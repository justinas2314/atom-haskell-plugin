{"Prelude": {"Bool": "", "False": "", "True": "", "minBound": "a", "maxBound": "a", "&&": "Bool -> Bool -> Bool infixr 3", "||": "Bool -> Bool -> Bool infixr 2", "not": "Bool -> Bool", "otherwise": "Bool", "Maybe": "", "Nothing": "", "Just": "a", ">>=": "a a -> (a -> a b) -> a b", ">>": "a a -> a b -> a b", "return": "a -> a a", "maybe": "b -> (a -> b) -> Maybe a -> b", "Either": "", "Left": "a", "Right": "b", "liftShowsPrec2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> Either a b -> ShowS", "liftShowList2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [Either a b] -> ShowS", "either": "(a -> c) -> (b -> c) -> Either a b -> c", "Ordering": "", "LT": "", "EQ": "", "GT": "", "Char": "", "String": "", "fst": "(a, b) -> a", "snd": "(a, b) -> b", "curry": "((a, b) -> c) -> a -> b -> c", "uncurry": "(a -> b -> c) -> (a, b) -> c", "Eq": "", "==": "a -> a -> Bool infix 4", "/=": "a -> a -> Bool infix 4", "compare": "a -> a -> Ordering", "<": "a -> a -> Bool infix 4", "<=": "a -> a -> Bool infix 4", ">": "a -> a -> Bool infix 4", ">=": "a -> a -> Bool infix 4", "max": "a -> a -> a", "min": "a -> a -> a", "Enum": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "Bounded": "", "Int": "", "Integer": "", "Float": "", "Double": "", "Rational": "", "Word": "", "Num": "", "+": "a -> a -> a infixl 6", "-": "a -> a -> a infixl 6", "*": "a -> a -> a infixl 7", "negate": "a -> a", "abs": "a -> a", "signum": "a -> a", "fromInteger": "Integer -> a", "toRational": "a -> Rational", "Real": "", "quot": "a -> a -> a infixl 7", "rem": "a -> a -> a infixl 7", "div": "a -> a -> a infixl 7", "mod": "a -> a -> a infixl 7", "quotRem": "a -> a -> (a, a)", "divMod": "a -> a -> (a, a)", "toInteger": "a -> Integer", "/": "a -> a -> a infixl 7", "recip": "a -> a", "fromRational": "Rational -> a", "Fractional": "", "pi": "a", "exp": "a -> a", "log": "a -> a", "sqrt": "a -> a", "**": "a -> a -> a infixr 8", "logBase": "a -> a -> a", "sin": "a -> a", "cos": "a -> a", "tan": "a -> a", "asin": "a -> a", "acos": "a -> a", "atan": "a -> a", "sinh": "a -> a", "cosh": "a -> a", "tanh": "a -> a", "asinh": "a -> a", "acosh": "a -> a", "atanh": "a -> a", "properFraction": "Integral b => a -> (b, a)", "truncate": "Integral b => a -> b", "round": "Integral b => a -> b", "ceiling": "Integral b => a -> b", "floor": "Integral b => a -> b", "RealFrac": "", "floatRadix": "a -> Integer", "floatDigits": "a -> Int", "floatRange": "a -> (Int, Int)", "decodeFloat": "a -> (Integer, Int)", "encodeFloat": "Integer -> Int -> a", "exponent": "a -> Int", "significand": "a -> a", "scaleFloat": "Int -> a -> a", "isNaN": "a -> Bool", "isInfinite": "a -> Bool", "isDenormalized": "a -> Bool", "isNegativeZero": "a -> Bool", "isIEEE": "a -> Bool", "atan2": "a -> a -> a", "subtract": "Num a => a -> a -> a", "even": "Integral a => a -> Bool", "odd": "Integral a => a -> Bool", "gcd": "Integral a => a -> a -> a", "lcm": "Integral a => a -> a -> a", "^": "(Num a, Integral b) => a -> b -> a infixr 8", "^^": "(Fractional a, Integral b) => a -> b -> a infixr 8", "fromIntegral": "(Integral a, Num b) => a -> b", "realToFrac": "(Real a, Fractional b) => a -> b", "Semigroup": "", "<>": "a -> a -> a infixr 6", "mempty": "a", "mappend": "a -> a -> a", "mconcat": "[a] -> a", "Functor": "", "fmap": "(a -> b) -> f a -> f b", "<$": "a -> f b -> f a infixl 4", "<$>": "Functor f => (a -> b) -> f a -> f b infixl 4", "pure": "a -> f a", "<*>": "f (a -> b) -> f a -> f b infixl 4", "*>": "f a -> f b -> f b infixl 4", "<*": "f a -> f b -> f a infixl 4", "Applicative": "", "Monad": "", "fail": "String -> m a", "mapM_": "(Foldable t, Monad m) => (a -> m b) -> t a -> m ()", "sequence_": "(Foldable t, Monad m) => t (m a) -> m ()", "=<<": "Monad m => (a -> m b) -> m a -> m b infixr 1", "Foldable": "", "foldMap": "Monoid m => (a -> m) -> t a -> m", "foldr": "(a -> b -> b) -> b -> t a -> b", "foldl": "(b -> a -> b) -> b -> t a -> b", "foldr1": "(a -> a -> a) -> t a -> a", "foldl1": "(a -> a -> a) -> t a -> a", "elem": "Eq a => a -> t a -> Bool infix 4", "maximum": "forall a. Ord a => t a -> a", "minimum": "forall a. Ord a => t a -> a", "sum": "Num a => t a -> a", "product": "Num a => t a -> a", "traverse": "Applicative f => (a -> f b) -> t a -> f (t b)", "sequenceA": "Applicative f => t (f a) -> f (t a)", "mapM": "Monad m => (a -> m b) -> t a -> m (t b)", "sequence": "Monad m => t (m a) -> m (t a)", "id": "a -> a", "const": "a -> b -> a", ".": "(b -> c) -> (a -> b) -> a -> c infixr 9", "flip": "(a -> b -> c) -> b -> a -> c", "::": "", "until": "(a -> Bool) -> (a -> a) -> a -> a", "asTypeOf": "a -> a -> a", "map": "(a -> b) -> [a] -> [b]", "++": "[a] -> [a] -> [a] infixr 5", "filter": "(a -> Bool) -> [a] -> [a]", "head": "[a] -> a", "last": "[a] -> a", "tail": "[a] -> [a]", "init": "[a] -> [a]", "!!": "[a] -> Int -> a infixl 9", "null": "Foldable t => t a -> Bool", "length": "Foldable t => t a -> Int", "reverse": "[a] -> [a]", "and": "Foldable t => t Bool -> Bool", "or": "Foldable t => t Bool -> Bool", "any": "Foldable t => (a -> Bool) -> t a -> Bool", "all": "Foldable t => (a -> Bool) -> t a -> Bool", "concat": "Foldable t => t [a] -> [a]", "concatMap": "Foldable t => (a -> [b]) -> t a -> [b]", "scanl": "(b -> a -> b) -> b -> [a] -> [b]", "scanl1": "(a -> a -> a) -> [a] -> [a]", "scanr": "(a -> b -> b) -> b -> [a] -> [b]", "scanr1": "(a -> a -> a) -> [a] -> [a]", "iterate": "(a -> a) -> a -> [a]", "repeat": "a -> [a]", "replicate": "Int -> a -> [a]", "cycle": "[a] -> [a]", "take": "Int -> [a] -> [a]", "drop": "Int -> [a] -> [a]", "takeWhile": "(a -> Bool) -> [a] -> [a]", "dropWhile": "(a -> Bool) -> [a] -> [a]", "span": "(a -> Bool) -> [a] -> ([a], [a])", "break": "(a -> Bool) -> [a] -> ([a], [a])", "splitAt": "Int -> [a] -> ([a], [a])", "notElem": "(Foldable t, Eq a) => a -> t a -> Bool infix 4", "lookup": "Eq a => a -> [(a, b)] -> Maybe b", "zip": "[a] -> [b] -> [(a, b)]", "zip3": "[a] -> [b] -> [c] -> [(a, b, c)]", "zipWith": "(a -> b -> c) -> [a] -> [b] -> [c]", "zipWith3": "(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]", "unzip": "[(a, b)] -> ([a], [b])", "unzip3": "[(a, b, c)] -> ([a], [b], [c])", "lines": "String -> [String]", "words": "String -> [String]", "unlines": "[String] -> String", "unwords": "[String] -> String", "ShowS": "", "Show": "", "showsPrec": "", "->": "a", "show": "a -> String", "showList": "[a] -> ShowS", "shows": "Show a => a -> ShowS", "showChar": "Char -> ShowS", "showString": "String -> ShowS", "showParen": "Bool -> ShowS -> ShowS", "ReadS": "", "Read": "", "readsPrec": "", "readList": "ReadS [a]", "reads": "Read a => ReadS a", "readParen": "Bool -> ReadS a -> ReadS a", "read": "Read a => String -> a", "lex": "ReadS String", "IO": "", "putChar": "Char -> IO ()", "putStr": "String -> IO ()", "putStrLn": "String -> IO ()", "print": "Show a => a -> IO ()", "getChar": "IO Char", "getLine": "IO String", "getContents": "IO String", "interact": "(String -> String) -> IO ()", "FilePath": "", "readFile": "FilePath -> IO String", "writeFile": "FilePath -> String -> IO ()", "appendFile": "FilePath -> String -> IO ()", "readIO": "Read a => String -> IO a", "readLn": "Read a => IO a", "IOError": "", "ioError": "IOError -> IO a", "userError": "String -> IOError"}, "Control.Applicative": {"Functor": "", "pure": "a -> f a", "<*>": "f (a -> b) -> f a -> f b infixl 4", "liftA2": "(a -> b -> c) -> f a -> f b -> f c", "*>": "f a -> f b -> f b infixl 4", "<*": "f a -> f b -> f a infixl 4", "Applicative": "", "empty": "f a", "<|>": "f a -> f a -> f a infixl 3", "some": "f a -> f [a]", "many": "f a -> f [a]", "Const": "", "getConst": "a", "from1": "forall (a0 a b a c d e f g h", "to1": "forall (a0 a Rep1 b c d e f g c", "WrappedMonad": "", "WrapMonad": "", "unwrapMonad": "m a", ">>=": "WrappedMonad m a -> (a -> WrappedMonad m b) -> WrappedMonad m b", ">>": "WrappedMonad m a -> WrappedMonad m b -> WrappedMonad m b", "return": "a -> WrappedMonad m a", "WrappedArrow": "", "WrapArrow": "", "unwrapArrow": "a b c", "ZipList": "", "getZipList": "[a]", "fmap": "(a -> b) -> ZipList a -> ZipList b", "<$": "a b c d -> b e", "<$>": "Functor f => (a -> b) -> f a -> f b infixl 4", "<**>": "Applicative f => f a -> f (a -> b) -> f b infixl 4", "liftA": "Applicative f => (a -> b) -> f a -> f b", "liftA3": "Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d", "optional": "Alternative f => f a -> f (Maybe a)"}, "Control.Arrow": {"Category": "", "arr": "(b -> c) -> a b c", "first": "a b c -> a (b, d) (c, d)", "second": "a b c -> a (d, b) (d, c)", "***": "a b c -> a b' c' -> a (b, b') (c, c') infixr 3", "&&&": "a b c -> a b c' -> a b (c, c') infixr 3", "Kleisli": "", "runKleisli": "a -> m b", "loop": "a b c d e d f a b", "returnA": "Arrow a => a b b", "^>>": "Arrow a => (b -> c) -> a c d -> a b d infixr 1", ">>^": "Arrow a => a b c -> (c -> d) -> a b d infixr 1", ">>>": "Category cat => cat a b -> cat b c -> cat a c infixr 1", "<<<": "Category cat => cat b c -> cat a b -> cat a c infixr 1", "<<^": "Arrow a => a c d -> (b -> c) -> a b d infixr 1", "^<<": "Arrow a => (c -> d) -> a b c -> a b d infixr 1", "Arrow": "", "zeroArrow": "a b c", "ArrowZero": "", "<+>": "a b c -> a b c -> a b c infixr 5", "left": "a b c -> a (Either b d) (Either c d)", "right": "a b c -> a (Either d b) (Either d c)", "+++": "a b c -> a b' c' -> a (Either b b') (Either c c') infixr 2", "|||": "a b d -> a c d -> a (Either b c) d infixr 2", "app": "a (a b c, b) c", "ArrowMonad": "", ">>=": "ArrowMonad a a0 -> (a0 -> ArrowMonad a b) -> ArrowMonad a b", ">>": "ArrowMonad a a0 -> ArrowMonad a b -> ArrowMonad a b", "return": "a0 -> ArrowMonad a a0", "leftApp": "ArrowApply a => a b c -> a (Either b d) (Either c d)"}, "Control.Category": {"Category": "", "id": "cat a a", ".": "cat b c -> cat a b -> cat a c infixr 9", "<<<": "Category cat => cat b c -> cat a b -> cat a c infixr 1", ">>>": "Category cat => cat a b -> cat b c -> cat a c infixr 1"}, "Control.Concurrent": {"ThreadId": "", "==": "ThreadId -> ThreadId -> Bool", "/=": "ThreadId -> ThreadId -> Bool", "myThreadId": "IO ThreadId", "forkIO": "IO () -> IO ThreadId", "forkFinally": "IO a -> (Either SomeException a -> IO ()) -> IO ThreadId", "::": "", "killThread": "ThreadId -> IO ()", "throwTo": "Exception e => ThreadId -> e -> IO ()", "forkOn": "Int -> IO () -> IO ThreadId", "getNumCapabilities": "IO Int", "setNumCapabilities": "Int -> IO ()", "threadCapability": "ThreadId -> IO (Int, Bool)", "yield": "IO ()", "threadDelay": "Int -> IO ()", "threadWaitRead": "Fd -> IO ()", "threadWaitWrite": "Fd -> IO ()", "threadWaitReadSTM": "Fd -> IO (STM (), IO ())", "threadWaitWriteSTM": "Fd -> IO (STM (), IO ())", "module": "a", "rtsSupportsBoundThreads": "Bool", "forkOS": "IO () -> IO ThreadId", "isCurrentThreadBound": "IO Bool", "runInBoundThread": "IO a -> IO a", "runInUnboundThread": "IO a -> IO a", "mkWeakThreadId": "ThreadId -> IO (Weak ThreadId)"}, "Control.Concurrent.Chan": {"Chan": "", "==": "Chan a -> Chan a -> Bool", "/=": "Chan a -> Chan a -> Bool", "newChan": "IO (Chan a)", "writeChan": "Chan a -> a -> IO ()", "readChan": "Chan a -> IO a", "dupChan": "Chan a -> IO (Chan a)", "getChanContents": "Chan a -> IO [a]", "writeList2Chan": "Chan a -> [a] -> IO ()"}, "Control.Concurrent.MVar": {"MVar": "", "==": "MVar a -> MVar a -> Bool", "/=": "MVar a -> MVar a -> Bool", "newEmptyMVar": "IO (MVar a)", "newMVar": "a -> IO (MVar a)", "takeMVar": "MVar a -> IO a", "putMVar": "MVar a -> a -> IO ()", "readMVar": "MVar a -> IO a", "swapMVar": "MVar a -> a -> IO a", "tryTakeMVar": "MVar a -> IO (Maybe a)", "tryPutMVar": "MVar a -> a -> IO Bool", "isEmptyMVar": "MVar a -> IO Bool", "withMVar": "MVar a -> (a -> IO b) -> IO b", "withMVarMasked": "MVar a -> (a -> IO b) -> IO b", "modifyMVar_": "MVar a -> (a -> IO a) -> IO ()", "modifyMVar": "MVar a -> (a -> IO (a, b)) -> IO b", "modifyMVarMasked_": "MVar a -> (a -> IO a) -> IO ()", "modifyMVarMasked": "MVar a -> (a -> IO (a, b)) -> IO b", "tryReadMVar": "MVar a -> IO (Maybe a)", "mkWeakMVar": "MVar a -> IO () -> IO (Weak (MVar a))", "addMVarFinalizer": "MVar a -> IO () -> IO ()"}, "Control.Concurrent.QSem": {"QSem": "", "newQSem": "Int -> IO QSem", "waitQSem": "QSem -> IO ()", "signalQSem": "QSem -> IO ()"}, "Control.Concurrent.QSemN": {"QSemN": "", "newQSemN": "Int -> IO QSemN", "waitQSemN": "QSemN -> Int -> IO ()", "signalQSemN": "QSemN -> Int -> IO ()"}, "Control.Exception": {"SomeException": "", "forall": "e.Exception e => a b", "showsPrec": "Int -> a -> ShowS", "show": "a -> String", "showList": "[a] -> ShowS", "Typeable": "", "toException": "e -> SomeException", "fromException": "SomeException -> Maybe e", "displayException": "e -> String", "IOException": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "ArithException": "", "Overflow": "", "Underflow": "", "LossOfPrecision": "", "DivideByZero": "", "Denormal": "", "RatioZeroDenominator": "", "ArrayException": "", "IndexOutOfBounds": "String", "UndefinedElement": "String", "AssertionFailed": "", "SomeAsyncException": "", "AsyncException": "", "StackOverflow": "", "HeapOverflow": "", "ThreadKilled": "", "UserInterrupt": "", "asyncExceptionToException": "Exception e => e -> SomeException", "asyncExceptionFromException": "Exception e => SomeException -> Maybe e", "NonTermination": "", "NestedAtomically": "", "BlockedIndefinitelyOnMVar": "", "BlockedIndefinitelyOnSTM": "", "AllocationLimitExceeded": "", "CompactionFailed": "", "Deadlock": "", "NoMethodError": "", "PatternMatchFail": "", "RecConError": "", "RecSelError": "", "RecUpdError": "", "ErrorCall": "", "ErrorCallWithLocation": "String String", "TypeError": "", "::": "", "throwIO": "Exception e => e -> IO a", "ioError": "IOError -> IO a", "throwTo": "Exception e => ThreadId -> e -> IO ()", "catch": "", "catches": "IO a -> [Handler a] -> IO a", "Handler": "", "fmap": "(a -> b) -> Handler a -> Handler b", "<$": "a -> Handler b -> Handler a", "catchJust": "", "handle": "Exception e => (e -> IO a) -> IO a -> IO a", "handleJust": "Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a", "try": "Exception e => IO a -> IO (Either e a)", "tryJust": "Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)", "evaluate": "a -> IO a", "mapException": "(Exception e1, Exception e2) => (e1 -> e2) -> a -> a", "mask_": "IO a -> IO a", "uninterruptibleMask_": "IO a -> IO a", "MaskingState": "", "Unmasked": "", "MaskedInterruptible": "", "MaskedUninterruptible": "", "getMaskingState": "IO MaskingState", "interruptible": "IO a -> IO a", "allowInterrupt": "IO ()", "assert": "Bool -> a -> a", "bracket": "", "bracket_": "IO a -> IO b -> IO c -> IO c", "bracketOnError": "", "finally": "", "onException": "IO a -> IO b -> IO a"}, "Control.Exception.Base": {"SomeException": "", "forall": "e.Exception e => a e", "showsPrec": "Int -> a -> ShowS", "show": "a -> String", "showList": "[a] -> ShowS", "Typeable": "", "toException": "e -> SomeException", "fromException": "SomeException -> Maybe e", "displayException": "e -> String", "IOException": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "ArithException": "", "Overflow": "", "Underflow": "", "LossOfPrecision": "", "DivideByZero": "", "Denormal": "", "RatioZeroDenominator": "", "ArrayException": "", "IndexOutOfBounds": "String", "UndefinedElement": "String", "AssertionFailed": "", "SomeAsyncException": "", "AsyncException": "", "StackOverflow": "", "HeapOverflow": "", "ThreadKilled": "", "UserInterrupt": "", "asyncExceptionToException": "Exception e => e -> SomeException", "asyncExceptionFromException": "Exception e => SomeException -> Maybe e", "NonTermination": "", "NestedAtomically": "", "BlockedIndefinitelyOnMVar": "", "FixIOException": "", "BlockedIndefinitelyOnSTM": "", "AllocationLimitExceeded": "", "CompactionFailed": "", "Deadlock": "", "NoMethodError": "", "PatternMatchFail": "", "RecConError": "", "RecSelError": "", "RecUpdError": "", "ErrorCall": "", "ErrorCallWithLocation": "String String", "TypeError": "", "throwIO": "Exception e => e -> IO a", "::": "", "ioError": "IOError -> IO a", "throwTo": "Exception e => ThreadId -> e -> IO ()", "catch": "", "catchJust": "", "handle": "Exception e => (e -> IO a) -> IO a -> IO a", "handleJust": "Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a", "try": "Exception e => IO a -> IO (Either e a)", "tryJust": "Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)", "onException": "IO a -> IO b -> IO a", "evaluate": "a -> IO a", "mapException": "(Exception e1, Exception e2) => (e1 -> e2) -> a -> a", "mask_": "IO a -> IO a", "uninterruptibleMask_": "IO a -> IO a", "MaskingState": "", "Unmasked": "", "MaskedInterruptible": "", "MaskedUninterruptible": "", "getMaskingState": "IO MaskingState", "assert": "Bool -> a -> a", "bracket": "", "bracket_": "IO a -> IO b -> IO c -> IO c", "bracketOnError": "", "finally": "", "recSelError": "Addr# -> a", "recConError": "Addr# -> a", "runtimeError": "Addr# -> a", "nonExhaustiveGuardsError": "Addr# -> a", "patError": "Addr# -> a", "noMethodBindingError": "Addr# -> a", "absentError": "Addr# -> a", "typeError": "Addr# -> a", "nonTermination": "SomeException", "nestedAtomically": "SomeException"}, "Control.Monad": {"Functor": "", "fmap": "(a -> b) -> f a -> f b", "<$": "a -> f b -> f a infixl 4", "Applicative": "", ">>=": "forall a b. m a -> (a -> m b) -> m b infixl 1", ">>": "forall a b. m a -> m b -> m b infixl 1", "return": "a -> m a", "Monad": "", "fail": "String -> m a", "Alternative": "", "mzero": "m a", "mplus": "m a -> m a -> m a", "mapM": "(Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)", "mapM_": "(Foldable t, Monad m) => (a -> m b) -> t a -> m ()", "forM": "(Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)", "forM_": "(Foldable t, Monad m) => t a -> (a -> m b) -> m ()", "sequence": "(Traversable t, Monad m) => t (m a) -> m (t a)", "sequence_": "(Foldable t, Monad m) => t (m a) -> m ()", "=<<": "Monad m => (a -> m b) -> m a -> m b infixr 1", ">=>": "Monad m => (a -> m b) -> (b -> m c) -> a -> m c infixr 1", "<=<": "Monad m => (b -> m c) -> (a -> m b) -> a -> m c infixr 1", "forever": "Applicative f => f a -> f b", "void": "Functor f => f a -> f ()", "join": "Monad m => m (m a) -> m a", "msum": "(Foldable t, MonadPlus m) => t (m a) -> m a", "mfilter": "MonadPlus m => (a -> Bool) -> m a -> m a", "filterM": "Applicative m => (a -> m Bool) -> [a] -> m [a]", "mapAndUnzipM": "Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])", "zipWithM": "Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]", "zipWithM_": "Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()", "foldM": "(Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b", "foldM_": "(Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()", "replicateM": "Applicative m => Int -> m a -> m [a]", "replicateM_": "Applicative m => Int -> m a -> m ()", "guard": "Alternative f => Bool -> f ()", "when": "Applicative f => Bool -> f () -> f ()", "unless": "Applicative f => Bool -> f () -> f ()", "liftM": "Monad m => (a1 -> r) -> m a1 -> m r", "liftM2": "Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r", "liftM3": "Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r", "liftM4": "Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r", "liftM5": "Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r", "ap": "Monad m => m (a -> b) -> m a -> m b", "<$!>": "Monad m => (a -> b) -> m a -> m b infixl 4"}, "Control.Monad.Fail": {"Monad": "", "fail": "String -> m a"}, "Control.Monad.Fix": {"Monad": "", "mfix": "(a -> m a) -> m a", "fix": "(a -> a) -> a"}, "Control.Monad.IO.Class": {"Monad": "", "liftIO": "IO a -> m a"}, "Control.Monad.Instances": {"Functor": "", "fmap": "(a -> b) -> f a -> f b", "<$": "a -> f b -> f a infixl 4", "Applicative": "", ">>=": "forall a b. m a -> (a -> m b) -> m b infixl 1", ">>": "forall a b. m a -> m b -> m b infixl 1", "return": "a -> m a"}, "Control.Monad.ST": {"ST": "", ">>=": "ST s a -> (a -> ST s b) -> ST s b", ">>": "ST s a -> ST s b -> ST s b", "return": "a -> ST s a", "::": "", "fixST": "(a -> ST s a) -> ST s a", "RealWorld": "", "stToIO": "ST RealWorld a -> IO a"}, "Control.Monad.ST.Lazy": {"ST": "", ">>=": "ST s a -> (a -> ST s b) -> ST s b", ">>": "ST s a -> ST s b -> ST s b", "return": "a -> ST s a", "::": "", "fixST": "(a -> ST s a) -> ST s a", "strictToLazyST": "ST s a -> ST s a", "lazyToStrictST": "ST s a -> ST s a", "RealWorld": "", "stToIO": "ST RealWorld a -> IO a"}, "Control.Monad.ST.Lazy.Safe": {"ST": "", ">>=": "ST s a -> (a -> ST s b) -> ST s b", ">>": "ST s a -> ST s b -> ST s b", "return": "a -> ST s a", "::": "", "fixST": "(a -> ST s a) -> ST s a", "strictToLazyST": "ST s a -> ST s a", "lazyToStrictST": "ST s a -> ST s a", "RealWorld": "", "stToIO": "ST RealWorld a -> IO a"}, "Control.Monad.ST.Lazy.Unsafe": {"unsafeInterleaveST": "ST s a -> ST s a", "unsafeIOToST": "IO a -> ST s a"}, "Control.Monad.ST.Safe": {"ST": "", ">>=": "ST s a -> (a -> ST s b) -> ST s b", ">>": "ST s a -> ST s b -> ST s b", "return": "a -> ST s a", "::": "", "fixST": "(a -> ST s a) -> ST s a", "RealWorld": "", "stToIO": "ST RealWorld a -> IO a"}, "Control.Monad.ST.Strict": {"module": "Control.Monad.ST"}, "Control.Monad.ST.Unsafe": {"unsafeInterleaveST": "ST s a -> ST s a", "unsafeDupableInterleaveST": "ST s a -> ST s a", "unsafeIOToST": "IO a -> ST s a", "unsafeSTToIO": "ST s a -> IO a"}, "Control.Monad.Zip": {"Monad": "", "mzip": "m a -> m b -> m (a, b)", "mzipWith": "(a -> b -> c) -> m a -> m b -> m c", "munzip": "m (a, b) -> (m a, m b)"}, "Data.Bifoldable": {"Bifoldable": "", "bifold": "Monoid m => p m m -> m", "bifoldMap": "Monoid m => (a -> m) -> (b -> m) -> p a b -> m", "bifoldr": "(a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c", "bifoldl": "(c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c", "bifoldr'": "Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c", "bifoldr1": "Bifoldable t => (a -> a -> a) -> t a a -> a", "bifoldrM": "(Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c", "bifoldl'": "Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a", "bifoldl1": "Bifoldable t => (a -> a -> a) -> t a a -> a", "bifoldlM": "(Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a", "bitraverse_": "(Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()", "bifor_": "(Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()", "bimapM_": "(Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()", "biforM_": "(Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()", "bimsum": "(Bifoldable t, Alternative f) => t (f a) (f a) -> f a", "bisequenceA_": "(Bifoldable t, Applicative f) => t (f a) (f b) -> f ()", "bisequence_": "(Bifoldable t, Applicative f) => t (f a) (f b) -> f ()", "biasum": "(Bifoldable t, Alternative f) => t (f a) (f a) -> f a", "biList": "Bifoldable t => t a a -> [a]", "binull": "Bifoldable t => t a b -> Bool", "bilength": "Bifoldable t => t a b -> Int", "bielem": "(Bifoldable t, Eq a) => a -> t a a -> Bool", "::": "", "bisum": "(Bifoldable t, Num a) => t a a -> a", "biproduct": "(Bifoldable t, Num a) => t a a -> a", "biconcat": "Bifoldable t => t [a] [a] -> [a]", "biconcatMap": "Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]", "biand": "Bifoldable t => t Bool Bool -> Bool", "bior": "Bifoldable t => t Bool Bool -> Bool", "biany": "Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool", "biall": "Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool", "bimaximumBy": "Bifoldable t => (a -> a -> Ordering) -> t a a -> a", "biminimumBy": "Bifoldable t => (a -> a -> Ordering) -> t a a -> a", "binotElem": "(Bifoldable t, Eq a) => a -> t a a -> Bool", "bifind": "Bifoldable t => (a -> Bool) -> t a a -> Maybe a"}, "Data.Bifunctor": {"Bifunctor": "", "bimap": "(a -> b) -> (c -> d) -> p a c -> p b d", "first": "(a -> b) -> p a c -> p b c", "second": "(b -> c) -> p a b -> p a c"}, "Data.Bitraversable": {"Bifunctor": "", "bitraverse": "Applicative f => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)", "bisequenceA": "(Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)", "bisequence": "(Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)", "bimapM": "(Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)", "bifor": "(Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)", "biforM": "(Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)", "bimapAccumL": "Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)", "bimapAccumR": "Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)", "::": ""}, "Data.Bits": {"Eq": "", ".&.": "a -> a -> a infixl 7", ".|.": "a -> a -> a infixl 5", "xor": "a -> a -> a infixl 6", "complement": "a -> a", "shift": "a -> Int -> a infixl 8", "rotate": "a -> Int -> a infixl 8", "zeroBits": "a", "bit": "Int -> a", "setBit": "a -> Int -> a", "clearBit": "a -> Int -> a", "complementBit": "a -> Int -> a", "testBit": "a -> Int -> Bool", "bitSizeMaybe": "a -> Maybe Int", "bitSize": "a -> Int", "isSigned": "a -> Bool", "shiftL": "a -> Int -> a infixl 8", "unsafeShiftL": "a -> Int -> a", "shiftR": "a -> Int -> a infixl 8", "unsafeShiftR": "a -> Int -> a", "rotateL": "a -> Int -> a infixl 8", "rotateR": "a -> Int -> a infixl 8", "popCount": "a -> Int", "Bits": "", "finiteBitSize": "b -> Int", "countLeadingZeros": "b -> Int", "countTrailingZeros": "b -> Int", "bitDefault": "(Bits a, Num a) => Int -> a", "testBitDefault": "(Bits a, Num a) => a -> Int -> Bool", "popCountDefault": "(Bits a, Num a) => a -> Int", "toIntegralSized": "(Integral a, Integral b, Bits a, Bits b) => a -> Maybe b"}, "Data.Bool": {"Bool": "", "False": "", "True": "", "minBound": "Bool", "maxBound": "Bool", "&&": "Bool -> Bool -> Bool infixr 3", "||": "Bool -> Bool -> Bool infixr 2", "not": "Bool -> Bool", "otherwise": "Bool", "bool": "a -> a -> Bool -> a"}, "Data.Char": {"Char": "", "minBound": "a", "maxBound": "a", "isControl": "Char -> Bool", "isSpace": "Char -> Bool", "isLower": "Char -> Bool", "isUpper": "Char -> Bool", "isAlpha": "Char -> Bool", "isAlphaNum": "Char -> Bool", "isPrint": "Char -> Bool", "isDigit": "Char -> Bool", "isOctDigit": "Char -> Bool", "isHexDigit": "Char -> Bool", "isLetter": "Char -> Bool", "isMark": "Char -> Bool", "isNumber": "Char -> Bool", "isPunctuation": "Char -> Bool", "isSymbol": "Char -> Bool", "isSeparator": "Char -> Bool", "isAscii": "Char -> Bool", "isLatin1": "Char -> Bool", "isAsciiUpper": "Char -> Bool", "isAsciiLower": "Char -> Bool", "GeneralCategory": "", "UppercaseLetter": "", "LowercaseLetter": "", "TitlecaseLetter": "", "ModifierLetter": "", "OtherLetter": "", "NonSpacingMark": "", "SpacingCombiningMark": "", "EnclosingMark": "", "DecimalNumber": "", "LetterNumber": "", "OtherNumber": "", "ConnectorPunctuation": "", "DashPunctuation": "", "OpenPunctuation": "", "ClosePunctuation": "", "InitialQuote": "", "FinalQuote": "", "OtherPunctuation": "", "MathSymbol": "", "CurrencySymbol": "", "ModifierSymbol": "", "OtherSymbol": "", "Space": "", "LineSeparator": "", "ParagraphSeparator": "", "Control": "", "Format": "", "Surrogate": "", "PrivateUse": "", "NotAssigned": "", "generalCategory": "Char -> GeneralCategory", "toUpper": "Char -> Char", "toLower": "Char -> Char", "toTitle": "Char -> Char", "digitToInt": "Char -> Int", "intToDigit": "Int -> Char", "ord": "Char -> Int", "chr": "Int -> Char", "showLitChar": "Char -> ShowS", "lexLitChar": "ReadS String", "readLitChar": "ReadS Char"}, "Data.Coerce": {"::": "", "a": ""}, "Data.Complex": {"Complex": "", "!a": ":+ !a infix 6", ">>=": "Complex a -> (a -> Complex b) -> Complex b", ">>": "Complex a -> Complex b -> Complex b", "return": "a -> Complex a", "realPart": "Complex a -> a", "imagPart": "Complex a -> a", "mkPolar": "Floating a => a -> a -> Complex a", "cis": "Floating a => a -> Complex a", "polar": "RealFloat a => Complex a -> (a, a)", "magnitude": "RealFloat a => Complex a -> a", "phase": "RealFloat a => Complex a -> a", "conjugate": "Num a => Complex a -> Complex a"}, "Data.Data": {"module": "Data.Typeable", "Typeable": "", "gfoldl": "", "::": "", "->": "a", "gunfold": "(forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a", "toConstr": "a -> Constr", "dataTypeOf": "a -> DataType", "dataCast1": "Typeable t => (forall d. Data d => c (t d)) -> Maybe (c a)", "dataCast2": "Typeable t => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)", "gmapT": "(forall b. Data b => b -> b) -> a -> a", "gmapQl": "forall r r'. (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r", "gmapQr": "forall r r'. (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r", "gmapQ": "(forall d. Data d => d -> u) -> a -> [u]", "gmapQi": "forall u. Int -> (forall d. Data d => d -> u) -> a -> u", "gmapM": "forall m. Monad m => (forall d. Data d => d -> m d) -> a -> m a", "gmapMp": "forall m. MonadPlus m => (forall d. Data d => d -> m d) -> a -> m a", "gmapMo": "forall m. MonadPlus m => (forall d. Data d => d -> m d) -> a -> m a", "DataType": "", "showsPrec": "Int -> DataType -> ShowS", "show": "DataType -> String", "showList": "[DataType] -> ShowS", "mkDataType": "String -> [Constr] -> DataType", "mkIntType": "String -> DataType", "mkFloatType": "String -> DataType", "mkCharType": "String -> DataType", "mkNoRepType": "String -> DataType", "dataTypeName": "DataType -> String", "DataRep": "", "AlgRep": "[Constr]", "IntRep": "", "FloatRep": "", "CharRep": "", "NoRep": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "dataTypeRep": "DataType -> DataRep", "repConstr": "DataType -> ConstrRep -> Constr", "isAlgType": "DataType -> Bool", "dataTypeConstrs": "DataType -> [Constr]", "indexConstr": "DataType -> ConIndex -> Constr", "maxConstrIndex": "DataType -> ConIndex", "isNorepType": "DataType -> Bool", "Constr": "", "ConIndex": "", "Fixity": "", "Prefix": "", "Infix": "", "mkConstr": "DataType -> String -> [String] -> Fixity -> Constr", "mkIntegralConstr": "(Integral a, Show a) => DataType -> a -> Constr", "mkRealConstr": "(Real a, Show a) => DataType -> a -> Constr", "mkCharConstr": "DataType -> Char -> Constr", "constrType": "Constr -> DataType", "ConstrRep": "", "AlgConstr": "ConIndex", "IntConstr": "Integer", "FloatConstr": "Rational", "CharConstr": "Char", "constrRep": "Constr -> ConstrRep", "constrFields": "Constr -> [String]", "constrFixity": "Constr -> Fixity", "constrIndex": "Constr -> ConIndex", "showConstr": "Constr -> String", "readConstr": "DataType -> String -> Maybe Constr", "tyconUQname": "String -> String", "tyconModule": "String -> String", "fromConstr": "Data a => Constr -> a"}, "Data.Dynamic": {"Dynamic": "", "showsPrec": "Int -> Dynamic -> ShowS", "show": "Dynamic -> String", "showList": "[Dynamic] -> ShowS", "toDyn": "Typeable a => a -> Dynamic", "fromDyn": "", "Source": "", "dynApply": "Dynamic -> Dynamic -> Maybe Dynamic", "dynApp": "Dynamic -> Dynamic -> Dynamic", "dynTypeRep": "Dynamic -> SomeTypeRep", "Typeable": ""}, "Data.Either": {"Either": "", "Left": "a", "Right": "b", "liftShowsPrec2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> Either a b -> ShowS", "liftShowList2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [Either a b] -> ShowS", "either": "(a -> c) -> (b -> c) -> Either a b -> c", "lefts": "[Either a b] -> [a]", "rights": "[Either a b] -> [b]", "isLeft": "Either a b -> Bool", "isRight": "Either a b -> Bool", "fromLeft": "a -> Either a b -> a", "fromRight": "b -> Either a b -> b", "partitionEithers": "[Either a b] -> ([a], [b])"}, "Data.Eq": {"Eq": "", "==": "a -> a -> Bool infix 4", "/=": "a -> a -> Bool infix 4"}, "Data.Fixed": {"div'": "(Real a, Integral b) => a -> a -> b", "mod'": "Real a => a -> a -> a", "divMod'": "(Real a, Integral b) => a -> a -> (b, a)", "Fixed": "", "MkFixed": "Integer", "succ": "Fixed a -> Fixed a", "pred": "Fixed a -> Fixed a", "toEnum": "Int -> Fixed a", "fromEnum": "Fixed a -> Int", "enumFrom": "Fixed a -> [Fixed a]", "enumFromThen": "Fixed a -> Fixed a -> [Fixed a]", "enumFromTo": "Fixed a -> Fixed a -> [Fixed a]", "enumFromThenTo": "Fixed a -> Fixed a -> Fixed a -> [Fixed a]", "HasResolution": "", "resolution": "p a -> Integer", "showFixed": "HasResolution a => Bool -> Fixed a -> String", "E0": "", "Uni": "", "E1": "", "Deci": "", "E2": "", "Centi": "", "E3": "", "Milli": "", "E6": "", "Micro": "", "E9": "", "Nano": "", "E12": "", "Pico": ""}, "Data.Foldable": {"Foldable": "", "fold": "Monoid m => t m -> m", "foldMap": "Monoid m => (a -> m) -> t a -> m", "foldMap'": "Monoid m => (a -> m) -> t a -> m", "foldr": "(a -> b -> b) -> b -> t a -> b", "foldr'": "(a -> b -> b) -> b -> t a -> b", "foldl": "(b -> a -> b) -> b -> t a -> b", "foldl'": "(b -> a -> b) -> b -> t a -> b", "foldr1": "(a -> a -> a) -> t a -> a", "foldl1": "(a -> a -> a) -> t a -> a", "toList": "t a -> [a]", "null": "t a -> Bool", "length": "t a -> Int", "elem": "Eq a => a -> t a -> Bool infix 4", "maximum": "forall a. Ord a => t a -> a", "minimum": "forall a. Ord a => t a -> a", "sum": "Num a => t a -> a", "product": "Num a => t a -> a", "foldrM": "(Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b", "foldlM": "(Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b", "traverse_": "(Foldable t, Applicative f) => (a -> f b) -> t a -> f ()", "for_": "(Foldable t, Applicative f) => t a -> (a -> f b) -> f ()", "sequenceA_": "(Foldable t, Applicative f) => t (f a) -> f ()", "asum": "(Foldable t, Alternative f) => t (f a) -> f a", "mapM_": "(Foldable t, Monad m) => (a -> m b) -> t a -> m ()", "forM_": "(Foldable t, Monad m) => t a -> (a -> m b) -> m ()", "sequence_": "(Foldable t, Monad m) => t (m a) -> m ()", "msum": "(Foldable t, MonadPlus m) => t (m a) -> m a", "concat": "Foldable t => t [a] -> [a]", "concatMap": "Foldable t => (a -> [b]) -> t a -> [b]", "and": "Foldable t => t Bool -> Bool", "or": "Foldable t => t Bool -> Bool", "any": "Foldable t => (a -> Bool) -> t a -> Bool", "all": "Foldable t => (a -> Bool) -> t a -> Bool", "maximumBy": "Foldable t => (a -> a -> Ordering) -> t a -> a", "minimumBy": "Foldable t => (a -> a -> Ordering) -> t a -> a", "notElem": "(Foldable t, Eq a) => a -> t a -> Bool infix 4", "find": "Foldable t => (a -> Bool) -> t a -> Maybe a"}, "Data.Function": {"id": "a -> a", "const": "a -> b -> a", ".": "(b -> c) -> (a -> b) -> a -> c infixr 9", "flip": "(a -> b -> c) -> b -> a -> c", "::": "", "&": "a -> (a -> b) -> b infixl 1", "fix": "(a -> a) -> a", "on": "(b -> b -> c) -> (a -> b) -> a -> a -> c infixl 0"}, "Data.Functor": {"Functor": "", "fmap": "(a -> b) -> f a -> f b", "<$": "a -> f b -> f a infixl 4", "$>": "Functor f => f a -> b -> f b infixl 4", "<$>": "Functor f => (a -> b) -> f a -> f b infixl 4", "<&>": "Functor f => f a -> (a -> b) -> f b infixl 1", "void": "Functor f => f a -> f ()"}, "Data.Functor.Classes": {"Eq1": "", "liftEq": "(a -> b -> Bool) -> f a -> f b -> Bool", "eq1": "(Eq1 f, Eq a) => f a -> f a -> Bool", "liftCompare": "(a -> b -> Ordering) -> f a -> f b -> Ordering", "compare1": "(Ord1 f, Ord a) => f a -> f a -> Ordering", "Read1": "", "liftReadsPrec": "(Int -> ReadS a) -> ReadS [a] -> Int -> ReadS (f a)", "liftReadList": "(Int -> ReadS a) -> ReadS [a] -> ReadS [f a]", "liftReadPrec": "ReadPrec a -> ReadPrec [a] -> ReadPrec (f a)", "liftReadListPrec": "ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]", "readsPrec1": "(Read1 f, Read a) => Int -> ReadS (f a)", "readPrec1": "(Read1 f, Read a) => ReadPrec (f a)", "liftReadListDefault": "Read1 f => (Int -> ReadS a) -> ReadS [a] -> ReadS [f a]", "liftReadListPrecDefault": "Read1 f => ReadPrec a -> ReadPrec [a] -> ReadPrec [f a]", "Show1": "", "liftShowsPrec": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS", "liftShowList": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> [f a] -> ShowS", "showsPrec1": "(Show1 f, Show a) => Int -> f a -> ShowS", "Eq2": "", "liftEq2": "(a -> b -> Bool) -> (c -> d -> Bool) -> f a c -> f b d -> Bool", "eq2": "(Eq2 f, Eq a, Eq b) => f a b -> f a b -> Bool", "liftCompare2": "(a -> b -> Ordering) -> (c -> d -> Ordering) -> f a c -> f b d -> Ordering", "compare2": "(Ord2 f, Ord a, Ord b) => f a b -> f a b -> Ordering", "Read2": "", "liftReadsPrec2": "(Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> Int -> ReadS (f a b)", "liftReadList2": "(Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]", "liftReadPrec2": "ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec (f a b)", "liftReadListPrec2": "ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]", "readsPrec2": "(Read2 f, Read a, Read b) => Int -> ReadS (f a b)", "readPrec2": "(Read2 f, Read a, Read b) => ReadPrec (f a b)", "liftReadList2Default": "Read2 f => (Int -> ReadS a) -> ReadS [a] -> (Int -> ReadS b) -> ReadS [b] -> ReadS [f a b]", "liftReadListPrec2Default": "Read2 f => ReadPrec a -> ReadPrec [a] -> ReadPrec b -> ReadPrec [b] -> ReadPrec [f a b]", "Show2": "", "liftShowsPrec2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS", "liftShowList2": "(Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> [f a b] -> ShowS", "showsPrec2": "(Show2 f, Show a, Show b) => Int -> f a b -> ShowS", "readsData": "(String -> ReadS a) -> Int -> ReadS a", "readData": "ReadPrec a -> ReadPrec a", "readsUnaryWith": "(Int -> ReadS a) -> String -> (a -> t) -> String -> ReadS t", "readUnaryWith": "ReadPrec a -> String -> (a -> t) -> ReadPrec t", "readsBinaryWith": "(Int -> ReadS a) -> (Int -> ReadS b) -> String -> (a -> b -> t) -> String -> ReadS t", "readBinaryWith": "ReadPrec a -> ReadPrec b -> String -> (a -> b -> t) -> ReadPrec t", "showsUnaryWith": "(Int -> a -> ShowS) -> String -> Int -> a -> ShowS", "showsBinaryWith": "(Int -> a -> ShowS) -> (Int -> b -> ShowS) -> String -> Int -> a -> b -> ShowS", "readsUnary": "Read a => String -> (a -> t) -> String -> ReadS t", "readsUnary1": "(Read1 f, Read a) => String -> (f a -> t) -> String -> ReadS t", "readsBinary1": "(Read1 f, Read1 g, Read a) => String -> (f a -> g a -> t) -> String -> ReadS t", "showsUnary": "Show a => String -> Int -> a -> ShowS", "showsUnary1": "(Show1 f, Show a) => String -> Int -> f a -> ShowS", "showsBinary1": "(Show1 f, Show1 g, Show a) => String -> Int -> f a -> g a -> ShowS"}, "Data.Functor.Compose": {"Compose": "", "getCompose": "f (g a)", "from1": "forall (a k0). Compose f g a -> Rep1 (Compose f g) a", "to1": "forall (a k0). Rep1 (Compose f g) a -> Compose f g a"}, "Data.Functor.Const": {"Const": "", "getConst": "a", "from1": "forall (a0 k0). Const a a0 -> Rep1 (Const a) a0", "to1": "forall (a0 k0). Rep1 (Const a) a0 -> Const a a0"}, "Data.Functor.Contravariant": {"Contravariant": "", "contramap": "(a' -> a) -> a a -> a a'", ">$": "b -> a b -> a a", "phantom": "(Functor f, Contravariant f) => f a -> f b", ">$<": "Contravariant f => (a -> b) -> f b -> f a infixl 4", ">$$<": "Contravariant f => f b -> (a -> b) -> f a infixl 4", "$<": "Contravariant f => f b -> b -> f a infixl 4", "Predicate": "", "getPredicate": "a -> Bool", "Comparison": "", "getComparison": "a -> a -> Ordering", "defaultComparison": "Ord a => Comparison a", "Equivalence": "", "getEquivalence": "a -> a -> Bool", "defaultEquivalence": "Eq a => Equivalence a", "comparisonEquivalence": "Comparison a -> Equivalence a", "Op": "", "getOp": "b -> a"}, "Data.Functor.Identity": {"Identity": "", "runIdentity": "a", ">>=": "Identity a -> (a -> Identity b) -> Identity b", ">>": "Identity a -> Identity b -> Identity b", "return": "a -> Identity a"}, "Data.Functor.Product": {"Product": "", "Pair": "(f a) (g a)", "from1": "forall (a k0). Product f g a -> Rep1 (Product f g) a", "to1": "forall (a k0). Rep1 (Product f g) a -> Product f g a"}, "Data.Functor.Sum": {"Sum": "", "InL": "(f a)", "InR": "(g a)", "from1": "forall (a k0). Sum f g a -> Rep1 (Sum f g) a", "to1": "forall (a k0). Rep1 (Sum f g) a -> Sum f g a"}, "Data.IORef": {"IORef": "", "==": "IORef a -> IORef a -> Bool", "/=": "IORef a -> IORef a -> Bool", "newIORef": "a -> IO (IORef a)", "readIORef": "IORef a -> IO a", "writeIORef": "IORef a -> a -> IO ()", "modifyIORef": "IORef a -> (a -> a) -> IO ()", "modifyIORef'": "IORef a -> (a -> a) -> IO ()", "atomicModifyIORef": "IORef a -> (a -> (a, b)) -> IO b", "atomicModifyIORef'": "IORef a -> (a -> (a, b)) -> IO b", "atomicWriteIORef": "IORef a -> a -> IO ()", "mkWeakIORef": "IORef a -> IO () -> IO (Weak (IORef a))"}, "Data.Int": {"Int": "", "minBound": "a", "maxBound": "a", "Int8": "", "Int16": "", "Int32": "", "Int64": ""}, "Data.Ix": {"Ord": "", "range": "(a, a) -> [a]", "index": "(a, a) -> a -> Int", "inRange": "(a, a) -> a -> Bool", "rangeSize": "(a, a) -> Int"}, "Data.Kind": {"Type": "", "Constraint": "", "FUN": "", "id": "forall (a k). a -> a", ".": "forall (b k) (c k) (a k). (b -> c) -> (a -> b) -> a -> c"}, "Data.List": {"++": "[a] -> [a] -> [a] infixr 5", "head": "[a] -> a", "last": "[a] -> a", "tail": "[a] -> [a]", "init": "[a] -> [a]", "uncons": "[a] -> Maybe (a, [a])", "singleton": "a -> [a]", "null": "Foldable t => t a -> Bool", "length": "Foldable t => t a -> Int", "map": "(a -> b) -> [a] -> [b]", "reverse": "[a] -> [a]", "intersperse": "a -> [a] -> [a]", "intercalate": "[a] -> [[a]] -> [a]", "transpose": "[[a]] -> [[a]]", "subsequences": "[a] -> [[a]]", "permutations": "[a] -> [[a]]", "foldl": "Foldable t => (b -> a -> b) -> b -> t a -> b", "foldl'": "Foldable t => (b -> a -> b) -> b -> t a -> b", "foldl1": "Foldable t => (a -> a -> a) -> t a -> a", "foldl1'": "(a -> a -> a) -> [a] -> a", "foldr": "Foldable t => (a -> b -> b) -> b -> t a -> b", "foldr1": "Foldable t => (a -> a -> a) -> t a -> a", "concat": "Foldable t => t [a] -> [a]", "concatMap": "Foldable t => (a -> [b]) -> t a -> [b]", "and": "Foldable t => t Bool -> Bool", "or": "Foldable t => t Bool -> Bool", "any": "Foldable t => (a -> Bool) -> t a -> Bool", "all": "Foldable t => (a -> Bool) -> t a -> Bool", "sum": "(Foldable t, Num a) => t a -> a", "product": "(Foldable t, Num a) => t a -> a", "::": "", "scanl": "(b -> a -> b) -> b -> [a] -> [b]", "scanl'": "(b -> a -> b) -> b -> [a] -> [b]", "scanl1": "(a -> a -> a) -> [a] -> [a]", "scanr": "(a -> b -> b) -> b -> [a] -> [b]", "scanr1": "(a -> a -> a) -> [a] -> [a]", "mapAccumL": "Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)", "mapAccumR": "Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)", "iterate": "(a -> a) -> a -> [a]", "iterate'": "(a -> a) -> a -> [a]", "repeat": "a -> [a]", "replicate": "Int -> a -> [a]", "cycle": "[a] -> [a]", "unfoldr": "(b -> Maybe (a, b)) -> b -> [a]", "take": "Int -> [a] -> [a]", "drop": "Int -> [a] -> [a]", "splitAt": "Int -> [a] -> ([a], [a])", "takeWhile": "(a -> Bool) -> [a] -> [a]", "dropWhile": "(a -> Bool) -> [a] -> [a]", "dropWhileEnd": "(a -> Bool) -> [a] -> [a]", "span": "(a -> Bool) -> [a] -> ([a], [a])", "break": "(a -> Bool) -> [a] -> ([a], [a])", "stripPrefix": "Eq a => [a] -> [a] -> Maybe [a]", "group": "Eq a => [a] -> [[a]]", "inits": "[a] -> [[a]]", "tails": "[a] -> [[a]]", "isPrefixOf": "Eq a => [a] -> [a] -> Bool", "isSuffixOf": "Eq a => [a] -> [a] -> Bool", "isInfixOf": "Eq a => [a] -> [a] -> Bool", "isSubsequenceOf": "Eq a => [a] -> [a] -> Bool", "elem": "(Foldable t, Eq a) => a -> t a -> Bool infix 4", "notElem": "(Foldable t, Eq a) => a -> t a -> Bool infix 4", "lookup": "Eq a => a -> [(a, b)] -> Maybe b", "find": "Foldable t => (a -> Bool) -> t a -> Maybe a", "filter": "(a -> Bool) -> [a] -> [a]", "partition": "(a -> Bool) -> [a] -> ([a], [a])", "!!": "[a] -> Int -> a infixl 9", "elemIndex": "Eq a => a -> [a] -> Maybe Int", "elemIndices": "Eq a => a -> [a] -> [Int]", "findIndex": "(a -> Bool) -> [a] -> Maybe Int", "findIndices": "(a -> Bool) -> [a] -> [Int]", "zip": "[a] -> [b] -> [(a, b)]", "zip3": "[a] -> [b] -> [c] -> [(a, b, c)]", "zip4": "[a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]", "zip5": "[a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]", "zip6": "[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]", "zip7": "[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]", "zipWith": "(a -> b -> c) -> [a] -> [b] -> [c]", "zipWith3": "(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]", "zipWith4": "(a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]", "zipWith5": "(a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]", "zipWith6": "(a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]", "zipWith7": "(a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]", "unzip": "[(a, b)] -> ([a], [b])", "unzip3": "[(a, b, c)] -> ([a], [b], [c])", "unzip4": "[(a, b, c, d)] -> ([a], [b], [c], [d])", "unzip5": "[(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])", "unzip6": "[(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])", "unzip7": "[(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])", "lines": "String -> [String]", "words": "String -> [String]", "unlines": "[String] -> String", "unwords": "[String] -> String", "nub": "Eq a => [a] -> [a]", "delete": "Eq a => a -> [a] -> [a]", "\\\\": "Eq a => [a] -> [a] -> [a] infix 5", "union": "Eq a => [a] -> [a] -> [a]", "intersect": "Eq a => [a] -> [a] -> [a]", "sort": "Ord a => [a] -> [a]", "sortOn": "Ord b => (a -> b) -> [a] -> [a]", "insert": "Ord a => a -> [a] -> [a]", "nubBy": "(a -> a -> Bool) -> [a] -> [a]", "deleteBy": "(a -> a -> Bool) -> a -> [a] -> [a]", "deleteFirstsBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "unionBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "intersectBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "groupBy": "(a -> a -> Bool) -> [a] -> [[a]]", "sortBy": "(a -> a -> Ordering) -> [a] -> [a]", "insertBy": "(a -> a -> Ordering) -> a -> [a] -> [a]", "maximumBy": "Foldable t => (a -> a -> Ordering) -> t a -> a", "minimumBy": "Foldable t => (a -> a -> Ordering) -> t a -> a", "genericLength": "Num i => [a] -> i", "genericTake": "Integral i => i -> [a] -> [a]", "genericDrop": "Integral i => i -> [a] -> [a]", "genericSplitAt": "Integral i => i -> [a] -> ([a], [a])", "genericIndex": "Integral i => [a] -> i -> a", "genericReplicate": "Integral i => i -> a -> [a]"}, "Data.List.NonEmpty": {"NonEmpty": "", "a": ":| [a] infixr 5", ">>=": "NonEmpty a -> (a -> NonEmpty b) -> NonEmpty b", ">>": "NonEmpty a -> NonEmpty b -> NonEmpty b", "return": "a -> NonEmpty a", "map": "(a -> b) -> NonEmpty a -> NonEmpty b", "intersperse": "a -> NonEmpty a -> NonEmpty a", "scanl": "Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b", "scanr": "Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b", "scanl1": "(a -> a -> a) -> NonEmpty a -> NonEmpty a", "scanr1": "(a -> a -> a) -> NonEmpty a -> NonEmpty a", "transpose": "NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)", "sortBy": "(a -> a -> Ordering) -> NonEmpty a -> NonEmpty a", "sortWith": "Ord o => (a -> o) -> NonEmpty a -> NonEmpty a", "length": "NonEmpty a -> Int", "head": "NonEmpty a -> a", "tail": "NonEmpty a -> [a]", "last": "NonEmpty a -> a", "init": "NonEmpty a -> [a]", "singleton": "a -> NonEmpty a", "<|": "a -> NonEmpty a -> NonEmpty a infixr 5", "cons": "a -> NonEmpty a -> NonEmpty a", "uncons": "NonEmpty a -> (a, Maybe (NonEmpty a))", "unfoldr": "(a -> (b, Maybe a)) -> a -> NonEmpty b", "sort": "Ord a => NonEmpty a -> NonEmpty a", "reverse": "NonEmpty a -> NonEmpty a", "inits": "Foldable f => f a -> NonEmpty [a]", "tails": "Foldable f => f a -> NonEmpty [a]", "iterate": "(a -> a) -> a -> NonEmpty a", "repeat": "a -> NonEmpty a", "cycle": "NonEmpty a -> NonEmpty a", "unfold": "(a -> (b, Maybe a)) -> a -> NonEmpty b", "insert": "(Foldable f, Ord a) => a -> f a -> NonEmpty a", "some1": "Alternative f => f a -> f (NonEmpty a)", "take": "Int -> NonEmpty a -> [a]", "drop": "Int -> NonEmpty a -> [a]", "splitAt": "Int -> NonEmpty a -> ([a], [a])", "takeWhile": "(a -> Bool) -> NonEmpty a -> [a]", "dropWhile": "(a -> Bool) -> NonEmpty a -> [a]", "span": "(a -> Bool) -> NonEmpty a -> ([a], [a])", "break": "(a -> Bool) -> NonEmpty a -> ([a], [a])", "filter": "(a -> Bool) -> NonEmpty a -> [a]", "partition": "(a -> Bool) -> NonEmpty a -> ([a], [a])", "group": "(Foldable f, Eq a) => f a -> [NonEmpty a]", "groupBy": "Foldable f => (a -> a -> Bool) -> f a -> [NonEmpty a]", "groupWith": "(Foldable f, Eq b) => (a -> b) -> f a -> [NonEmpty a]", "groupAllWith": "Ord b => (a -> b) -> [a] -> [NonEmpty a]", "group1": "Eq a => NonEmpty a -> NonEmpty (NonEmpty a)", "groupBy1": "(a -> a -> Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)", "groupWith1": "Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)", "groupAllWith1": "Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)", "isPrefixOf": "Eq a => [a] -> NonEmpty a -> Bool", "nub": "Eq a => NonEmpty a -> NonEmpty a", "nubBy": "(a -> a -> Bool) -> NonEmpty a -> NonEmpty a", "!!": "NonEmpty a -> Int -> a infixl 9", "zip": "NonEmpty a -> NonEmpty b -> NonEmpty (a, b)", "zipWith": "(a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c", "unzip": "Functor f => f (a, b) -> (f a, f b)", "fromList": "[a] -> NonEmpty a", "toList": "NonEmpty a -> [a]", "nonEmpty": "[a] -> Maybe (NonEmpty a)", "xor": "NonEmpty Bool -> Bool"}, "Data.Maybe": {"Maybe": "", "Nothing": "", "Just": "a", ">>=": "Maybe a -> (a -> Maybe b) -> Maybe b", ">>": "Maybe a -> Maybe b -> Maybe b", "return": "a -> Maybe a", "maybe": "b -> (a -> b) -> Maybe a -> b", "isJust": "Maybe a -> Bool", "isNothing": "Maybe a -> Bool", "fromJust": "HasCallStack => Maybe a -> a", "fromMaybe": "a -> Maybe a -> a", "listToMaybe": "[a] -> Maybe a", "maybeToList": "Maybe a -> [a]", "catMaybes": "[Maybe a] -> [a]", "mapMaybe": "(a -> Maybe b) -> [a] -> [b]"}, "Data.Monoid": {"Semigroup": "", "mempty": "a", "mappend": "a -> a -> a", "mconcat": "[a] -> a", "<>": "Semigroup a => a -> a -> a infixr 6", "Dual": "", "getDual": "a", ">>=": "a a -> (a -> a b) -> a b", ">>": "a a -> a b -> a b", "return": "a -> a a", "Endo": "", "appEndo": "a -> a", "from": "Endo a -> Rep (Endo a) x", "to": "Rep (Endo a) x -> Endo a", "All": "", "getAll": "Bool", "minBound": "a", "maxBound": "a", "Any": "", "getAny": "Bool", "Sum": "", "getSum": "a", "Product": "", "getProduct": "a", "First": "", "getFirst": "Maybe a", "Last": "", "getLast": "Maybe a", "Alt": "", "getAlt": "f a", "from1": "forall (a k0). a f a -> Rep1 b f) a", "to1": "forall (a k0). Rep1 a f) a -> b f a", "Ap": "", "getAp": "f a"}, "Data.Ord": {"Eq": "", "compare": "a -> a -> Ordering", "<": "a -> a -> Bool infix 4", "<=": "a -> a -> Bool infix 4", ">": "a -> a -> Bool infix 4", ">=": "a -> a -> Bool infix 4", "max": "a -> a -> a", "min": "a -> a -> a", "Ordering": "", "LT": "", "EQ": "", "GT": "", "minBound": "Ordering", "maxBound": "Ordering", "Down": "", "getDown": "a", ">>=": "Down a -> (a -> Down b) -> Down b", ">>": "Down a -> Down b -> Down b", "return": "a -> Down a", "comparing": "Ord a => (b -> a) -> b -> b -> Ordering"}, "Data.Proxy": {"Proxy": "", "from1": "forall (a k0). Proxy a -> Rep1 Proxy a", "to1": "forall (a k0). Rep1 Proxy a -> Proxy a", "asProxyTypeOf": "a -> proxy a -> a", "KProxy": ""}, "Data.Ratio": {"Ratio": "", "succ": "Ratio a -> Ratio a", "pred": "Ratio a -> Ratio a", "toEnum": "Int -> Ratio a", "fromEnum": "Ratio a -> Int", "enumFrom": "Ratio a -> [Ratio a]", "enumFromThen": "Ratio a -> Ratio a -> [Ratio a]", "enumFromTo": "Ratio a -> Ratio a -> [Ratio a]", "enumFromThenTo": "Ratio a -> Ratio a -> Ratio a -> [Ratio a]", "Rational": "", "%": "Integral a => a -> a -> Ratio a infixl 7", "numerator": "Ratio a -> a", "denominator": "Ratio a -> a", "approxRational": "RealFrac a => a -> a -> Rational"}, "Data.STRef": {"STRef": "", "==": "STRef s a -> STRef s a -> Bool", "/=": "STRef s a -> STRef s a -> Bool", "newSTRef": "a -> ST s (STRef s a)", "readSTRef": "STRef s a -> ST s a", "writeSTRef": "STRef s a -> a -> ST s ()", "modifySTRef": "STRef s a -> (a -> a) -> ST s ()", "modifySTRef'": "STRef s a -> (a -> a) -> ST s ()"}, "Data.STRef.Lazy": {"STRef": "", "==": "STRef s a -> STRef s a -> Bool", "/=": "STRef s a -> STRef s a -> Bool", "newSTRef": "a -> ST s (STRef s a)", "readSTRef": "STRef s a -> ST s a", "writeSTRef": "STRef s a -> a -> ST s ()", "modifySTRef": "STRef s a -> (a -> a) -> ST s ()"}, "Data.STRef.Strict": {"module": "Data.STRef"}, "Data.Semigroup": {"Semigroup": "", "<>": "a -> a -> a infixr 6", "sconcat": "NonEmpty a -> a", "stimes": "Integral b => b -> a -> a", "stimesMonoid": "(Integral b, Monoid a) => b -> a -> a", "stimesIdempotent": "Integral b => b -> a -> a", "stimesIdempotentMonoid": "(Integral b, Monoid a) => b -> a -> a", "mtimesDefault": "(Integral b, Monoid a) => b -> a -> a", "Min": "", "getMin": "a", ">>=": "a a -> (a -> a b) -> a b", ">>": "a a -> a b -> a b", "return": "a -> a a", "Max": "", "getMax": "a", "First": "", "getFirst": "a", "Last": "", "getLast": "a", "WrappedMonoid": "", "WrapMonoid": "", "unwrapMonoid": "m", "minBound": "a", "maxBound": "a", "Dual": "", "getDual": "a", "Endo": "", "appEndo": "a -> a", "from": "Endo a -> Rep (Endo a) x", "to": "Rep (Endo a) x -> Endo a", "All": "", "getAll": "Bool", "Any": "", "getAny": "Bool", "Sum": "", "getSum": "a", "Product": "", "getProduct": "a", "Option": "", "getOption": "Maybe a", "option": "b -> (a -> b) -> Option a -> b", "diff": "Semigroup m => m -> Endo m", "cycle1": "Semigroup m => m -> m", "Arg": "", "a": "", "b": "", "bimap": "(a -> b) -> (c -> d) -> Arg a c -> Arg b d", "first": "(a -> b) -> Arg a c -> Arg b c", "second": "(b -> c) -> Arg a b -> Arg a c", "ArgMin": "", "ArgMax": ""}, "Data.String": {"String": "", "IsString": "", "fromString": "String -> a", "lines": "String -> [String]", "words": "String -> [String]", "unlines": "[String] -> String", "unwords": "[String] -> String"}, "Data.Traversable": {"Functor": "", "traverse": "Applicative f => (a -> f b) -> t a -> f (t b)", "sequenceA": "Applicative f => t (f a) -> f (t a)", "mapM": "Monad m => (a -> m b) -> t a -> m (t b)", "sequence": "Monad m => t (m a) -> m (t a)", "for": "(Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)", "forM": "(Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)", "mapAccumL": "Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)", "mapAccumR": "Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)", "::": ""}, "Data.Tuple": {"fst": "(a, b) -> a", "snd": "(a, b) -> b", "curry": "((a, b) -> c) -> a -> b -> c", "uncurry": "(a -> b -> c) -> (a, b) -> c", "swap": "(a, b) -> (b, a)"}, "Data.Type.Bool": {"family": ""}, "Data.Type.Coercion": {"Coercion": "", "id": "forall (a k0). Coercion a a", ".": "forall (b k0) (c k0) (a k0). Coercion b c -> Coercion a b -> Coercion a c", "coerceWith": "Coercion a b -> a -> b", "gcoerceWith": "Coercion a b -> (Coercible a b => r) -> r", "sym": "Coercion a b -> Coercion b a", "trans": "Coercion a b -> Coercion b c -> Coercion a c", "repr": "(a :~: b) -> Coercion a b", "TestCoercion": "", "testCoercion": "f a -> f b -> Maybe (Coercion a b)"}, "Data.Type.Equality": {"a": "", "Refl": "a :~: a", "id": "forall (a k0). a a a", ".": "forall (b k0) (c k0) (a k0). (b a c) -> (a a b) -> a a c", "HRefl": "a :~~: a", "sym": "(a :~: b) -> b :~: a", "trans": "(a :~: b) -> (b :~: c) -> a :~: c", "castWith": "(a :~: b) -> a -> b", "gcastWith": "(a :~: b) -> (a ~ b => r) -> r", "apply": "(f :~: g) -> (a :~: b) -> f a :~: g b", "inner": "(f a :~: g b) -> a :~: b", "outer": "(f a :~: g b) -> f :~: g", "TestEquality": "", "testEquality": "f a -> f b -> Maybe (a :~: b)", "family": ""}, "Data.Typeable": {"Typeable": "", "::": "", "a": "", "Refl": "a :~: a", "id": "forall (a k0). a a a", ".": "forall (b k0) (c k0) (a k0). (b a c) -> (a a b) -> a a c", "HRefl": "a :~~: a", "Proxy": "", "from1": "forall (a k0). Proxy a -> Rep1 Proxy a", "to1": "forall (a k0). Rep1 Proxy a -> Proxy a", "TypeRep": "", "rnfTypeRep": "TypeRep -> ()", "showsTypeRep": "TypeRep -> ShowS", "mkFunTy": "TypeRep -> TypeRep -> TypeRep", "funResultTy": "TypeRep -> TypeRep -> Maybe TypeRep", "splitTyConApp": "TypeRep -> (TyCon, [TypeRep])", "typeRepArgs": "TypeRep -> [TypeRep]", "typeRepTyCon": "TypeRep -> TyCon", "typeRepFingerprint": "TypeRep -> Fingerprint", "TyCon": "", "==": "TyCon -> TyCon -> Bool", "/=": "TyCon -> TyCon -> Bool", "tyConPackage": "TyCon -> String", "tyConModule": "TyCon -> String", "tyConName": "TyCon -> String", "rnfTyCon": "TyCon -> ()", "tyConFingerprint": "TyCon -> Fingerprint"}, "Data.Unique": {"Unique": "", "==": "Unique -> Unique -> Bool", "/=": "Unique -> Unique -> Bool", "newUnique": "IO Unique", "hashUnique": "Unique -> Int"}, "Data.Version": {"Version": "", "versionBranch": "[Int]", "versionTags": "[String]", "fromList": "[Item Version] -> Version", "fromListN": "Int -> [Item Version] -> Version", "toList": "Version -> [Item Version]", "showVersion": "Version -> String", "parseVersion": "ReadP Version", "makeVersion": "[Int] -> Version"}, "Data.Void": {"Void": "", "==": "Void -> Void -> Bool", "/=": "Void -> Void -> Bool", "absurd": "Void -> a", "vacuous": "Functor f => f Void -> f a"}, "Data.Word": {"Word": "", "minBound": "a", "maxBound": "a", "Word8": "", "Word16": "", "Word32": "", "Word64": "", "byteSwap16": "Word16 -> Word16", "byteSwap32": "Word32 -> Word32", "byteSwap64": "Word64 -> Word64", "bitReverse8": "Word8 -> Word8", "bitReverse16": "Word16 -> Word16", "bitReverse32": "Word32 -> Word32", "bitReverse64": "Word64 -> Word64"}, "Debug.Trace": {"trace": "String -> a -> a", "traceId": "String -> String", "traceShow": "Show a => a -> b -> b", "traceShowId": "Show a => a -> a", "traceStack": "String -> a -> a", "traceIO": "String -> IO ()", "traceM": "Applicative f => String -> f ()", "traceShowM": "(Show a, Applicative f) => a -> f ()", "putTraceMsg": "String -> IO ()", "traceEvent": "String -> a -> a", "traceEventIO": "String -> IO ()", "traceMarker": "String -> a -> a", "traceMarkerIO": "String -> IO ()"}, "Foreign": {"module": "a"}, "Foreign.C": {"module": "a"}, "Foreign.C.Error": {"Errno": "", "==": "Errno -> Errno -> Bool", "/=": "Errno -> Errno -> Bool", "eOK": "Errno", "e2BIG": "Errno", "eACCES": "Errno", "eADDRINUSE": "Errno", "eADDRNOTAVAIL": "Errno", "eADV": "Errno", "eAFNOSUPPORT": "Errno", "eAGAIN": "Errno", "eALREADY": "Errno", "eBADF": "Errno", "eBADMSG": "Errno", "eBADRPC": "Errno", "eBUSY": "Errno", "eCHILD": "Errno", "eCOMM": "Errno", "eCONNABORTED": "Errno", "eCONNREFUSED": "Errno", "eCONNRESET": "Errno", "eDEADLK": "Errno", "eDESTADDRREQ": "Errno", "eDIRTY": "Errno", "eDOM": "Errno", "eDQUOT": "Errno", "eEXIST": "Errno", "eFAULT": "Errno", "eFBIG": "Errno", "eFTYPE": "Errno", "eHOSTDOWN": "Errno", "eHOSTUNREACH": "Errno", "eIDRM": "Errno", "eILSEQ": "Errno", "eINPROGRESS": "Errno", "eINTR": "Errno", "eINVAL": "Errno", "eIO": "Errno", "eISCONN": "Errno", "eISDIR": "Errno", "eLOOP": "Errno", "eMFILE": "Errno", "eMLINK": "Errno", "eMSGSIZE": "Errno", "eMULTIHOP": "Errno", "eNAMETOOLONG": "Errno", "eNETDOWN": "Errno", "eNETRESET": "Errno", "eNETUNREACH": "Errno", "eNFILE": "Errno", "eNOBUFS": "Errno", "eNODATA": "Errno", "eNODEV": "Errno", "eNOENT": "Errno", "eNOEXEC": "Errno", "eNOLCK": "Errno", "eNOLINK": "Errno", "eNOMEM": "Errno", "eNOMSG": "Errno", "eNONET": "Errno", "eNOPROTOOPT": "Errno", "eNOSPC": "Errno", "eNOSR": "Errno", "eNOSTR": "Errno", "eNOSYS": "Errno", "eNOTBLK": "Errno", "eNOTCONN": "Errno", "eNOTDIR": "Errno", "eNOTEMPTY": "Errno", "eNOTSOCK": "Errno", "eNOTSUP": "Errno", "eNOTTY": "Errno", "eNXIO": "Errno", "eOPNOTSUPP": "Errno", "ePERM": "Errno", "ePFNOSUPPORT": "Errno", "ePIPE": "Errno", "ePROCLIM": "Errno", "ePROCUNAVAIL": "Errno", "ePROGMISMATCH": "Errno", "ePROGUNAVAIL": "Errno", "ePROTO": "Errno", "ePROTONOSUPPORT": "Errno", "ePROTOTYPE": "Errno", "eRANGE": "Errno", "eREMCHG": "Errno", "eREMOTE": "Errno", "eROFS": "Errno", "eRPCMISMATCH": "Errno", "eRREMOTE": "Errno", "eSHUTDOWN": "Errno", "eSOCKTNOSUPPORT": "Errno", "eSPIPE": "Errno", "eSRCH": "Errno", "eSRMNT": "Errno", "eSTALE": "Errno", "eTIME": "Errno", "eTIMEDOUT": "Errno", "eTOOMANYREFS": "Errno", "eTXTBSY": "Errno", "eUSERS": "Errno", "eWOULDBLOCK": "Errno", "eXDEV": "Errno", "isValidErrno": "Errno -> Bool", "getErrno": "IO Errno", "resetErrno": "IO ()", "errnoToIOError": "", "throwErrno": "", "throwErrnoIf": "", "throwErrnoIf_": "(a -> Bool) -> String -> IO a -> IO ()", "throwErrnoIfRetry": "(a -> Bool) -> String -> IO a -> IO a", "throwErrnoIfRetry_": "(a -> Bool) -> String -> IO a -> IO ()", "throwErrnoIfMinus1": "(Eq a, Num a) => String -> IO a -> IO a", "throwErrnoIfMinus1_": "(Eq a, Num a) => String -> IO a -> IO ()", "throwErrnoIfMinus1Retry": "(Eq a, Num a) => String -> IO a -> IO a", "throwErrnoIfMinus1Retry_": "(Eq a, Num a) => String -> IO a -> IO ()", "throwErrnoIfNull": "String -> IO (Ptr a) -> IO (Ptr a)", "throwErrnoIfNullRetry": "String -> IO (Ptr a) -> IO (Ptr a)", "throwErrnoIfRetryMayBlock": "", "throwErrnoIfRetryMayBlock_": "(a -> Bool) -> String -> IO a -> IO b -> IO ()", "throwErrnoIfMinus1RetryMayBlock": "(Eq a, Num a) => String -> IO a -> IO b -> IO a", "throwErrnoIfMinus1RetryMayBlock_": "(Eq a, Num a) => String -> IO a -> IO b -> IO ()", "throwErrnoIfNullRetryMayBlock": "String -> IO (Ptr a) -> IO b -> IO (Ptr a)", "throwErrnoPath": "String -> FilePath -> IO a", "throwErrnoPathIf": "(a -> Bool) -> String -> FilePath -> IO a -> IO a", "throwErrnoPathIf_": "(a -> Bool) -> String -> FilePath -> IO a -> IO ()", "throwErrnoPathIfNull": "String -> FilePath -> IO (Ptr a) -> IO (Ptr a)", "throwErrnoPathIfMinus1": "(Eq a, Num a) => String -> FilePath -> IO a -> IO a", "throwErrnoPathIfMinus1_": "(Eq a, Num a) => String -> FilePath -> IO a -> IO ()"}, "Foreign.C.String": {"CString": "", "CStringLen": "", "peekCString": "CString -> IO String", "peekCStringLen": "CStringLen -> IO String", "newCString": "String -> IO CString", "newCStringLen": "String -> IO CStringLen", "withCString": "String -> (CString -> IO a) -> IO a", "withCStringLen": "String -> (CStringLen -> IO a) -> IO a", "charIsRepresentable": "Char -> IO Bool", "castCharToCChar": "Char -> CChar", "castCCharToChar": "CChar -> Char", "castCharToCUChar": "Char -> CUChar", "castCUCharToChar": "CUChar -> Char", "castCharToCSChar": "Char -> CSChar", "castCSCharToChar": "CSChar -> Char", "peekCAString": "CString -> IO String", "peekCAStringLen": "CStringLen -> IO String", "newCAString": "String -> IO CString", "newCAStringLen": "String -> IO CStringLen", "withCAString": "String -> (CString -> IO a) -> IO a", "withCAStringLen": "String -> (CStringLen -> IO a) -> IO a", "CWString": "", "CWStringLen": "", "peekCWString": "CWString -> IO String", "peekCWStringLen": "CWStringLen -> IO String", "newCWString": "String -> IO CWString", "newCWStringLen": "String -> IO CWStringLen", "withCWString": "String -> (CWString -> IO a) -> IO a", "withCWStringLen": "String -> (CWStringLen -> IO a) -> IO a"}, "Foreign.C.Types": {"CChar": "", "minBound": "a", "maxBound": "a", "CSChar": "", "CUChar": "", "CShort": "", "CUShort": "", "CInt": "", "CUInt": "", "CLong": "", "CULong": "", "CPtrdiff": "", "CSize": "", "CWchar": "", "CSigAtomic": "", "CLLong": "", "CULLong": "", "CBool": "", "CIntPtr": "", "CUIntPtr": "", "CIntMax": "", "CUIntMax": "", "CClock": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "CTime": "", "CUSeconds": "", "CSUSeconds": "", "CFloat": "", "CDouble": "", "CFile": "", "CFpos": "", "CJmpBuf": ""}, "Foreign.Concurrent": {"newForeignPtr": "Ptr a -> IO () -> IO (ForeignPtr a)", "addForeignPtrFinalizer": "ForeignPtr a -> IO () -> IO ()"}, "Foreign.ForeignPtr": {"ForeignPtr": "", "==": "ForeignPtr a -> ForeignPtr a -> Bool", "/=": "ForeignPtr a -> ForeignPtr a -> Bool", "FinalizerPtr": "", "FinalizerEnvPtr": "", "newForeignPtr": "FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)", "newForeignPtr_": "Ptr a -> IO (ForeignPtr a)", "addForeignPtrFinalizer": "FinalizerPtr a -> ForeignPtr a -> IO ()", "newForeignPtrEnv": "FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)", "addForeignPtrFinalizerEnv": "FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()", "withForeignPtr": "ForeignPtr a -> (Ptr a -> IO b) -> IO b", "finalizeForeignPtr": "ForeignPtr a -> IO ()", "touchForeignPtr": "ForeignPtr a -> IO ()", "castForeignPtr": "ForeignPtr a -> ForeignPtr b", "plusForeignPtr": "ForeignPtr a -> Int -> ForeignPtr b", "mallocForeignPtr": "Storable a => IO (ForeignPtr a)", "mallocForeignPtrBytes": "Int -> IO (ForeignPtr a)", "mallocForeignPtrArray": "Storable a => Int -> IO (ForeignPtr a)", "mallocForeignPtrArray0": "Storable a => Int -> IO (ForeignPtr a)"}, "Foreign.ForeignPtr.Safe": {"ForeignPtr": "", "==": "ForeignPtr a -> ForeignPtr a -> Bool", "/=": "ForeignPtr a -> ForeignPtr a -> Bool", "FinalizerPtr": "", "FinalizerEnvPtr": "", "newForeignPtr": "FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)", "newForeignPtr_": "Ptr a -> IO (ForeignPtr a)", "addForeignPtrFinalizer": "FinalizerPtr a -> ForeignPtr a -> IO ()", "newForeignPtrEnv": "FinalizerEnvPtr env a -> Ptr env -> Ptr a -> IO (ForeignPtr a)", "addForeignPtrFinalizerEnv": "FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()", "withForeignPtr": "ForeignPtr a -> (Ptr a -> IO b) -> IO b", "finalizeForeignPtr": "ForeignPtr a -> IO ()", "touchForeignPtr": "ForeignPtr a -> IO ()", "castForeignPtr": "ForeignPtr a -> ForeignPtr b", "mallocForeignPtr": "Storable a => IO (ForeignPtr a)", "mallocForeignPtrBytes": "Int -> IO (ForeignPtr a)", "mallocForeignPtrArray": "Storable a => Int -> IO (ForeignPtr a)", "mallocForeignPtrArray0": "Storable a => Int -> IO (ForeignPtr a)"}, "Foreign.ForeignPtr.Unsafe": {"unsafeForeignPtrToPtr": "ForeignPtr a -> Ptr a"}, "Foreign.Marshal": {"module": "a"}, "Foreign.Marshal.Alloc": {"::": "", "allocaBytes": "Int -> (Ptr a -> IO b) -> IO b", "allocaBytesAligned": "Int -> Int -> (Ptr a -> IO b) -> IO b", "mallocBytes": "Int -> IO (Ptr a)", "callocBytes": "Int -> IO (Ptr a)", "reallocBytes": "Ptr a -> Int -> IO (Ptr a)", "free": "Ptr a -> IO ()", "finalizerFree": "FinalizerPtr a"}, "Foreign.Marshal.Array": {"::": "", "mallocArray0": "Storable a => Int -> IO (Ptr a)", "allocaArray0": "Storable a => Int -> (Ptr a -> IO b) -> IO b", "reallocArray0": "Storable a => Ptr a -> Int -> IO (Ptr a)", "callocArray0": "Storable a => Int -> IO (Ptr a)", "peekArray": "Storable a => Int -> Ptr a -> IO [a]", "peekArray0": "(Storable a, Eq a) => a -> Ptr a -> IO [a]", "pokeArray": "Storable a => Ptr a -> [a] -> IO ()", "pokeArray0": "Storable a => a -> Ptr a -> [a] -> IO ()", "newArray": "Storable a => [a] -> IO (Ptr a)", "newArray0": "Storable a => a -> [a] -> IO (Ptr a)", "withArray": "Storable a => [a] -> (Ptr a -> IO b) -> IO b", "withArray0": "Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b", "withArrayLen": "Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b", "withArrayLen0": "Storable a => a -> [a] -> (Int -> Ptr a -> IO b) -> IO b", "lengthArray0": "(Storable a, Eq a) => a -> Ptr a -> IO Int"}, "Foreign.Marshal.Error": {"throwIf": "", "throwIf_": "(a -> Bool) -> (a -> String) -> IO a -> IO ()", "throwIfNeg": "(Ord a, Num a) => (a -> String) -> IO a -> IO a", "throwIfNeg_": "(Ord a, Num a) => (a -> String) -> IO a -> IO ()", "throwIfNull": "String -> IO (Ptr a) -> IO (Ptr a)", "void": "IO a -> IO ()"}, "Foreign.Marshal.Pool": {"Pool": "", "newPool": "IO Pool", "freePool": "Pool -> IO ()", "withPool": "(Pool -> IO b) -> IO b", "::": "", "pooledMallocBytes": "Pool -> Int -> IO (Ptr a)", "pooledReallocBytes": "Pool -> Ptr a -> Int -> IO (Ptr a)", "pooledMallocArray0": "Storable a => Pool -> Int -> IO (Ptr a)", "pooledReallocArray0": "Storable a => Pool -> Ptr a -> Int -> IO (Ptr a)", "pooledNew": "Storable a => Pool -> a -> IO (Ptr a)", "pooledNewArray": "Storable a => Pool -> [a] -> IO (Ptr a)", "pooledNewArray0": "Storable a => Pool -> a -> [a] -> IO (Ptr a)"}, "Foreign.Marshal.Safe": {"module": "a"}, "Foreign.Marshal.Unsafe": {"unsafeLocalState": "IO a -> a"}, "Foreign.Marshal.Utils": {"with": "Storable a => a -> (Ptr a -> IO b) -> IO b", "new": "Storable a => a -> IO (Ptr a)", "fromBool": "Num a => Bool -> a", "toBool": "(Eq a, Num a) => a -> Bool", "maybeNew": "(a -> IO (Ptr b)) -> Maybe a -> IO (Ptr b)", "maybeWith": "(a -> (Ptr b -> IO c) -> IO c) -> Maybe a -> (Ptr b -> IO c) -> IO c", "maybePeek": "(Ptr a -> IO b) -> Ptr a -> IO (Maybe b)", "withMany": "(a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res", "copyBytes": "", "moveBytes": "", "fillBytes": "Ptr a -> Word8 -> Int -> IO ()"}, "Foreign.Ptr": {"Ptr": "", "from1": "forall (a k0). URec (Ptr ()) a -> Rep1 (URec (Ptr ())) a", "to1": "forall (a k0). Rep1 (URec (Ptr ())) a -> URec (Ptr ()) a", "nullPtr": "Ptr a", "castPtr": "Ptr a -> Ptr b", "plusPtr": "Ptr a -> Int -> Ptr b", "alignPtr": "Ptr a -> Int -> Ptr a", "minusPtr": "Ptr a -> Ptr b -> Int", "FunPtr": "", "==": "FunPtr a -> FunPtr a -> Bool", "/=": "FunPtr a -> FunPtr a -> Bool", "nullFunPtr": "FunPtr a", "castFunPtr": "FunPtr a -> FunPtr b", "castFunPtrToPtr": "FunPtr a -> Ptr b", "castPtrToFunPtr": "Ptr a -> FunPtr b", "freeHaskellFunPtr": "FunPtr a -> IO ()", "IntPtr": "", "minBound": "a", "maxBound": "a", "ptrToIntPtr": "Ptr a -> IntPtr", "intPtrToPtr": "IntPtr -> Ptr a", "WordPtr": "", "ptrToWordPtr": "Ptr a -> WordPtr", "wordPtrToPtr": "WordPtr -> Ptr a"}, "Foreign.Safe": {"module": "a"}, "Foreign.StablePtr": {"StablePtr": "", "==": "StablePtr a -> StablePtr a -> Bool", "/=": "StablePtr a -> StablePtr a -> Bool", "newStablePtr": "a -> IO (StablePtr a)", "deRefStablePtr": "StablePtr a -> IO a", "freeStablePtr": "StablePtr a -> IO ()", "castStablePtrToPtr": "StablePtr a -> Ptr ()", "castPtrToStablePtr": "Ptr () -> StablePtr a"}, "Foreign.Storable": {"Storable": "", "sizeOf": "a -> Int", "alignment": "a -> Int", "peekElemOff": "Ptr a -> Int -> IO a", "pokeElemOff": "Ptr a -> Int -> a -> IO ()", "peekByteOff": "Ptr b -> Int -> IO a", "pokeByteOff": "Ptr b -> Int -> a -> IO ()", "peek": "Ptr a -> IO a", "poke": "Ptr a -> a -> IO ()"}, "GHC.Arr": {"Ord": "", "range": "(a, a) -> [a]", "index": "(a, a) -> a -> Int", "unsafeIndex": "(a, a) -> a -> Int", "inRange": "(a, a) -> a -> Bool", "rangeSize": "(a, a) -> Int", "unsafeRangeSize": "(a, a) -> Int", "Array": "", "fmap": "(a -> b) -> Array i a -> Array i b", "<$": "a -> Array i b -> Array i a", "STArray": "", "==": "STArray s i e -> STArray s i e -> Bool", "/=": "STArray s i e -> STArray s i e -> Bool", "arrEleBottom": "a", "array": "", "listArray": "Ix i => (i, i) -> [e] -> Array i e", "!": "Ix i => Array i e -> i -> e infixl 9", "safeRangeSize": "Ix i => (i, i) -> Int", "negRange": "Int", "safeIndex": "Ix i => (i, i) -> Int -> i -> Int", "badSafeIndex": "Int -> Int -> Int", "bounds": "Array i e -> (i, i)", "numElements": "Array i e -> Int", "numElementsSTArray": "STArray s i e -> Int", "indices": "Ix i => Array i e -> [i]", "elems": "Array i e -> [e]", "assocs": "Ix i => Array i e -> [(i, e)]", "accumArray": "", "adjust": "(e -> a -> e) -> MutableArray# s e -> (Int, a) -> STRep s b -> STRep s b", "//": "Ix i => Array i e -> [(i, e)] -> Array i e infixl 9", "accum": "Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e", "amap": "(a -> b) -> Array i a -> Array i b", "ixmap": "(Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e", "eqArray": "(Ix i, Eq e) => Array i e -> Array i e -> Bool", "cmpArray": "(Ix i, Ord e) => Array i e -> Array i e -> Ordering", "cmpIntArray": "Ord e => Array Int e -> Array Int e -> Ordering", "newSTArray": "Ix i => (i, i) -> e -> ST s (STArray s i e)", "boundsSTArray": "STArray s i e -> (i, i)", "readSTArray": "Ix i => STArray s i e -> i -> ST s e", "writeSTArray": "Ix i => STArray s i e -> i -> e -> ST s ()", "freezeSTArray": "STArray s i e -> ST s (Array i e)", "thawSTArray": "Array i e -> ST s (STArray s i e)", "foldlElems": "(b -> a -> b) -> b -> Array i a -> b", "foldlElems'": "(b -> a -> b) -> b -> Array i a -> b", "foldl1Elems": "(a -> a -> a) -> Array i a -> a", "foldrElems": "(a -> b -> b) -> b -> Array i a -> b", "foldrElems'": "(a -> b -> b) -> b -> Array i a -> b", "foldr1Elems": "(a -> a -> a) -> Array i a -> a", "fill": "MutableArray# s e -> (Int, e) -> STRep s a -> STRep s a", "done": "i -> i -> Int -> MutableArray# s e -> STRep s (Array i e)", "unsafeArray": "Ix i => (i, i) -> [(Int, e)] -> Array i e", "unsafeArray'": "(i, i) -> Int -> [(Int, e)] -> Array i e", "lessSafeIndex": "Ix i => (i, i) -> Int -> i -> Int", "unsafeAt": "Array i e -> Int -> e", "unsafeReplace": "Array i e -> [(Int, e)] -> Array i e", "unsafeAccumArray": "Ix i => (e -> a -> e) -> e -> (i, i) -> [(Int, a)] -> Array i e", "unsafeAccumArray'": "(e -> a -> e) -> e -> (i, i) -> Int -> [(Int, a)] -> Array i e", "unsafeAccum": "(e -> a -> e) -> Array i e -> [(Int, a)] -> Array i e", "unsafeReadSTArray": "STArray s i e -> Int -> ST s e", "unsafeWriteSTArray": "STArray s i e -> Int -> e -> ST s ()", "unsafeFreezeSTArray": "STArray s i e -> ST s (Array i e)", "unsafeThawSTArray": "Array i e -> ST s (STArray s i e)"}, "GHC.Base": {"::": "", "++": "[a] -> [a] -> [a] infixr 5", "foldr": "(a -> b -> b) -> b -> [a] -> b", "eqString": "String -> String -> Bool", "bindIO": "IO a -> (a -> IO b) -> IO b", "returnIO": "a -> IO a", "otherwise": "Bool", "assert": "Bool -> a -> a", "thenIO": "IO a -> IO b -> IO b", "breakpoint": "a -> a", "breakpointCond": "Bool -> a -> a", "map": "(a -> b) -> [a] -> [b]", "join": "Monad m => m (m a) -> m a", "Applicative": "", ">>=": "a a b c b a d -> a e", ">>": "a a b a c -> a b", "return": "a -> a a", "Functor": "", "fmap": "(a -> b) -> f a -> f b", "<$": "a -> f b -> f a infixl 4", "pure": "a -> f a", "<*>": "f (a -> b) -> f a -> f b infixl 4", "liftA2": "(a -> b -> c) -> f a -> f b -> f c", "*>": "f a -> f b -> f b infixl 4", "<*": "f a -> f b -> f a infixl 4", "Semigroup": "", "<>": "a -> a -> a infixr 6", "sconcat": "NonEmpty a -> a", "stimes": "Integral b => b -> a -> a", "mempty": "a", "mappend": "a -> a -> a", "mconcat": "[a] -> a", "String": "", "Opaque": "", "forall": "a. O a", "NonEmpty": "", "a": ":| [a] infixr 5", "Alternative": "", "mzero": "m a", "mplus": "m a -> m a -> m a", "empty": "f a", "<|>": "f a -> f a -> f a infixl 3", "some": "f a -> f [a]", "many": "f a -> f [a]", "<**>": "Applicative f => f a -> f (a -> b) -> f b infixl 4", "liftA": "Applicative f => (a -> b) -> f a -> f b", "liftA3": "Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d", "=<<": "Monad m => (a -> m b) -> m a -> m b infixr 1", "when": "Applicative f => Bool -> f () -> f ()", "sequence": "Monad m => [m a] -> m [a]", "mapM": "Monad m => (a -> m b) -> [a] -> m [b]", "liftM": "Monad m => (a1 -> r) -> m a1 -> m r", "liftM2": "Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r", "liftM3": "Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r", "liftM4": "Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r", "liftM5": "Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r", "ap": "Monad m => m (a -> b) -> m a -> m b", "mapFB": "(elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst", "unsafeChr": "Int -> Char", "ord": "Char -> Int", "minInt": "Int", "maxInt": "Int", "id": "a -> a", "const": "a -> b -> a", ".": "(b -> c) -> (a -> b) -> a -> c infixr 9", "flip": "(a -> b -> c) -> b -> a -> c", "until": "(a -> Bool) -> (a -> a) -> a -> a", "asTypeOf": "a -> a -> a", "failIO": "String -> IO a", "unIO": "IO a -> State# RealWorld -> (# State# RealWorld, a #)", "getTag": "a -> Int#", "quotInt": "Int -> Int -> Int", "remInt": "Int -> Int -> Int", "divInt": "Int -> Int -> Int", "modInt": "Int -> Int -> Int", "quotRemInt": "Int -> Int -> (Int, Int)", "divModInt": "Int -> Int -> (Int, Int)", "divModInt#": "Int# -> Int# -> (# Int#, Int# #)", "shiftL#": "Word# -> Int# -> Word#", "shiftRL#": "Word# -> Int# -> Word#", "iShiftL#": "Int# -> Int# -> Int#", "iShiftRA#": "Int# -> Int# -> Int#", "iShiftRL#": "Int# -> Int# -> Int#", "module": "a"}, "GHC.ByteOrder": {"ByteOrder": "", "BigEndian": "", "LittleEndian": "", "minBound": "ByteOrder", "maxBound": "ByteOrder", "targetByteOrder": "ByteOrder"}, "GHC.Char": {"chr": "Int -> Char", "eqChar": "Char -> Char -> Bool", "neChar": "Char -> Char -> Bool"}, "GHC.Clock": {"getMonotonicTime": "IO Double", "getMonotonicTimeNSec": "IO Word64"}, "GHC.Conc": {"ThreadId": "", "==": "a b a b c", "/=": "a b a b c", "forkIO": "IO () -> IO ThreadId", "::": "", "forkOn": "Int -> IO () -> IO ThreadId", "numCapabilities": "Int", "getNumCapabilities": "IO Int", "setNumCapabilities": "Int -> IO ()", "getNumProcessors": "IO Int", "numSparks": "IO Int", "childHandler": "SomeException -> IO ()", "myThreadId": "IO ThreadId", "killThread": "ThreadId -> IO ()", "throwTo": "Exception e => ThreadId -> e -> IO ()", "par": "a -> b -> b infixr 0", "pseq": "a -> b -> b infixr 0", "runSparks": "IO ()", "yield": "IO ()", "labelThread": "ThreadId -> String -> IO ()", "mkWeakThreadId": "ThreadId -> IO (Weak ThreadId)", "ThreadStatus": "", "ThreadRunning": "", "ThreadFinished": "", "ThreadBlocked": "BlockReason", "ThreadDied": "", "BlockReason": "", "BlockedOnMVar": "", "BlockedOnBlackHole": "", "BlockedOnException": "", "BlockedOnSTM": "", "BlockedOnForeignCall": "", "BlockedOnIOCompletion": "", "BlockedOnOther": "", "threadStatus": "ThreadId -> IO ThreadStatus", "threadCapability": "ThreadId -> IO (Int, Bool)", "newStablePtrPrimMVar": "MVar () -> IO (StablePtr PrimMVar)", "PrimMVar": "", "threadDelay": "Int -> IO ()", "registerDelay": "Int -> IO (TVar Bool)", "threadWaitRead": "Fd -> IO ()", "threadWaitWrite": "Fd -> IO ()", "threadWaitReadSTM": "Fd -> IO (STM (), IO ())", "threadWaitWriteSTM": "Fd -> IO (STM (), IO ())", "closeFdWith": "", "setAllocationCounter": "Int64 -> IO ()", "getAllocationCounter": "IO Int64", "enableAllocationLimit": "IO ()", "disableAllocationLimit": "IO ()", "STM": "", ">>=": "STM a -> (a -> STM b) -> STM b", ">>": "STM a -> STM b -> STM b", "return": "a -> STM a", "atomically": "STM a -> IO a", "retry": "STM a", "orElse": "STM a -> STM a -> STM a", "throwSTM": "Exception e => e -> STM a", "catchSTM": "Exception e => STM a -> (e -> STM a) -> STM a", "TVar": "", "newTVar": "a -> STM (TVar a)", "newTVarIO": "a -> IO (TVar a)", "readTVar": "TVar a -> STM a", "readTVarIO": "TVar a -> IO a", "writeTVar": "TVar a -> a -> STM ()", "unsafeIOToSTM": "IO a -> STM a", "withMVar": "MVar a -> (a -> IO b) -> IO b", "Signal": "", "HandlerFun": "", "setHandler": "Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))", "runHandlers": "ForeignPtr Word8 -> Signal -> IO ()", "ensureIOManagerIsRunning": "IO ()", "ioManagerCapabilitiesChanged": "IO ()", "setUncaughtExceptionHandler": "(SomeException -> IO ()) -> IO ()", "getUncaughtExceptionHandler": "IO (SomeException -> IO ())", "reportError": "SomeException -> IO ()", "reportStackOverflow": "IO ()", "reportHeapOverflow": "IO ()"}, "GHC.Conc.IO": {"ensureIOManagerIsRunning": "IO ()", "ioManagerCapabilitiesChanged": "IO ()", "interruptIOManager": "IO ()", "threadDelay": "Int -> IO ()", "registerDelay": "Int -> IO (TVar Bool)", "threadWaitRead": "Fd -> IO ()", "threadWaitWrite": "Fd -> IO ()", "threadWaitReadSTM": "Fd -> IO (STM (), IO ())", "threadWaitWriteSTM": "Fd -> IO (STM (), IO ())", "closeFdWith": ""}, "GHC.Conc.Signal": {"Signal": "", "HandlerFun": "", "setHandler": "Signal -> Maybe (HandlerFun, Dynamic) -> IO (Maybe (HandlerFun, Dynamic))", "runHandlers": "ForeignPtr Word8 -> Signal -> IO ()", "runHandlersPtr": "Ptr Word8 -> Signal -> IO ()"}, "GHC.Conc.Sync": {"ThreadId": "", "==": "a b a b c", "/=": "a b a b c", "showThreadId": "ThreadId -> String", "forkIO": "IO () -> IO ThreadId", "::": "", "forkOn": "Int -> IO () -> IO ThreadId", "numCapabilities": "Int", "getNumCapabilities": "IO Int", "setNumCapabilities": "Int -> IO ()", "getNumProcessors": "IO Int", "numSparks": "IO Int", "childHandler": "SomeException -> IO ()", "myThreadId": "IO ThreadId", "killThread": "ThreadId -> IO ()", "throwTo": "Exception e => ThreadId -> e -> IO ()", "par": "a -> b -> b infixr 0", "pseq": "a -> b -> b infixr 0", "runSparks": "IO ()", "yield": "IO ()", "labelThread": "ThreadId -> String -> IO ()", "mkWeakThreadId": "ThreadId -> IO (Weak ThreadId)", "ThreadStatus": "", "ThreadRunning": "", "ThreadFinished": "", "ThreadBlocked": "BlockReason", "ThreadDied": "", "BlockReason": "", "BlockedOnMVar": "", "BlockedOnBlackHole": "", "BlockedOnException": "", "BlockedOnSTM": "", "BlockedOnForeignCall": "", "BlockedOnIOCompletion": "", "BlockedOnOther": "", "threadStatus": "ThreadId -> IO ThreadStatus", "threadCapability": "ThreadId -> IO (Int, Bool)", "newStablePtrPrimMVar": "MVar () -> IO (StablePtr PrimMVar)", "PrimMVar": "", "setAllocationCounter": "Int64 -> IO ()", "getAllocationCounter": "IO Int64", "enableAllocationLimit": "IO ()", "disableAllocationLimit": "IO ()", "STM": "", ">>=": "STM a -> (a -> STM b) -> STM b", ">>": "STM a -> STM b -> STM b", "return": "a -> STM a", "atomically": "STM a -> IO a", "retry": "STM a", "orElse": "STM a -> STM a -> STM a", "throwSTM": "Exception e => e -> STM a", "catchSTM": "Exception e => STM a -> (e -> STM a) -> STM a", "TVar": "", "newTVar": "a -> STM (TVar a)", "newTVarIO": "a -> IO (TVar a)", "readTVar": "TVar a -> STM a", "readTVarIO": "TVar a -> IO a", "writeTVar": "TVar a -> a -> STM ()", "unsafeIOToSTM": "IO a -> STM a", "withMVar": "MVar a -> (a -> IO b) -> IO b", "modifyMVar_": "MVar a -> (a -> IO a) -> IO ()", "setUncaughtExceptionHandler": "(SomeException -> IO ()) -> IO ()", "getUncaughtExceptionHandler": "IO (SomeException -> IO ())", "reportError": "SomeException -> IO ()", "reportStackOverflow": "IO ()", "reportHeapOverflow": "IO ()", "sharedCAF": "a -> (Ptr a -> IO (Ptr a)) -> IO a"}, "GHC.ConsoleHandler": {}, "GHC.Constants": {}, "GHC.Desugar": {"::": "", "AnnotationWrapper": "", "forall": "a.Data a => AnnotationWrapper a", "toAnnotationWrapper": "Data a => a -> AnnotationWrapper"}, "GHC.Enum": {"Bounded": "", "minBound": "a", "maxBound": "a", "Enum": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "boundedEnumFrom": "(Enum a, Bounded a) => a -> [a]", "boundedEnumFromThen": "(Enum a, Bounded a) => a -> a -> [a]", "toEnumError": "Show a => String -> Int -> (a, a) -> b", "fromEnumError": "Show a => String -> a -> b", "succError": "String -> a", "predError": "String -> a"}, "GHC.Environment": {"getFullArgs": "IO [String]"}, "GHC.Err": {"absentErr": "a", "::": ""}, "GHC.Event": {"EventManager": "", "TimerManager": "", "getSystemEventManager": "IO (Maybe EventManager)", "new": "IO EventManager", "getSystemTimerManager": "IO TimerManager", "Event": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "evtRead": "Event", "evtWrite": "Event", "IOCallback": "", "FdKey": "", "Lifetime": "", "OneShot": "", "MultiShot": "", "registerFd": "EventManager -> IOCallback -> Fd -> Event -> Lifetime -> IO FdKey", "unregisterFd": "EventManager -> FdKey -> IO ()", "unregisterFd_": "EventManager -> FdKey -> IO Bool", "closeFd": "EventManager -> (Fd -> IO ()) -> Fd -> IO ()", "TimeoutCallback": "", "TimeoutKey": "", "registerTimeout": "TimerManager -> Int -> TimeoutCallback -> IO TimeoutKey", "updateTimeout": "TimerManager -> TimeoutKey -> Int -> IO ()", "unregisterTimeout": "TimerManager -> TimeoutKey -> IO ()"}, "GHC.Event.TimeOut": {"TimeoutQueue": "", "TimeoutCallback": "", "TimeoutEdit": "", "TimeoutKey": "", "TK": "Unique", "==": "TimeoutKey -> TimeoutKey -> Bool", "/=": "TimeoutKey -> TimeoutKey -> Bool"}, "GHC.Exception": {"module": "GHC.Exception.Type", "::": "", "ErrorCall": "", "ErrorCallWithLocation": "String String", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "errorCallException": "String -> SomeException", "errorCallWithCallStackException": "String -> CallStack -> SomeException", "CallStack": "", "fromList": "[Item CallStack] -> CallStack", "fromListN": "Int -> [Item CallStack] -> CallStack", "toList": "CallStack -> [Item CallStack]", "fromCallSiteList": "[([Char], SrcLoc)] -> CallStack", "getCallStack": "CallStack -> [([Char], SrcLoc)]", "prettyCallStack": "CallStack -> String", "prettyCallStackLines": "CallStack -> [String]", "showCCSStack": "[String] -> [String]", "SrcLoc": "", "srcLocPackage": "[Char]", "srcLocModule": "[Char]", "srcLocFile": "[Char]", "srcLocStartLine": "Int", "srcLocStartCol": "Int", "srcLocEndLine": "Int", "srcLocEndCol": "Int", "prettySrcLoc": "SrcLoc -> String"}, "GHC.Exception.Type": {"Typeable": "", "toException": "e -> SomeException", "fromException": "SomeException -> Maybe e", "displayException": "e -> String", "SomeException": "", "forall": "e.Exception e => SomeException e", "showsPrec": "Int -> SomeException -> ShowS", "show": "SomeException -> String", "showList": "[SomeException] -> ShowS", "ArithException": "", "Overflow": "", "Underflow": "", "LossOfPrecision": "", "DivideByZero": "", "Denormal": "", "RatioZeroDenominator": "", "==": "ArithException -> ArithException -> Bool", "/=": "ArithException -> ArithException -> Bool", "divZeroException": "SomeException", "overflowException": "SomeException", "ratioZeroDenomException": "SomeException", "underflowException": "SomeException"}, "GHC.ExecutionStack": {"Location": "", "objectName": "String", "functionName": "String", "srcLoc": "Maybe SrcLoc", "SrcLoc": "", "sourceFile": "String", "sourceLine": "Int", "sourceColumn": "Int", "getStackTrace": "IO (Maybe [Location])", "showStackTrace": "IO (Maybe String)"}, "GHC.ExecutionStack.Internal": {"Location": "", "objectName": "String", "functionName": "String", "srcLoc": "Maybe SrcLoc", "SrcLoc": "", "sourceFile": "String", "sourceLine": "Int", "sourceColumn": "Int", "StackTrace": "", "stackFrames": "StackTrace -> Maybe [Location]", "stackDepth": "StackTrace -> Int", "collectStackTrace": "IO (Maybe StackTrace)", "showStackFrames": "[Location] -> ShowS", "invalidateDebugCache": "IO ()"}, "GHC.Exts": {"Int": "", "I#": "Int#", "minBound": "a", "maxBound": "a", "Word": "", "W#": "Word#", "Float": "", "F#": "Float#", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "Double": "", "D#": "Double#", "Char": "", "C#": "Char#", "Ptr": "", "from1": "forall (a k0). a b c a -> Rep1 a b c a", "to1": "forall (a k0). Rep1 a b c a -> d b e a", "FunPtr": "", "==": "a b c a b", "/=": "a b c a b", "maxTupleSize": "Int", "FUN": "", "id": "forall (a k). a -> a", ".": "forall (b k) (c k) (a k). (b -> c) -> (a -> b) -> a -> c", "::": "", "realWorld#": "State# RealWorld", "void#": "Void#", "nullAddr#": "Addr#", "magicDict": "a", "Addr#": "", "Array#": "", "ByteArray#": "", "Char#": "", "Double#": "", "Float#": "", "Int#": "", "Int8#": "", "Int16#": "", "Int32#": "", "Int64#": "", "Weak#": "", "MutableArray#": "", "MutableByteArray#": "", "MVar#": "", "IOPort#": "", "RealWorld": "", "StablePtr#": "", "ArrayArray#": "", "MutableArrayArray#": "", "State#": "", "StableName#": "", "MutVar#": "", "Void#": "", "Word#": "", "Word8#": "", "Word16#": "", "Word32#": "", "Word64#": "", "ThreadId#": "", "BCO": "", "TVar#": "", "Compact#": "", "Proxy#": "", "SmallArray#": "", "SmallMutableArray#": "", "Int8X16#": "", "Int16X8#": "", "Int32X4#": "", "Int64X2#": "", "Int8X32#": "", "Int16X16#": "", "Int32X8#": "", "Int64X4#": "", "Int8X64#": "", "Int16X32#": "", "Int32X16#": "", "Int64X8#": "", "Word8X16#": "", "Word16X8#": "", "Word32X4#": "", "Word64X2#": "", "Word8X32#": "", "Word16X16#": "", "Word32X8#": "", "Word64X4#": "", "Word8X64#": "", "Word16X32#": "", "Word32X16#": "", "Word64X8#": "", "FloatX4#": "", "DoubleX2#": "", "FloatX8#": "", "DoubleX4#": "", "FloatX16#": "", "DoubleX8#": "", "gtChar#": "Char# -> Char# -> Int#", "geChar#": "Char# -> Char# -> Int#", "eqChar#": "Char# -> Char# -> Int#", "neChar#": "Char# -> Char# -> Int#", "ltChar#": "Char# -> Char# -> Int#", "leChar#": "Char# -> Char# -> Int#", "ord#": "Char# -> Int#", "extendInt8#": "Int8# -> Int#", "narrowInt8#": "Int# -> Int8#", "negateInt8#": "Int8# -> Int8#", "plusInt8#": "Int8# -> Int8# -> Int8#", "subInt8#": "Int8# -> Int8# -> Int8#", "timesInt8#": "Int8# -> Int8# -> Int8#", "quotInt8#": "Int8# -> Int8# -> Int8#", "remInt8#": "Int8# -> Int8# -> Int8#", "quotRemInt8#": "Int8# -> Int8# -> (# Int8#, Int8# #)", "eqInt8#": "Int8# -> Int8# -> Int#", "geInt8#": "Int8# -> Int8# -> Int#", "gtInt8#": "Int8# -> Int8# -> Int#", "leInt8#": "Int8# -> Int8# -> Int#", "ltInt8#": "Int8# -> Int8# -> Int#", "neInt8#": "Int8# -> Int8# -> Int#", "extendWord8#": "Word8# -> Word#", "narrowWord8#": "Word# -> Word8#", "notWord8#": "Word8# -> Word8#", "plusWord8#": "Word8# -> Word8# -> Word8#", "subWord8#": "Word8# -> Word8# -> Word8#", "timesWord8#": "Word8# -> Word8# -> Word8#", "quotWord8#": "Word8# -> Word8# -> Word8#", "remWord8#": "Word8# -> Word8# -> Word8#", "quotRemWord8#": "Word8# -> Word8# -> (# Word8#, Word8# #)", "eqWord8#": "Word8# -> Word8# -> Int#", "geWord8#": "Word8# -> Word8# -> Int#", "gtWord8#": "Word8# -> Word8# -> Int#", "leWord8#": "Word8# -> Word8# -> Int#", "ltWord8#": "Word8# -> Word8# -> Int#", "neWord8#": "Word8# -> Word8# -> Int#", "extendInt16#": "Int16# -> Int#", "narrowInt16#": "Int# -> Int16#", "negateInt16#": "Int16# -> Int16#", "plusInt16#": "Int16# -> Int16# -> Int16#", "subInt16#": "Int16# -> Int16# -> Int16#", "timesInt16#": "Int16# -> Int16# -> Int16#", "quotInt16#": "Int16# -> Int16# -> Int16#", "remInt16#": "Int16# -> Int16# -> Int16#", "quotRemInt16#": "Int16# -> Int16# -> (# Int16#, Int16# #)", "eqInt16#": "Int16# -> Int16# -> Int#", "geInt16#": "Int16# -> Int16# -> Int#", "gtInt16#": "Int16# -> Int16# -> Int#", "leInt16#": "Int16# -> Int16# -> Int#", "ltInt16#": "Int16# -> Int16# -> Int#", "neInt16#": "Int16# -> Int16# -> Int#", "extendWord16#": "Word16# -> Word#", "narrowWord16#": "Word# -> Word16#", "notWord16#": "Word16# -> Word16#", "plusWord16#": "Word16# -> Word16# -> Word16#", "subWord16#": "Word16# -> Word16# -> Word16#", "timesWord16#": "Word16# -> Word16# -> Word16#", "quotWord16#": "Word16# -> Word16# -> Word16#", "remWord16#": "Word16# -> Word16# -> Word16#", "quotRemWord16#": "Word16# -> Word16# -> (# Word16#, Word16# #)", "eqWord16#": "Word16# -> Word16# -> Int#", "geWord16#": "Word16# -> Word16# -> Int#", "gtWord16#": "Word16# -> Word16# -> Int#", "leWord16#": "Word16# -> Word16# -> Int#", "ltWord16#": "Word16# -> Word16# -> Int#", "neWord16#": "Word16# -> Word16# -> Int#", "+#": "Int# -> Int# -> Int# infixl 6", "-#": "Int# -> Int# -> Int# infixl 6", "*#": "Int# -> Int# -> Int# infixl 7", "timesInt2#": "Int# -> Int# -> (# Int#, Int#, Int# #)", "mulIntMayOflo#": "Int# -> Int# -> Int#", "quotInt#": "Int# -> Int# -> Int#", "remInt#": "Int# -> Int# -> Int#", "quotRemInt#": "Int# -> Int# -> (# Int#, Int# #)", "andI#": "Int# -> Int# -> Int#", "orI#": "Int# -> Int# -> Int#", "xorI#": "Int# -> Int# -> Int#", "notI#": "Int# -> Int#", "negateInt#": "Int# -> Int#", "addIntC#": "Int# -> Int# -> (# Int#, Int# #)", "subIntC#": "Int# -> Int# -> (# Int#, Int# #)", ">#": "Int# -> Int# -> Int# infix 4", ">=#": "Int# -> Int# -> Int# infix 4", "==#": "Int# -> Int# -> Int# infix 4", "/=#": "Int# -> Int# -> Int# infix 4", "<#": "Int# -> Int# -> Int# infix 4", "<=#": "Int# -> Int# -> Int# infix 4", "chr#": "Int# -> Char#", "int2Word#": "Int# -> Word#", "int2Float#": "Int# -> Float#", "int2Double#": "Int# -> Double#", "word2Float#": "Word# -> Float#", "word2Double#": "Word# -> Double#", "uncheckedIShiftL#": "Int# -> Int# -> Int#", "uncheckedIShiftRA#": "Int# -> Int# -> Int#", "uncheckedIShiftRL#": "Int# -> Int# -> Int#", "plusWord#": "Word# -> Word# -> Word#", "addWordC#": "Word# -> Word# -> (# Word#, Int# #)", "subWordC#": "Word# -> Word# -> (# Word#, Int# #)", "plusWord2#": "Word# -> Word# -> (# Word#, Word# #)", "minusWord#": "Word# -> Word# -> Word#", "timesWord#": "Word# -> Word# -> Word#", "timesWord2#": "Word# -> Word# -> (# Word#, Word# #)", "quotWord#": "Word# -> Word# -> Word#", "remWord#": "Word# -> Word# -> Word#", "quotRemWord#": "Word# -> Word# -> (# Word#, Word# #)", "quotRemWord2#": "Word# -> Word# -> Word# -> (# Word#, Word# #)", "and#": "Word# -> Word# -> Word#", "or#": "Word# -> Word# -> Word#", "xor#": "Word# -> Word# -> Word#", "not#": "Word# -> Word#", "uncheckedShiftL#": "Word# -> Int# -> Word#", "uncheckedShiftRL#": "Word# -> Int# -> Word#", "word2Int#": "Word# -> Int#", "gtWord#": "Word# -> Word# -> Int#", "geWord#": "Word# -> Word# -> Int#", "eqWord#": "Word# -> Word# -> Int#", "neWord#": "Word# -> Word# -> Int#", "ltWord#": "Word# -> Word# -> Int#", "leWord#": "Word# -> Word# -> Int#", "popCnt8#": "Word# -> Word#", "popCnt16#": "Word# -> Word#", "popCnt32#": "Word# -> Word#", "popCnt64#": "Word# -> Word#", "popCnt#": "Word# -> Word#", "pdep8#": "Word# -> Word# -> Word#", "pdep16#": "Word# -> Word# -> Word#", "pdep32#": "Word# -> Word# -> Word#", "pdep64#": "Word# -> Word# -> Word#", "pdep#": "Word# -> Word# -> Word#", "pext8#": "Word# -> Word# -> Word#", "pext16#": "Word# -> Word# -> Word#", "pext32#": "Word# -> Word# -> Word#", "pext64#": "Word# -> Word# -> Word#", "pext#": "Word# -> Word# -> Word#", "clz8#": "Word# -> Word#", "clz16#": "Word# -> Word#", "clz32#": "Word# -> Word#", "clz64#": "Word# -> Word#", "clz#": "Word# -> Word#", "ctz8#": "Word# -> Word#", "ctz16#": "Word# -> Word#", "ctz32#": "Word# -> Word#", "ctz64#": "Word# -> Word#", "ctz#": "Word# -> Word#", "byteSwap16#": "Word# -> Word#", "byteSwap32#": "Word# -> Word#", "byteSwap64#": "Word# -> Word#", "byteSwap#": "Word# -> Word#", "bitReverse8#": "Word# -> Word#", "bitReverse16#": "Word# -> Word#", "bitReverse32#": "Word# -> Word#", "bitReverse64#": "Word# -> Word#", "bitReverse#": "Word# -> Word#", "narrow8Int#": "Int# -> Int#", "narrow16Int#": "Int# -> Int#", "narrow32Int#": "Int# -> Int#", "narrow8Word#": "Word# -> Word#", "narrow16Word#": "Word# -> Word#", "narrow32Word#": "Word# -> Word#", ">##": "Double# -> Double# -> Int# infix 4", ">=##": "Double# -> Double# -> Int# infix 4", "==##": "Double# -> Double# -> Int# infix 4", "/=##": "Double# -> Double# -> Int# infix 4", "<##": "Double# -> Double# -> Int# infix 4", "<=##": "Double# -> Double# -> Int# infix 4", "+##": "Double# -> Double# -> Double# infixl 6", "-##": "Double# -> Double# -> Double# infixl 6", "*##": "Double# -> Double# -> Double# infixl 7", "/##": "Double# -> Double# -> Double# infixl 7", "negateDouble#": "Double# -> Double#", "fabsDouble#": "Double# -> Double#", "double2Int#": "Double# -> Int#", "double2Float#": "Double# -> Float#", "expDouble#": "Double# -> Double#", "expm1Double#": "Double# -> Double#", "logDouble#": "Double# -> Double#", "log1pDouble#": "Double# -> Double#", "sqrtDouble#": "Double# -> Double#", "sinDouble#": "Double# -> Double#", "cosDouble#": "Double# -> Double#", "tanDouble#": "Double# -> Double#", "asinDouble#": "Double# -> Double#", "acosDouble#": "Double# -> Double#", "atanDouble#": "Double# -> Double#", "sinhDouble#": "Double# -> Double#", "coshDouble#": "Double# -> Double#", "tanhDouble#": "Double# -> Double#", "asinhDouble#": "Double# -> Double#", "acoshDouble#": "Double# -> Double#", "atanhDouble#": "Double# -> Double#", "**##": "Double# -> Double# -> Double#", "decodeDouble_2Int#": "Double# -> (# Int#, Word#, Word#, Int# #)", "decodeDouble_Int64#": "Double# -> (# Int#, Int# #)", "gtFloat#": "Float# -> Float# -> Int#", "geFloat#": "Float# -> Float# -> Int#", "eqFloat#": "Float# -> Float# -> Int#", "neFloat#": "Float# -> Float# -> Int#", "ltFloat#": "Float# -> Float# -> Int#", "leFloat#": "Float# -> Float# -> Int#", "plusFloat#": "Float# -> Float# -> Float#", "minusFloat#": "Float# -> Float# -> Float#", "timesFloat#": "Float# -> Float# -> Float#", "divideFloat#": "Float# -> Float# -> Float#", "negateFloat#": "Float# -> Float#", "fabsFloat#": "Float# -> Float#", "float2Int#": "Float# -> Int#", "expFloat#": "Float# -> Float#", "expm1Float#": "Float# -> Float#", "logFloat#": "Float# -> Float#", "log1pFloat#": "Float# -> Float#", "sqrtFloat#": "Float# -> Float#", "sinFloat#": "Float# -> Float#", "cosFloat#": "Float# -> Float#", "tanFloat#": "Float# -> Float#", "asinFloat#": "Float# -> Float#", "acosFloat#": "Float# -> Float#", "atanFloat#": "Float# -> Float#", "sinhFloat#": "Float# -> Float#", "coshFloat#": "Float# -> Float#", "tanhFloat#": "Float# -> Float#", "asinhFloat#": "Float# -> Float#", "acoshFloat#": "Float# -> Float#", "atanhFloat#": "Float# -> Float#", "powerFloat#": "Float# -> Float# -> Float#", "float2Double#": "Float# -> Double#", "decodeFloat_Int#": "Float# -> (# Int#, Int# #)", "newArray#": "Int# -> a -> State# d -> (# State# d, MutableArray# d a #)", "sameMutableArray#": "MutableArray# d a -> MutableArray# d a -> Int#", "readArray#": "MutableArray# d a -> Int# -> State# d -> (# State# d, a #)", "writeArray#": "MutableArray# d a -> Int# -> a -> State# d -> State# d", "sizeofArray#": "Array# a -> Int#", "sizeofMutableArray#": "MutableArray# d a -> Int#", "indexArray#": "Array# a -> Int# -> (# a #)", "unsafeFreezeArray#": "MutableArray# d a -> State# d -> (# State# d, Array# a #)", "unsafeThawArray#": "Array# a -> State# d -> (# State# d, MutableArray# d a #)", "copyArray#": "Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d", "copyMutableArray#": "MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d", "cloneArray#": "Array# a -> Int# -> Int# -> Array# a", "cloneMutableArray#": "MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)", "freezeArray#": "MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)", "thawArray#": "Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)", "casArray#": "MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)", "newSmallArray#": "Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)", "sameSmallMutableArray#": "SmallMutableArray# d a -> SmallMutableArray# d a -> Int#", "shrinkSmallMutableArray#": "SmallMutableArray# d a -> Int# -> State# d -> State# d", "readSmallArray#": "SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)", "writeSmallArray#": "SmallMutableArray# d a -> Int# -> a -> State# d -> State# d", "sizeofSmallArray#": "SmallArray# a -> Int#", "sizeofSmallMutableArray#": "SmallMutableArray# d a -> Int#", "getSizeofSmallMutableArray#": "SmallMutableArray# d a -> State# d -> (# State# d, Int# #)", "indexSmallArray#": "SmallArray# a -> Int# -> (# a #)", "unsafeFreezeSmallArray#": "SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)", "unsafeThawSmallArray#": "SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)", "copySmallArray#": "SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d", "copySmallMutableArray#": "SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d", "cloneSmallArray#": "SmallArray# a -> Int# -> Int# -> SmallArray# a", "cloneSmallMutableArray#": "SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)", "freezeSmallArray#": "SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)", "thawSmallArray#": "SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)", "casSmallArray#": "SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)", "newByteArray#": "Int# -> State# d -> (# State# d, MutableByteArray# d #)", "newPinnedByteArray#": "Int# -> State# d -> (# State# d, MutableByteArray# d #)", "newAlignedPinnedByteArray#": "Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)", "isMutableByteArrayPinned#": "MutableByteArray# d -> Int#", "isByteArrayPinned#": "ByteArray# -> Int#", "byteArrayContents#": "ByteArray# -> Addr#", "sameMutableByteArray#": "MutableByteArray# d -> MutableByteArray# d -> Int#", "shrinkMutableByteArray#": "MutableByteArray# d -> Int# -> State# d -> State# d", "resizeMutableByteArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)", "unsafeFreezeByteArray#": "MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)", "sizeofByteArray#": "ByteArray# -> Int#", "sizeofMutableByteArray#": "MutableByteArray# d -> Int#", "getSizeofMutableByteArray#": "MutableByteArray# d -> State# d -> (# State# d, Int# #)", "indexCharArray#": "ByteArray# -> Int# -> Char#", "indexWideCharArray#": "ByteArray# -> Int# -> Char#", "indexIntArray#": "ByteArray# -> Int# -> Int#", "indexWordArray#": "ByteArray# -> Int# -> Word#", "indexAddrArray#": "ByteArray# -> Int# -> Addr#", "indexFloatArray#": "ByteArray# -> Int# -> Float#", "indexDoubleArray#": "ByteArray# -> Int# -> Double#", "indexStablePtrArray#": "ByteArray# -> Int# -> StablePtr# a", "indexInt8Array#": "ByteArray# -> Int# -> Int#", "indexInt16Array#": "ByteArray# -> Int# -> Int#", "indexInt32Array#": "ByteArray# -> Int# -> Int#", "indexInt64Array#": "ByteArray# -> Int# -> Int#", "indexWord8Array#": "ByteArray# -> Int# -> Word#", "indexWord16Array#": "ByteArray# -> Int# -> Word#", "indexWord32Array#": "ByteArray# -> Int# -> Word#", "indexWord64Array#": "ByteArray# -> Int# -> Word#", "indexWord8ArrayAsChar#": "ByteArray# -> Int# -> Char#", "indexWord8ArrayAsWideChar#": "ByteArray# -> Int# -> Char#", "indexWord8ArrayAsAddr#": "ByteArray# -> Int# -> Addr#", "indexWord8ArrayAsFloat#": "ByteArray# -> Int# -> Float#", "indexWord8ArrayAsDouble#": "ByteArray# -> Int# -> Double#", "indexWord8ArrayAsStablePtr#": "ByteArray# -> Int# -> StablePtr# a", "indexWord8ArrayAsInt16#": "ByteArray# -> Int# -> Int#", "indexWord8ArrayAsInt32#": "ByteArray# -> Int# -> Int#", "indexWord8ArrayAsInt64#": "ByteArray# -> Int# -> Int#", "indexWord8ArrayAsInt#": "ByteArray# -> Int# -> Int#", "indexWord8ArrayAsWord16#": "ByteArray# -> Int# -> Word#", "indexWord8ArrayAsWord32#": "ByteArray# -> Int# -> Word#", "indexWord8ArrayAsWord64#": "ByteArray# -> Int# -> Word#", "indexWord8ArrayAsWord#": "ByteArray# -> Int# -> Word#", "readCharArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)", "readWideCharArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)", "readIntArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWordArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readAddrArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)", "readFloatArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)", "readDoubleArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)", "readStablePtrArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)", "readInt8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readInt16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readInt32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readInt64Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWord8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord64Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord8ArrayAsChar#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)", "readWord8ArrayAsWideChar#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)", "readWord8ArrayAsAddr#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)", "readWord8ArrayAsFloat#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)", "readWord8ArrayAsDouble#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)", "readWord8ArrayAsStablePtr#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)", "readWord8ArrayAsInt16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWord8ArrayAsInt32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWord8ArrayAsInt64#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWord8ArrayAsInt#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "readWord8ArrayAsWord16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord8ArrayAsWord32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord8ArrayAsWord64#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "readWord8ArrayAsWord#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)", "writeCharArray#": "MutableByteArray# d -> Int# -> Char# -> State# d -> State# d", "writeWideCharArray#": "MutableByteArray# d -> Int# -> Char# -> State# d -> State# d", "writeIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWordArray#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeAddrArray#": "MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d", "writeFloatArray#": "MutableByteArray# d -> Int# -> Float# -> State# d -> State# d", "writeDoubleArray#": "MutableByteArray# d -> Int# -> Double# -> State# d -> State# d", "writeStablePtrArray#": "MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d", "writeInt8Array#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeInt16Array#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeInt32Array#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeInt64Array#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWord8Array#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord16Array#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord32Array#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord64Array#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord8ArrayAsChar#": "MutableByteArray# d -> Int# -> Char# -> State# d -> State# d", "writeWord8ArrayAsWideChar#": "MutableByteArray# d -> Int# -> Char# -> State# d -> State# d", "writeWord8ArrayAsAddr#": "MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d", "writeWord8ArrayAsFloat#": "MutableByteArray# d -> Int# -> Float# -> State# d -> State# d", "writeWord8ArrayAsDouble#": "MutableByteArray# d -> Int# -> Double# -> State# d -> State# d", "writeWord8ArrayAsStablePtr#": "MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d", "writeWord8ArrayAsInt16#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWord8ArrayAsInt32#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWord8ArrayAsInt64#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWord8ArrayAsInt#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "writeWord8ArrayAsWord16#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord8ArrayAsWord32#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord8ArrayAsWord64#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "writeWord8ArrayAsWord#": "MutableByteArray# d -> Int# -> Word# -> State# d -> State# d", "compareByteArrays#": "ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#", "copyByteArray#": "ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "copyMutableByteArray#": "MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "copyByteArrayToAddr#": "ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d", "copyMutableByteArrayToAddr#": "MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d", "copyAddrToByteArray#": "Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "setByteArray#": "MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d", "atomicReadIntArray#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)", "atomicWriteIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> State# d", "casIntArray#": "MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchAddIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchSubIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchAndIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchNandIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchOrIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "fetchXorIntArray#": "MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)", "newArrayArray#": "Int# -> State# d -> (# State# d, MutableArrayArray# d #)", "sameMutableArrayArray#": "MutableArrayArray# d -> MutableArrayArray# d -> Int#", "unsafeFreezeArrayArray#": "MutableArrayArray# d -> State# d -> (# State# d, ArrayArray# #)", "sizeofArrayArray#": "ArrayArray# -> Int#", "sizeofMutableArrayArray#": "MutableArrayArray# d -> Int#", "indexByteArrayArray#": "ArrayArray# -> Int# -> ByteArray#", "indexArrayArrayArray#": "ArrayArray# -> Int# -> ArrayArray#", "readByteArrayArray#": "MutableArrayArray# d -> Int# -> State# d -> (# State# d, ByteArray# #)", "readMutableByteArrayArray#": "MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)", "readArrayArrayArray#": "MutableArrayArray# d -> Int# -> State# d -> (# State# d, ArrayArray# #)", "readMutableArrayArrayArray#": "MutableArrayArray# d -> Int# -> State# d -> (# State# d, MutableArrayArray# d #)", "writeByteArrayArray#": "MutableArrayArray# d -> Int# -> ByteArray# -> State# d -> State# d", "writeMutableByteArrayArray#": "MutableArrayArray# d -> Int# -> MutableByteArray# d -> State# d -> State# d", "writeArrayArrayArray#": "MutableArrayArray# d -> Int# -> ArrayArray# -> State# d -> State# d", "writeMutableArrayArrayArray#": "MutableArrayArray# d -> Int# -> MutableArrayArray# d -> State# d -> State# d", "copyArrayArray#": "ArrayArray# -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d", "copyMutableArrayArray#": "MutableArrayArray# d -> Int# -> MutableArrayArray# d -> Int# -> Int# -> State# d -> State# d", "plusAddr#": "Addr# -> Int# -> Addr#", "minusAddr#": "Addr# -> Addr# -> Int#", "remAddr#": "Addr# -> Int# -> Int#", "addr2Int#": "Addr# -> Int#", "int2Addr#": "Int# -> Addr#", "gtAddr#": "Addr# -> Addr# -> Int#", "geAddr#": "Addr# -> Addr# -> Int#", "eqAddr#": "Addr# -> Addr# -> Int#", "neAddr#": "Addr# -> Addr# -> Int#", "ltAddr#": "Addr# -> Addr# -> Int#", "leAddr#": "Addr# -> Addr# -> Int#", "indexCharOffAddr#": "Addr# -> Int# -> Char#", "indexWideCharOffAddr#": "Addr# -> Int# -> Char#", "indexIntOffAddr#": "Addr# -> Int# -> Int#", "indexWordOffAddr#": "Addr# -> Int# -> Word#", "indexAddrOffAddr#": "Addr# -> Int# -> Addr#", "indexFloatOffAddr#": "Addr# -> Int# -> Float#", "indexDoubleOffAddr#": "Addr# -> Int# -> Double#", "indexStablePtrOffAddr#": "Addr# -> Int# -> StablePtr# a", "indexInt8OffAddr#": "Addr# -> Int# -> Int#", "indexInt16OffAddr#": "Addr# -> Int# -> Int#", "indexInt32OffAddr#": "Addr# -> Int# -> Int#", "indexInt64OffAddr#": "Addr# -> Int# -> Int#", "indexWord8OffAddr#": "Addr# -> Int# -> Word#", "indexWord16OffAddr#": "Addr# -> Int# -> Word#", "indexWord32OffAddr#": "Addr# -> Int# -> Word#", "indexWord64OffAddr#": "Addr# -> Int# -> Word#", "readCharOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Char# #)", "readWideCharOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Char# #)", "readIntOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int# #)", "readWordOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word# #)", "readAddrOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Addr# #)", "readFloatOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Float# #)", "readDoubleOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Double# #)", "readStablePtrOffAddr#": "Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)", "readInt8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int# #)", "readInt16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int# #)", "readInt32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int# #)", "readInt64OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int# #)", "readWord8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word# #)", "readWord16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word# #)", "readWord32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word# #)", "readWord64OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word# #)", "writeCharOffAddr#": "Addr# -> Int# -> Char# -> State# d -> State# d", "writeWideCharOffAddr#": "Addr# -> Int# -> Char# -> State# d -> State# d", "writeIntOffAddr#": "Addr# -> Int# -> Int# -> State# d -> State# d", "writeWordOffAddr#": "Addr# -> Int# -> Word# -> State# d -> State# d", "writeAddrOffAddr#": "Addr# -> Int# -> Addr# -> State# d -> State# d", "writeFloatOffAddr#": "Addr# -> Int# -> Float# -> State# d -> State# d", "writeDoubleOffAddr#": "Addr# -> Int# -> Double# -> State# d -> State# d", "writeStablePtrOffAddr#": "Addr# -> Int# -> StablePtr# a -> State# d -> State# d", "writeInt8OffAddr#": "Addr# -> Int# -> Int# -> State# d -> State# d", "writeInt16OffAddr#": "Addr# -> Int# -> Int# -> State# d -> State# d", "writeInt32OffAddr#": "Addr# -> Int# -> Int# -> State# d -> State# d", "writeInt64OffAddr#": "Addr# -> Int# -> Int# -> State# d -> State# d", "writeWord8OffAddr#": "Addr# -> Int# -> Word# -> State# d -> State# d", "writeWord16OffAddr#": "Addr# -> Int# -> Word# -> State# d -> State# d", "writeWord32OffAddr#": "Addr# -> Int# -> Word# -> State# d -> State# d", "writeWord64OffAddr#": "Addr# -> Int# -> Word# -> State# d -> State# d", "atomicExchangeAddrAddr#": "Addr# -> Addr# -> State# d -> (# State# d, Addr# #)", "atomicExchangeWordAddr#": "Addr# -> Word# -> State# d -> (# State# d, Word# #)", "atomicCasAddrAddr#": "Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)", "atomicCasWordAddr#": "Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)", "newMutVar#": "a -> State# d -> (# State# d, MutVar# d a #)", "readMutVar#": "MutVar# d a -> State# d -> (# State# d, a #)", "writeMutVar#": "MutVar# d a -> a -> State# d -> State# d", "sameMutVar#": "MutVar# d a -> MutVar# d a -> Int#", "atomicModifyMutVar2#": "MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)", "atomicModifyMutVar_#": "MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)", "casMutVar#": "MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)", "catch#": "(State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "raiseIO#": "a -> State# RealWorld -> (# State# RealWorld, b #)", "maskAsyncExceptions#": "(State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "maskUninterruptible#": "(State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "unmaskAsyncExceptions#": "(State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "getMaskingState#": "State# RealWorld -> (# State# RealWorld, Int# #)", "atomically#": "(State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "retry#": "State# RealWorld -> (# State# RealWorld, a #)", "catchRetry#": "(State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "catchSTM#": "(State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)", "newTVar#": "a -> State# d -> (# State# d, TVar# d a #)", "readTVar#": "TVar# d a -> State# d -> (# State# d, a #)", "readTVarIO#": "TVar# d a -> State# d -> (# State# d, a #)", "writeTVar#": "TVar# d a -> a -> State# d -> State# d", "sameTVar#": "TVar# d a -> TVar# d a -> Int#", "newMVar#": "State# d -> (# State# d, MVar# d a #)", "takeMVar#": "MVar# d a -> State# d -> (# State# d, a #)", "tryTakeMVar#": "MVar# d a -> State# d -> (# State# d, Int#, a #)", "putMVar#": "MVar# d a -> a -> State# d -> State# d", "tryPutMVar#": "MVar# d a -> a -> State# d -> (# State# d, Int# #)", "readMVar#": "MVar# d a -> State# d -> (# State# d, a #)", "tryReadMVar#": "MVar# d a -> State# d -> (# State# d, Int#, a #)", "sameMVar#": "MVar# d a -> MVar# d a -> Int#", "isEmptyMVar#": "MVar# d a -> State# d -> (# State# d, Int# #)", "newIOPort#": "State# d -> (# State# d, IOPort# d a #)", "readIOPort#": "IOPort# d a -> State# d -> (# State# d, a #)", "writeIOPort#": "IOPort# d a -> a -> State# d -> (# State# d, Int# #)", "sameIOPort#": "IOPort# d a -> IOPort# d a -> Int#", "delay#": "Int# -> State# d -> State# d", "waitRead#": "Int# -> State# d -> State# d", "waitWrite#": "Int# -> State# d -> State# d", "fork#": "a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)", "forkOn#": "Int# -> a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)", "killThread#": "ThreadId# -> a -> State# RealWorld -> State# RealWorld", "yield#": "State# RealWorld -> State# RealWorld", "myThreadId#": "State# RealWorld -> (# State# RealWorld, ThreadId# #)", "labelThread#": "ThreadId# -> Addr# -> State# RealWorld -> State# RealWorld", "isCurrentThreadBound#": "State# RealWorld -> (# State# RealWorld, Int# #)", "noDuplicate#": "State# d -> State# d", "threadStatus#": "ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)", "addCFinalizerToWeak#": "Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)", "deRefWeak#": "Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)", "finalizeWeak#": "Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)", "makeStablePtr#": "a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)", "deRefStablePtr#": "StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)", "eqStablePtr#": "StablePtr# a -> StablePtr# a -> Int#", "makeStableName#": "a -> State# RealWorld -> (# State# RealWorld, StableName# a #)", "eqStableName#": "StableName# a -> StableName# b -> Int#", "stableNameToInt#": "StableName# a -> Int#", "compactNew#": "Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)", "compactResize#": "Compact# -> Word# -> State# RealWorld -> State# RealWorld", "compactContains#": "Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)", "compactContainsAny#": "a -> State# RealWorld -> (# State# RealWorld, Int# #)", "compactGetFirstBlock#": "Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)", "compactGetNextBlock#": "Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)", "compactAllocateBlock#": "Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)", "compactFixupPointers#": "Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)", "compactAdd#": "Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)", "compactAddWithSharing#": "Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)", "compactSize#": "Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)", "reallyUnsafePtrEquality#": "a -> a -> Int#", "par#": "a -> Int#", "spark#": "a -> State# d -> (# State# d, a #)", "seq#": "a -> State# d -> (# State# d, a #)", "getSpark#": "State# d -> (# State# d, Int#, a #)", "numSparks#": "State# d -> (# State# d, Int# #)", "dataToTag#": "a -> Int#", "tagToEnum#": "Int# -> a", "addrToAny#": "Addr# -> (# a #)", "anyToAddr#": "a -> State# RealWorld -> (# State# RealWorld, Addr# #)", "mkApUpd0#": "BCO -> (# a #)", "newBCO#": "ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)", "unpackClosure#": "a -> (# Addr#, ByteArray#, Array# b #)", "closureSize#": "a -> Int#", "getApStackVal#": "a -> Int# -> (# Int#, b #)", "getCCSOf#": "a -> State# d -> (# State# d, Addr# #)", "getCurrentCCS#": "a -> State# d -> (# State# d, Addr# #)", "clearCCS#": "(State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)", "traceEvent#": "Addr# -> State# d -> State# d", "traceBinaryEvent#": "Addr# -> Int# -> State# d -> State# d", "traceMarker#": "Addr# -> State# d -> State# d", "setThreadAllocationCounter#": "Int# -> State# RealWorld -> State# RealWorld", "broadcastInt8X16#": "Int# -> Int8X16#", "broadcastInt16X8#": "Int# -> Int16X8#", "broadcastInt32X4#": "Int# -> Int32X4#", "broadcastInt64X2#": "Int# -> Int64X2#", "broadcastInt8X32#": "Int# -> Int8X32#", "broadcastInt16X16#": "Int# -> Int16X16#", "broadcastInt32X8#": "Int# -> Int32X8#", "broadcastInt64X4#": "Int# -> Int64X4#", "broadcastInt8X64#": "Int# -> Int8X64#", "broadcastInt16X32#": "Int# -> Int16X32#", "broadcastInt32X16#": "Int# -> Int32X16#", "broadcastInt64X8#": "Int# -> Int64X8#", "broadcastWord8X16#": "Word# -> Word8X16#", "broadcastWord16X8#": "Word# -> Word16X8#", "broadcastWord32X4#": "Word# -> Word32X4#", "broadcastWord64X2#": "Word# -> Word64X2#", "broadcastWord8X32#": "Word# -> Word8X32#", "broadcastWord16X16#": "Word# -> Word16X16#", "broadcastWord32X8#": "Word# -> Word32X8#", "broadcastWord64X4#": "Word# -> Word64X4#", "broadcastWord8X64#": "Word# -> Word8X64#", "broadcastWord16X32#": "Word# -> Word16X32#", "broadcastWord32X16#": "Word# -> Word32X16#", "broadcastWord64X8#": "Word# -> Word64X8#", "broadcastFloatX4#": "Float# -> FloatX4#", "broadcastDoubleX2#": "Double# -> DoubleX2#", "broadcastFloatX8#": "Float# -> FloatX8#", "broadcastDoubleX4#": "Double# -> DoubleX4#", "broadcastFloatX16#": "Float# -> FloatX16#", "broadcastDoubleX8#": "Double# -> DoubleX8#", "packInt8X16#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X16#", "packInt16X8#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X8#", "packInt32X4#": "(# Int#, Int#, Int#, Int# #) -> Int32X4#", "packInt64X2#": "(# Int#, Int# #) -> Int64X2#", "packInt8X32#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X32#", "packInt16X16#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X16#", "packInt32X8#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X8#", "packInt64X4#": "(# Int#, Int#, Int#, Int# #) -> Int64X4#", "packInt8X64#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int8X64#", "packInt16X32#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int16X32#", "packInt32X16#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int32X16#", "packInt64X8#": "(# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #) -> Int64X8#", "packWord8X16#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X16#", "packWord16X8#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X8#", "packWord32X4#": "(# Word#, Word#, Word#, Word# #) -> Word32X4#", "packWord64X2#": "(# Word#, Word# #) -> Word64X2#", "packWord8X32#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X32#", "packWord16X16#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X16#", "packWord32X8#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X8#", "packWord64X4#": "(# Word#, Word#, Word#, Word# #) -> Word64X4#", "packWord8X64#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word8X64#", "packWord16X32#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word16X32#", "packWord32X16#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word32X16#", "packWord64X8#": "(# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #) -> Word64X8#", "packFloatX4#": "(# Float#, Float#, Float#, Float# #) -> FloatX4#", "packDoubleX2#": "(# Double#, Double# #) -> DoubleX2#", "packFloatX8#": "(# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#", "packDoubleX4#": "(# Double#, Double#, Double#, Double# #) -> DoubleX4#", "packFloatX16#": "(# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#", "packDoubleX8#": "(# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#", "unpackInt8X16#": "Int8X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt16X8#": "Int16X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt32X4#": "Int32X4# -> (# Int#, Int#, Int#, Int# #)", "unpackInt64X2#": "Int64X2# -> (# Int#, Int# #)", "unpackInt8X32#": "Int8X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt16X16#": "Int16X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt32X8#": "Int32X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt64X4#": "Int64X4# -> (# Int#, Int#, Int#, Int# #)", "unpackInt8X64#": "Int8X64# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt16X32#": "Int16X32# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt32X16#": "Int32X16# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackInt64X8#": "Int64X8# -> (# Int#, Int#, Int#, Int#, Int#, Int#, Int#, Int# #)", "unpackWord8X16#": "Word8X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord16X8#": "Word16X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord32X4#": "Word32X4# -> (# Word#, Word#, Word#, Word# #)", "unpackWord64X2#": "Word64X2# -> (# Word#, Word# #)", "unpackWord8X32#": "Word8X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord16X16#": "Word16X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord32X8#": "Word32X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord64X4#": "Word64X4# -> (# Word#, Word#, Word#, Word# #)", "unpackWord8X64#": "Word8X64# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord16X32#": "Word16X32# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord32X16#": "Word32X16# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackWord64X8#": "Word64X8# -> (# Word#, Word#, Word#, Word#, Word#, Word#, Word#, Word# #)", "unpackFloatX4#": "FloatX4# -> (# Float#, Float#, Float#, Float# #)", "unpackDoubleX2#": "DoubleX2# -> (# Double#, Double# #)", "unpackFloatX8#": "FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)", "unpackDoubleX4#": "DoubleX4# -> (# Double#, Double#, Double#, Double# #)", "unpackFloatX16#": "FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)", "unpackDoubleX8#": "DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)", "insertInt8X16#": "Int8X16# -> Int# -> Int# -> Int8X16#", "insertInt16X8#": "Int16X8# -> Int# -> Int# -> Int16X8#", "insertInt32X4#": "Int32X4# -> Int# -> Int# -> Int32X4#", "insertInt64X2#": "Int64X2# -> Int# -> Int# -> Int64X2#", "insertInt8X32#": "Int8X32# -> Int# -> Int# -> Int8X32#", "insertInt16X16#": "Int16X16# -> Int# -> Int# -> Int16X16#", "insertInt32X8#": "Int32X8# -> Int# -> Int# -> Int32X8#", "insertInt64X4#": "Int64X4# -> Int# -> Int# -> Int64X4#", "insertInt8X64#": "Int8X64# -> Int# -> Int# -> Int8X64#", "insertInt16X32#": "Int16X32# -> Int# -> Int# -> Int16X32#", "insertInt32X16#": "Int32X16# -> Int# -> Int# -> Int32X16#", "insertInt64X8#": "Int64X8# -> Int# -> Int# -> Int64X8#", "insertWord8X16#": "Word8X16# -> Word# -> Int# -> Word8X16#", "insertWord16X8#": "Word16X8# -> Word# -> Int# -> Word16X8#", "insertWord32X4#": "Word32X4# -> Word# -> Int# -> Word32X4#", "insertWord64X2#": "Word64X2# -> Word# -> Int# -> Word64X2#", "insertWord8X32#": "Word8X32# -> Word# -> Int# -> Word8X32#", "insertWord16X16#": "Word16X16# -> Word# -> Int# -> Word16X16#", "insertWord32X8#": "Word32X8# -> Word# -> Int# -> Word32X8#", "insertWord64X4#": "Word64X4# -> Word# -> Int# -> Word64X4#", "insertWord8X64#": "Word8X64# -> Word# -> Int# -> Word8X64#", "insertWord16X32#": "Word16X32# -> Word# -> Int# -> Word16X32#", "insertWord32X16#": "Word32X16# -> Word# -> Int# -> Word32X16#", "insertWord64X8#": "Word64X8# -> Word# -> Int# -> Word64X8#", "insertFloatX4#": "FloatX4# -> Float# -> Int# -> FloatX4#", "insertDoubleX2#": "DoubleX2# -> Double# -> Int# -> DoubleX2#", "insertFloatX8#": "FloatX8# -> Float# -> Int# -> FloatX8#", "insertDoubleX4#": "DoubleX4# -> Double# -> Int# -> DoubleX4#", "insertFloatX16#": "FloatX16# -> Float# -> Int# -> FloatX16#", "insertDoubleX8#": "DoubleX8# -> Double# -> Int# -> DoubleX8#", "plusInt8X16#": "Int8X16# -> Int8X16# -> Int8X16#", "plusInt16X8#": "Int16X8# -> Int16X8# -> Int16X8#", "plusInt32X4#": "Int32X4# -> Int32X4# -> Int32X4#", "plusInt64X2#": "Int64X2# -> Int64X2# -> Int64X2#", "plusInt8X32#": "Int8X32# -> Int8X32# -> Int8X32#", "plusInt16X16#": "Int16X16# -> Int16X16# -> Int16X16#", "plusInt32X8#": "Int32X8# -> Int32X8# -> Int32X8#", "plusInt64X4#": "Int64X4# -> Int64X4# -> Int64X4#", "plusInt8X64#": "Int8X64# -> Int8X64# -> Int8X64#", "plusInt16X32#": "Int16X32# -> Int16X32# -> Int16X32#", "plusInt32X16#": "Int32X16# -> Int32X16# -> Int32X16#", "plusInt64X8#": "Int64X8# -> Int64X8# -> Int64X8#", "plusWord8X16#": "Word8X16# -> Word8X16# -> Word8X16#", "plusWord16X8#": "Word16X8# -> Word16X8# -> Word16X8#", "plusWord32X4#": "Word32X4# -> Word32X4# -> Word32X4#", "plusWord64X2#": "Word64X2# -> Word64X2# -> Word64X2#", "plusWord8X32#": "Word8X32# -> Word8X32# -> Word8X32#", "plusWord16X16#": "Word16X16# -> Word16X16# -> Word16X16#", "plusWord32X8#": "Word32X8# -> Word32X8# -> Word32X8#", "plusWord64X4#": "Word64X4# -> Word64X4# -> Word64X4#", "plusWord8X64#": "Word8X64# -> Word8X64# -> Word8X64#", "plusWord16X32#": "Word16X32# -> Word16X32# -> Word16X32#", "plusWord32X16#": "Word32X16# -> Word32X16# -> Word32X16#", "plusWord64X8#": "Word64X8# -> Word64X8# -> Word64X8#", "plusFloatX4#": "FloatX4# -> FloatX4# -> FloatX4#", "plusDoubleX2#": "DoubleX2# -> DoubleX2# -> DoubleX2#", "plusFloatX8#": "FloatX8# -> FloatX8# -> FloatX8#", "plusDoubleX4#": "DoubleX4# -> DoubleX4# -> DoubleX4#", "plusFloatX16#": "FloatX16# -> FloatX16# -> FloatX16#", "plusDoubleX8#": "DoubleX8# -> DoubleX8# -> DoubleX8#", "minusInt8X16#": "Int8X16# -> Int8X16# -> Int8X16#", "minusInt16X8#": "Int16X8# -> Int16X8# -> Int16X8#", "minusInt32X4#": "Int32X4# -> Int32X4# -> Int32X4#", "minusInt64X2#": "Int64X2# -> Int64X2# -> Int64X2#", "minusInt8X32#": "Int8X32# -> Int8X32# -> Int8X32#", "minusInt16X16#": "Int16X16# -> Int16X16# -> Int16X16#", "minusInt32X8#": "Int32X8# -> Int32X8# -> Int32X8#", "minusInt64X4#": "Int64X4# -> Int64X4# -> Int64X4#", "minusInt8X64#": "Int8X64# -> Int8X64# -> Int8X64#", "minusInt16X32#": "Int16X32# -> Int16X32# -> Int16X32#", "minusInt32X16#": "Int32X16# -> Int32X16# -> Int32X16#", "minusInt64X8#": "Int64X8# -> Int64X8# -> Int64X8#", "minusWord8X16#": "Word8X16# -> Word8X16# -> Word8X16#", "minusWord16X8#": "Word16X8# -> Word16X8# -> Word16X8#", "minusWord32X4#": "Word32X4# -> Word32X4# -> Word32X4#", "minusWord64X2#": "Word64X2# -> Word64X2# -> Word64X2#", "minusWord8X32#": "Word8X32# -> Word8X32# -> Word8X32#", "minusWord16X16#": "Word16X16# -> Word16X16# -> Word16X16#", "minusWord32X8#": "Word32X8# -> Word32X8# -> Word32X8#", "minusWord64X4#": "Word64X4# -> Word64X4# -> Word64X4#", "minusWord8X64#": "Word8X64# -> Word8X64# -> Word8X64#", "minusWord16X32#": "Word16X32# -> Word16X32# -> Word16X32#", "minusWord32X16#": "Word32X16# -> Word32X16# -> Word32X16#", "minusWord64X8#": "Word64X8# -> Word64X8# -> Word64X8#", "minusFloatX4#": "FloatX4# -> FloatX4# -> FloatX4#", "minusDoubleX2#": "DoubleX2# -> DoubleX2# -> DoubleX2#", "minusFloatX8#": "FloatX8# -> FloatX8# -> FloatX8#", "minusDoubleX4#": "DoubleX4# -> DoubleX4# -> DoubleX4#", "minusFloatX16#": "FloatX16# -> FloatX16# -> FloatX16#", "minusDoubleX8#": "DoubleX8# -> DoubleX8# -> DoubleX8#", "timesInt8X16#": "Int8X16# -> Int8X16# -> Int8X16#", "timesInt16X8#": "Int16X8# -> Int16X8# -> Int16X8#", "timesInt32X4#": "Int32X4# -> Int32X4# -> Int32X4#", "timesInt64X2#": "Int64X2# -> Int64X2# -> Int64X2#", "timesInt8X32#": "Int8X32# -> Int8X32# -> Int8X32#", "timesInt16X16#": "Int16X16# -> Int16X16# -> Int16X16#", "timesInt32X8#": "Int32X8# -> Int32X8# -> Int32X8#", "timesInt64X4#": "Int64X4# -> Int64X4# -> Int64X4#", "timesInt8X64#": "Int8X64# -> Int8X64# -> Int8X64#", "timesInt16X32#": "Int16X32# -> Int16X32# -> Int16X32#", "timesInt32X16#": "Int32X16# -> Int32X16# -> Int32X16#", "timesInt64X8#": "Int64X8# -> Int64X8# -> Int64X8#", "timesWord8X16#": "Word8X16# -> Word8X16# -> Word8X16#", "timesWord16X8#": "Word16X8# -> Word16X8# -> Word16X8#", "timesWord32X4#": "Word32X4# -> Word32X4# -> Word32X4#", "timesWord64X2#": "Word64X2# -> Word64X2# -> Word64X2#", "timesWord8X32#": "Word8X32# -> Word8X32# -> Word8X32#", "timesWord16X16#": "Word16X16# -> Word16X16# -> Word16X16#", "timesWord32X8#": "Word32X8# -> Word32X8# -> Word32X8#", "timesWord64X4#": "Word64X4# -> Word64X4# -> Word64X4#", "timesWord8X64#": "Word8X64# -> Word8X64# -> Word8X64#", "timesWord16X32#": "Word16X32# -> Word16X32# -> Word16X32#", "timesWord32X16#": "Word32X16# -> Word32X16# -> Word32X16#", "timesWord64X8#": "Word64X8# -> Word64X8# -> Word64X8#", "timesFloatX4#": "FloatX4# -> FloatX4# -> FloatX4#", "timesDoubleX2#": "DoubleX2# -> DoubleX2# -> DoubleX2#", "timesFloatX8#": "FloatX8# -> FloatX8# -> FloatX8#", "timesDoubleX4#": "DoubleX4# -> DoubleX4# -> DoubleX4#", "timesFloatX16#": "FloatX16# -> FloatX16# -> FloatX16#", "timesDoubleX8#": "DoubleX8# -> DoubleX8# -> DoubleX8#", "divideFloatX4#": "FloatX4# -> FloatX4# -> FloatX4#", "divideDoubleX2#": "DoubleX2# -> DoubleX2# -> DoubleX2#", "divideFloatX8#": "FloatX8# -> FloatX8# -> FloatX8#", "divideDoubleX4#": "DoubleX4# -> DoubleX4# -> DoubleX4#", "divideFloatX16#": "FloatX16# -> FloatX16# -> FloatX16#", "divideDoubleX8#": "DoubleX8# -> DoubleX8# -> DoubleX8#", "quotInt8X16#": "Int8X16# -> Int8X16# -> Int8X16#", "quotInt16X8#": "Int16X8# -> Int16X8# -> Int16X8#", "quotInt32X4#": "Int32X4# -> Int32X4# -> Int32X4#", "quotInt64X2#": "Int64X2# -> Int64X2# -> Int64X2#", "quotInt8X32#": "Int8X32# -> Int8X32# -> Int8X32#", "quotInt16X16#": "Int16X16# -> Int16X16# -> Int16X16#", "quotInt32X8#": "Int32X8# -> Int32X8# -> Int32X8#", "quotInt64X4#": "Int64X4# -> Int64X4# -> Int64X4#", "quotInt8X64#": "Int8X64# -> Int8X64# -> Int8X64#", "quotInt16X32#": "Int16X32# -> Int16X32# -> Int16X32#", "quotInt32X16#": "Int32X16# -> Int32X16# -> Int32X16#", "quotInt64X8#": "Int64X8# -> Int64X8# -> Int64X8#", "quotWord8X16#": "Word8X16# -> Word8X16# -> Word8X16#", "quotWord16X8#": "Word16X8# -> Word16X8# -> Word16X8#", "quotWord32X4#": "Word32X4# -> Word32X4# -> Word32X4#", "quotWord64X2#": "Word64X2# -> Word64X2# -> Word64X2#", "quotWord8X32#": "Word8X32# -> Word8X32# -> Word8X32#", "quotWord16X16#": "Word16X16# -> Word16X16# -> Word16X16#", "quotWord32X8#": "Word32X8# -> Word32X8# -> Word32X8#", "quotWord64X4#": "Word64X4# -> Word64X4# -> Word64X4#", "quotWord8X64#": "Word8X64# -> Word8X64# -> Word8X64#", "quotWord16X32#": "Word16X32# -> Word16X32# -> Word16X32#", "quotWord32X16#": "Word32X16# -> Word32X16# -> Word32X16#", "quotWord64X8#": "Word64X8# -> Word64X8# -> Word64X8#", "remInt8X16#": "Int8X16# -> Int8X16# -> Int8X16#", "remInt16X8#": "Int16X8# -> Int16X8# -> Int16X8#", "remInt32X4#": "Int32X4# -> Int32X4# -> Int32X4#", "remInt64X2#": "Int64X2# -> Int64X2# -> Int64X2#", "remInt8X32#": "Int8X32# -> Int8X32# -> Int8X32#", "remInt16X16#": "Int16X16# -> Int16X16# -> Int16X16#", "remInt32X8#": "Int32X8# -> Int32X8# -> Int32X8#", "remInt64X4#": "Int64X4# -> Int64X4# -> Int64X4#", "remInt8X64#": "Int8X64# -> Int8X64# -> Int8X64#", "remInt16X32#": "Int16X32# -> Int16X32# -> Int16X32#", "remInt32X16#": "Int32X16# -> Int32X16# -> Int32X16#", "remInt64X8#": "Int64X8# -> Int64X8# -> Int64X8#", "remWord8X16#": "Word8X16# -> Word8X16# -> Word8X16#", "remWord16X8#": "Word16X8# -> Word16X8# -> Word16X8#", "remWord32X4#": "Word32X4# -> Word32X4# -> Word32X4#", "remWord64X2#": "Word64X2# -> Word64X2# -> Word64X2#", "remWord8X32#": "Word8X32# -> Word8X32# -> Word8X32#", "remWord16X16#": "Word16X16# -> Word16X16# -> Word16X16#", "remWord32X8#": "Word32X8# -> Word32X8# -> Word32X8#", "remWord64X4#": "Word64X4# -> Word64X4# -> Word64X4#", "remWord8X64#": "Word8X64# -> Word8X64# -> Word8X64#", "remWord16X32#": "Word16X32# -> Word16X32# -> Word16X32#", "remWord32X16#": "Word32X16# -> Word32X16# -> Word32X16#", "remWord64X8#": "Word64X8# -> Word64X8# -> Word64X8#", "negateInt8X16#": "Int8X16# -> Int8X16#", "negateInt16X8#": "Int16X8# -> Int16X8#", "negateInt32X4#": "Int32X4# -> Int32X4#", "negateInt64X2#": "Int64X2# -> Int64X2#", "negateInt8X32#": "Int8X32# -> Int8X32#", "negateInt16X16#": "Int16X16# -> Int16X16#", "negateInt32X8#": "Int32X8# -> Int32X8#", "negateInt64X4#": "Int64X4# -> Int64X4#", "negateInt8X64#": "Int8X64# -> Int8X64#", "negateInt16X32#": "Int16X32# -> Int16X32#", "negateInt32X16#": "Int32X16# -> Int32X16#", "negateInt64X8#": "Int64X8# -> Int64X8#", "negateFloatX4#": "FloatX4# -> FloatX4#", "negateDoubleX2#": "DoubleX2# -> DoubleX2#", "negateFloatX8#": "FloatX8# -> FloatX8#", "negateDoubleX4#": "DoubleX4# -> DoubleX4#", "negateFloatX16#": "FloatX16# -> FloatX16#", "negateDoubleX8#": "DoubleX8# -> DoubleX8#", "indexInt8X16Array#": "ByteArray# -> Int# -> Int8X16#", "indexInt16X8Array#": "ByteArray# -> Int# -> Int16X8#", "indexInt32X4Array#": "ByteArray# -> Int# -> Int32X4#", "indexInt64X2Array#": "ByteArray# -> Int# -> Int64X2#", "indexInt8X32Array#": "ByteArray# -> Int# -> Int8X32#", "indexInt16X16Array#": "ByteArray# -> Int# -> Int16X16#", "indexInt32X8Array#": "ByteArray# -> Int# -> Int32X8#", "indexInt64X4Array#": "ByteArray# -> Int# -> Int64X4#", "indexInt8X64Array#": "ByteArray# -> Int# -> Int8X64#", "indexInt16X32Array#": "ByteArray# -> Int# -> Int16X32#", "indexInt32X16Array#": "ByteArray# -> Int# -> Int32X16#", "indexInt64X8Array#": "ByteArray# -> Int# -> Int64X8#", "indexWord8X16Array#": "ByteArray# -> Int# -> Word8X16#", "indexWord16X8Array#": "ByteArray# -> Int# -> Word16X8#", "indexWord32X4Array#": "ByteArray# -> Int# -> Word32X4#", "indexWord64X2Array#": "ByteArray# -> Int# -> Word64X2#", "indexWord8X32Array#": "ByteArray# -> Int# -> Word8X32#", "indexWord16X16Array#": "ByteArray# -> Int# -> Word16X16#", "indexWord32X8Array#": "ByteArray# -> Int# -> Word32X8#", "indexWord64X4Array#": "ByteArray# -> Int# -> Word64X4#", "indexWord8X64Array#": "ByteArray# -> Int# -> Word8X64#", "indexWord16X32Array#": "ByteArray# -> Int# -> Word16X32#", "indexWord32X16Array#": "ByteArray# -> Int# -> Word32X16#", "indexWord64X8Array#": "ByteArray# -> Int# -> Word64X8#", "indexFloatX4Array#": "ByteArray# -> Int# -> FloatX4#", "indexDoubleX2Array#": "ByteArray# -> Int# -> DoubleX2#", "indexFloatX8Array#": "ByteArray# -> Int# -> FloatX8#", "indexDoubleX4Array#": "ByteArray# -> Int# -> DoubleX4#", "indexFloatX16Array#": "ByteArray# -> Int# -> FloatX16#", "indexDoubleX8Array#": "ByteArray# -> Int# -> DoubleX8#", "readInt8X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)", "readInt16X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)", "readInt32X4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)", "readInt64X2Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)", "readInt8X32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)", "readInt16X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)", "readInt32X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)", "readInt64X4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)", "readInt8X64Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)", "readInt16X32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)", "readInt32X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)", "readInt64X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)", "readWord8X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)", "readWord16X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)", "readWord32X4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)", "readWord64X2Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)", "readWord8X32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)", "readWord16X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)", "readWord32X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)", "readWord64X4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)", "readWord8X64Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)", "readWord16X32Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)", "readWord32X16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)", "readWord64X8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)", "readFloatX4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)", "readDoubleX2Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)", "readFloatX8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)", "readDoubleX4Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)", "readFloatX16Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)", "readDoubleX8Array#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)", "writeInt8X16Array#": "MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d", "writeInt16X8Array#": "MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d", "writeInt32X4Array#": "MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d", "writeInt64X2Array#": "MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d", "writeInt8X32Array#": "MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d", "writeInt16X16Array#": "MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d", "writeInt32X8Array#": "MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d", "writeInt64X4Array#": "MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d", "writeInt8X64Array#": "MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d", "writeInt16X32Array#": "MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d", "writeInt32X16Array#": "MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d", "writeInt64X8Array#": "MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d", "writeWord8X16Array#": "MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d", "writeWord16X8Array#": "MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d", "writeWord32X4Array#": "MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d", "writeWord64X2Array#": "MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d", "writeWord8X32Array#": "MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d", "writeWord16X16Array#": "MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d", "writeWord32X8Array#": "MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d", "writeWord64X4Array#": "MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d", "writeWord8X64Array#": "MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d", "writeWord16X32Array#": "MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d", "writeWord32X16Array#": "MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d", "writeWord64X8Array#": "MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d", "writeFloatX4Array#": "MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d", "writeDoubleX2Array#": "MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d", "writeFloatX8Array#": "MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d", "writeDoubleX4Array#": "MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d", "writeFloatX16Array#": "MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d", "writeDoubleX8Array#": "MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d", "indexInt8X16OffAddr#": "Addr# -> Int# -> Int8X16#", "indexInt16X8OffAddr#": "Addr# -> Int# -> Int16X8#", "indexInt32X4OffAddr#": "Addr# -> Int# -> Int32X4#", "indexInt64X2OffAddr#": "Addr# -> Int# -> Int64X2#", "indexInt8X32OffAddr#": "Addr# -> Int# -> Int8X32#", "indexInt16X16OffAddr#": "Addr# -> Int# -> Int16X16#", "indexInt32X8OffAddr#": "Addr# -> Int# -> Int32X8#", "indexInt64X4OffAddr#": "Addr# -> Int# -> Int64X4#", "indexInt8X64OffAddr#": "Addr# -> Int# -> Int8X64#", "indexInt16X32OffAddr#": "Addr# -> Int# -> Int16X32#", "indexInt32X16OffAddr#": "Addr# -> Int# -> Int32X16#", "indexInt64X8OffAddr#": "Addr# -> Int# -> Int64X8#", "indexWord8X16OffAddr#": "Addr# -> Int# -> Word8X16#", "indexWord16X8OffAddr#": "Addr# -> Int# -> Word16X8#", "indexWord32X4OffAddr#": "Addr# -> Int# -> Word32X4#", "indexWord64X2OffAddr#": "Addr# -> Int# -> Word64X2#", "indexWord8X32OffAddr#": "Addr# -> Int# -> Word8X32#", "indexWord16X16OffAddr#": "Addr# -> Int# -> Word16X16#", "indexWord32X8OffAddr#": "Addr# -> Int# -> Word32X8#", "indexWord64X4OffAddr#": "Addr# -> Int# -> Word64X4#", "indexWord8X64OffAddr#": "Addr# -> Int# -> Word8X64#", "indexWord16X32OffAddr#": "Addr# -> Int# -> Word16X32#", "indexWord32X16OffAddr#": "Addr# -> Int# -> Word32X16#", "indexWord64X8OffAddr#": "Addr# -> Int# -> Word64X8#", "indexFloatX4OffAddr#": "Addr# -> Int# -> FloatX4#", "indexDoubleX2OffAddr#": "Addr# -> Int# -> DoubleX2#", "indexFloatX8OffAddr#": "Addr# -> Int# -> FloatX8#", "indexDoubleX4OffAddr#": "Addr# -> Int# -> DoubleX4#", "indexFloatX16OffAddr#": "Addr# -> Int# -> FloatX16#", "indexDoubleX8OffAddr#": "Addr# -> Int# -> DoubleX8#", "readInt8X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)", "readInt16X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)", "readInt32X4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)", "readInt64X2OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)", "readInt8X32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)", "readInt16X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)", "readInt32X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)", "readInt64X4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)", "readInt8X64OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)", "readInt16X32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)", "readInt32X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)", "readInt64X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)", "readWord8X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)", "readWord16X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)", "readWord32X4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)", "readWord64X2OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)", "readWord8X32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)", "readWord16X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)", "readWord32X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)", "readWord64X4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)", "readWord8X64OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)", "readWord16X32OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)", "readWord32X16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)", "readWord64X8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)", "readFloatX4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)", "readDoubleX2OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)", "readFloatX8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)", "readDoubleX4OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)", "readFloatX16OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)", "readDoubleX8OffAddr#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)", "writeInt8X16OffAddr#": "Addr# -> Int# -> Int8X16# -> State# d -> State# d", "writeInt16X8OffAddr#": "Addr# -> Int# -> Int16X8# -> State# d -> State# d", "writeInt32X4OffAddr#": "Addr# -> Int# -> Int32X4# -> State# d -> State# d", "writeInt64X2OffAddr#": "Addr# -> Int# -> Int64X2# -> State# d -> State# d", "writeInt8X32OffAddr#": "Addr# -> Int# -> Int8X32# -> State# d -> State# d", "writeInt16X16OffAddr#": "Addr# -> Int# -> Int16X16# -> State# d -> State# d", "writeInt32X8OffAddr#": "Addr# -> Int# -> Int32X8# -> State# d -> State# d", "writeInt64X4OffAddr#": "Addr# -> Int# -> Int64X4# -> State# d -> State# d", "writeInt8X64OffAddr#": "Addr# -> Int# -> Int8X64# -> State# d -> State# d", "writeInt16X32OffAddr#": "Addr# -> Int# -> Int16X32# -> State# d -> State# d", "writeInt32X16OffAddr#": "Addr# -> Int# -> Int32X16# -> State# d -> State# d", "writeInt64X8OffAddr#": "Addr# -> Int# -> Int64X8# -> State# d -> State# d", "writeWord8X16OffAddr#": "Addr# -> Int# -> Word8X16# -> State# d -> State# d", "writeWord16X8OffAddr#": "Addr# -> Int# -> Word16X8# -> State# d -> State# d", "writeWord32X4OffAddr#": "Addr# -> Int# -> Word32X4# -> State# d -> State# d", "writeWord64X2OffAddr#": "Addr# -> Int# -> Word64X2# -> State# d -> State# d", "writeWord8X32OffAddr#": "Addr# -> Int# -> Word8X32# -> State# d -> State# d", "writeWord16X16OffAddr#": "Addr# -> Int# -> Word16X16# -> State# d -> State# d", "writeWord32X8OffAddr#": "Addr# -> Int# -> Word32X8# -> State# d -> State# d", "writeWord64X4OffAddr#": "Addr# -> Int# -> Word64X4# -> State# d -> State# d", "writeWord8X64OffAddr#": "Addr# -> Int# -> Word8X64# -> State# d -> State# d", "writeWord16X32OffAddr#": "Addr# -> Int# -> Word16X32# -> State# d -> State# d", "writeWord32X16OffAddr#": "Addr# -> Int# -> Word32X16# -> State# d -> State# d", "writeWord64X8OffAddr#": "Addr# -> Int# -> Word64X8# -> State# d -> State# d", "writeFloatX4OffAddr#": "Addr# -> Int# -> FloatX4# -> State# d -> State# d", "writeDoubleX2OffAddr#": "Addr# -> Int# -> DoubleX2# -> State# d -> State# d", "writeFloatX8OffAddr#": "Addr# -> Int# -> FloatX8# -> State# d -> State# d", "writeDoubleX4OffAddr#": "Addr# -> Int# -> DoubleX4# -> State# d -> State# d", "writeFloatX16OffAddr#": "Addr# -> Int# -> FloatX16# -> State# d -> State# d", "writeDoubleX8OffAddr#": "Addr# -> Int# -> DoubleX8# -> State# d -> State# d", "indexInt8ArrayAsInt8X16#": "ByteArray# -> Int# -> Int8X16#", "indexInt16ArrayAsInt16X8#": "ByteArray# -> Int# -> Int16X8#", "indexInt32ArrayAsInt32X4#": "ByteArray# -> Int# -> Int32X4#", "indexInt64ArrayAsInt64X2#": "ByteArray# -> Int# -> Int64X2#", "indexInt8ArrayAsInt8X32#": "ByteArray# -> Int# -> Int8X32#", "indexInt16ArrayAsInt16X16#": "ByteArray# -> Int# -> Int16X16#", "indexInt32ArrayAsInt32X8#": "ByteArray# -> Int# -> Int32X8#", "indexInt64ArrayAsInt64X4#": "ByteArray# -> Int# -> Int64X4#", "indexInt8ArrayAsInt8X64#": "ByteArray# -> Int# -> Int8X64#", "indexInt16ArrayAsInt16X32#": "ByteArray# -> Int# -> Int16X32#", "indexInt32ArrayAsInt32X16#": "ByteArray# -> Int# -> Int32X16#", "indexInt64ArrayAsInt64X8#": "ByteArray# -> Int# -> Int64X8#", "indexWord8ArrayAsWord8X16#": "ByteArray# -> Int# -> Word8X16#", "indexWord16ArrayAsWord16X8#": "ByteArray# -> Int# -> Word16X8#", "indexWord32ArrayAsWord32X4#": "ByteArray# -> Int# -> Word32X4#", "indexWord64ArrayAsWord64X2#": "ByteArray# -> Int# -> Word64X2#", "indexWord8ArrayAsWord8X32#": "ByteArray# -> Int# -> Word8X32#", "indexWord16ArrayAsWord16X16#": "ByteArray# -> Int# -> Word16X16#", "indexWord32ArrayAsWord32X8#": "ByteArray# -> Int# -> Word32X8#", "indexWord64ArrayAsWord64X4#": "ByteArray# -> Int# -> Word64X4#", "indexWord8ArrayAsWord8X64#": "ByteArray# -> Int# -> Word8X64#", "indexWord16ArrayAsWord16X32#": "ByteArray# -> Int# -> Word16X32#", "indexWord32ArrayAsWord32X16#": "ByteArray# -> Int# -> Word32X16#", "indexWord64ArrayAsWord64X8#": "ByteArray# -> Int# -> Word64X8#", "indexFloatArrayAsFloatX4#": "ByteArray# -> Int# -> FloatX4#", "indexDoubleArrayAsDoubleX2#": "ByteArray# -> Int# -> DoubleX2#", "indexFloatArrayAsFloatX8#": "ByteArray# -> Int# -> FloatX8#", "indexDoubleArrayAsDoubleX4#": "ByteArray# -> Int# -> DoubleX4#", "indexFloatArrayAsFloatX16#": "ByteArray# -> Int# -> FloatX16#", "indexDoubleArrayAsDoubleX8#": "ByteArray# -> Int# -> DoubleX8#", "readInt8ArrayAsInt8X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)", "readInt16ArrayAsInt16X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)", "readInt32ArrayAsInt32X4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)", "readInt64ArrayAsInt64X2#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)", "readInt8ArrayAsInt8X32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)", "readInt16ArrayAsInt16X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)", "readInt32ArrayAsInt32X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)", "readInt64ArrayAsInt64X4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)", "readInt8ArrayAsInt8X64#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)", "readInt16ArrayAsInt16X32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)", "readInt32ArrayAsInt32X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)", "readInt64ArrayAsInt64X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)", "readWord8ArrayAsWord8X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)", "readWord16ArrayAsWord16X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)", "readWord32ArrayAsWord32X4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)", "readWord64ArrayAsWord64X2#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)", "readWord8ArrayAsWord8X32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)", "readWord16ArrayAsWord16X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)", "readWord32ArrayAsWord32X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)", "readWord64ArrayAsWord64X4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)", "readWord8ArrayAsWord8X64#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)", "readWord16ArrayAsWord16X32#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)", "readWord32ArrayAsWord32X16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)", "readWord64ArrayAsWord64X8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)", "readFloatArrayAsFloatX4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)", "readDoubleArrayAsDoubleX2#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)", "readFloatArrayAsFloatX8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)", "readDoubleArrayAsDoubleX4#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)", "readFloatArrayAsFloatX16#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)", "readDoubleArrayAsDoubleX8#": "MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)", "writeInt8ArrayAsInt8X16#": "MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d", "writeInt16ArrayAsInt16X8#": "MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d", "writeInt32ArrayAsInt32X4#": "MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d", "writeInt64ArrayAsInt64X2#": "MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d", "writeInt8ArrayAsInt8X32#": "MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d", "writeInt16ArrayAsInt16X16#": "MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d", "writeInt32ArrayAsInt32X8#": "MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d", "writeInt64ArrayAsInt64X4#": "MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d", "writeInt8ArrayAsInt8X64#": "MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d", "writeInt16ArrayAsInt16X32#": "MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d", "writeInt32ArrayAsInt32X16#": "MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d", "writeInt64ArrayAsInt64X8#": "MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d", "writeWord8ArrayAsWord8X16#": "MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d", "writeWord16ArrayAsWord16X8#": "MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d", "writeWord32ArrayAsWord32X4#": "MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d", "writeWord64ArrayAsWord64X2#": "MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d", "writeWord8ArrayAsWord8X32#": "MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d", "writeWord16ArrayAsWord16X16#": "MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d", "writeWord32ArrayAsWord32X8#": "MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d", "writeWord64ArrayAsWord64X4#": "MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d", "writeWord8ArrayAsWord8X64#": "MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d", "writeWord16ArrayAsWord16X32#": "MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d", "writeWord32ArrayAsWord32X16#": "MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d", "writeWord64ArrayAsWord64X8#": "MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d", "writeFloatArrayAsFloatX4#": "MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d", "writeDoubleArrayAsDoubleX2#": "MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d", "writeFloatArrayAsFloatX8#": "MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d", "writeDoubleArrayAsDoubleX4#": "MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d", "writeFloatArrayAsFloatX16#": "MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d", "writeDoubleArrayAsDoubleX8#": "MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d", "indexInt8OffAddrAsInt8X16#": "Addr# -> Int# -> Int8X16#", "indexInt16OffAddrAsInt16X8#": "Addr# -> Int# -> Int16X8#", "indexInt32OffAddrAsInt32X4#": "Addr# -> Int# -> Int32X4#", "indexInt64OffAddrAsInt64X2#": "Addr# -> Int# -> Int64X2#", "indexInt8OffAddrAsInt8X32#": "Addr# -> Int# -> Int8X32#", "indexInt16OffAddrAsInt16X16#": "Addr# -> Int# -> Int16X16#", "indexInt32OffAddrAsInt32X8#": "Addr# -> Int# -> Int32X8#", "indexInt64OffAddrAsInt64X4#": "Addr# -> Int# -> Int64X4#", "indexInt8OffAddrAsInt8X64#": "Addr# -> Int# -> Int8X64#", "indexInt16OffAddrAsInt16X32#": "Addr# -> Int# -> Int16X32#", "indexInt32OffAddrAsInt32X16#": "Addr# -> Int# -> Int32X16#", "indexInt64OffAddrAsInt64X8#": "Addr# -> Int# -> Int64X8#", "indexWord8OffAddrAsWord8X16#": "Addr# -> Int# -> Word8X16#", "indexWord16OffAddrAsWord16X8#": "Addr# -> Int# -> Word16X8#", "indexWord32OffAddrAsWord32X4#": "Addr# -> Int# -> Word32X4#", "indexWord64OffAddrAsWord64X2#": "Addr# -> Int# -> Word64X2#", "indexWord8OffAddrAsWord8X32#": "Addr# -> Int# -> Word8X32#", "indexWord16OffAddrAsWord16X16#": "Addr# -> Int# -> Word16X16#", "indexWord32OffAddrAsWord32X8#": "Addr# -> Int# -> Word32X8#", "indexWord64OffAddrAsWord64X4#": "Addr# -> Int# -> Word64X4#", "indexWord8OffAddrAsWord8X64#": "Addr# -> Int# -> Word8X64#", "indexWord16OffAddrAsWord16X32#": "Addr# -> Int# -> Word16X32#", "indexWord32OffAddrAsWord32X16#": "Addr# -> Int# -> Word32X16#", "indexWord64OffAddrAsWord64X8#": "Addr# -> Int# -> Word64X8#", "indexFloatOffAddrAsFloatX4#": "Addr# -> Int# -> FloatX4#", "indexDoubleOffAddrAsDoubleX2#": "Addr# -> Int# -> DoubleX2#", "indexFloatOffAddrAsFloatX8#": "Addr# -> Int# -> FloatX8#", "indexDoubleOffAddrAsDoubleX4#": "Addr# -> Int# -> DoubleX4#", "indexFloatOffAddrAsFloatX16#": "Addr# -> Int# -> FloatX16#", "indexDoubleOffAddrAsDoubleX8#": "Addr# -> Int# -> DoubleX8#", "readInt8OffAddrAsInt8X16#": "Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)", "readInt16OffAddrAsInt16X8#": "Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)", "readInt32OffAddrAsInt32X4#": "Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)", "readInt64OffAddrAsInt64X2#": "Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)", "readInt8OffAddrAsInt8X32#": "Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)", "readInt16OffAddrAsInt16X16#": "Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)", "readInt32OffAddrAsInt32X8#": "Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)", "readInt64OffAddrAsInt64X4#": "Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)", "readInt8OffAddrAsInt8X64#": "Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)", "readInt16OffAddrAsInt16X32#": "Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)", "readInt32OffAddrAsInt32X16#": "Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)", "readInt64OffAddrAsInt64X8#": "Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)", "readWord8OffAddrAsWord8X16#": "Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)", "readWord16OffAddrAsWord16X8#": "Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)", "readWord32OffAddrAsWord32X4#": "Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)", "readWord64OffAddrAsWord64X2#": "Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)", "readWord8OffAddrAsWord8X32#": "Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)", "readWord16OffAddrAsWord16X16#": "Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)", "readWord32OffAddrAsWord32X8#": "Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)", "readWord64OffAddrAsWord64X4#": "Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)", "readWord8OffAddrAsWord8X64#": "Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)", "readWord16OffAddrAsWord16X32#": "Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)", "readWord32OffAddrAsWord32X16#": "Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)", "readWord64OffAddrAsWord64X8#": "Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)", "readFloatOffAddrAsFloatX4#": "Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)", "readDoubleOffAddrAsDoubleX2#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)", "readFloatOffAddrAsFloatX8#": "Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)", "readDoubleOffAddrAsDoubleX4#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)", "readFloatOffAddrAsFloatX16#": "Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)", "readDoubleOffAddrAsDoubleX8#": "Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)", "writeInt8OffAddrAsInt8X16#": "Addr# -> Int# -> Int8X16# -> State# d -> State# d", "writeInt16OffAddrAsInt16X8#": "Addr# -> Int# -> Int16X8# -> State# d -> State# d", "writeInt32OffAddrAsInt32X4#": "Addr# -> Int# -> Int32X4# -> State# d -> State# d", "writeInt64OffAddrAsInt64X2#": "Addr# -> Int# -> Int64X2# -> State# d -> State# d", "writeInt8OffAddrAsInt8X32#": "Addr# -> Int# -> Int8X32# -> State# d -> State# d", "writeInt16OffAddrAsInt16X16#": "Addr# -> Int# -> Int16X16# -> State# d -> State# d", "writeInt32OffAddrAsInt32X8#": "Addr# -> Int# -> Int32X8# -> State# d -> State# d", "writeInt64OffAddrAsInt64X4#": "Addr# -> Int# -> Int64X4# -> State# d -> State# d", "writeInt8OffAddrAsInt8X64#": "Addr# -> Int# -> Int8X64# -> State# d -> State# d", "writeInt16OffAddrAsInt16X32#": "Addr# -> Int# -> Int16X32# -> State# d -> State# d", "writeInt32OffAddrAsInt32X16#": "Addr# -> Int# -> Int32X16# -> State# d -> State# d", "writeInt64OffAddrAsInt64X8#": "Addr# -> Int# -> Int64X8# -> State# d -> State# d", "writeWord8OffAddrAsWord8X16#": "Addr# -> Int# -> Word8X16# -> State# d -> State# d", "writeWord16OffAddrAsWord16X8#": "Addr# -> Int# -> Word16X8# -> State# d -> State# d", "writeWord32OffAddrAsWord32X4#": "Addr# -> Int# -> Word32X4# -> State# d -> State# d", "writeWord64OffAddrAsWord64X2#": "Addr# -> Int# -> Word64X2# -> State# d -> State# d", "writeWord8OffAddrAsWord8X32#": "Addr# -> Int# -> Word8X32# -> State# d -> State# d", "writeWord16OffAddrAsWord16X16#": "Addr# -> Int# -> Word16X16# -> State# d -> State# d", "writeWord32OffAddrAsWord32X8#": "Addr# -> Int# -> Word32X8# -> State# d -> State# d", "writeWord64OffAddrAsWord64X4#": "Addr# -> Int# -> Word64X4# -> State# d -> State# d", "writeWord8OffAddrAsWord8X64#": "Addr# -> Int# -> Word8X64# -> State# d -> State# d", "writeWord16OffAddrAsWord16X32#": "Addr# -> Int# -> Word16X32# -> State# d -> State# d", "writeWord32OffAddrAsWord32X16#": "Addr# -> Int# -> Word32X16# -> State# d -> State# d", "writeWord64OffAddrAsWord64X8#": "Addr# -> Int# -> Word64X8# -> State# d -> State# d", "writeFloatOffAddrAsFloatX4#": "Addr# -> Int# -> FloatX4# -> State# d -> State# d", "writeDoubleOffAddrAsDoubleX2#": "Addr# -> Int# -> DoubleX2# -> State# d -> State# d", "writeFloatOffAddrAsFloatX8#": "Addr# -> Int# -> FloatX8# -> State# d -> State# d", "writeDoubleOffAddrAsDoubleX4#": "Addr# -> Int# -> DoubleX4# -> State# d -> State# d", "writeFloatOffAddrAsFloatX16#": "Addr# -> Int# -> FloatX16# -> State# d -> State# d", "writeDoubleOffAddrAsDoubleX8#": "Addr# -> Int# -> DoubleX8# -> State# d -> State# d", "prefetchByteArray3#": "ByteArray# -> Int# -> State# d -> State# d", "prefetchMutableByteArray3#": "MutableByteArray# d -> Int# -> State# d -> State# d", "prefetchAddr3#": "Addr# -> Int# -> State# d -> State# d", "prefetchValue3#": "a -> State# d -> State# d", "prefetchByteArray2#": "ByteArray# -> Int# -> State# d -> State# d", "prefetchMutableByteArray2#": "MutableByteArray# d -> Int# -> State# d -> State# d", "prefetchAddr2#": "Addr# -> Int# -> State# d -> State# d", "prefetchValue2#": "a -> State# d -> State# d", "prefetchByteArray1#": "ByteArray# -> Int# -> State# d -> State# d", "prefetchMutableByteArray1#": "MutableByteArray# d -> Int# -> State# d -> State# d", "prefetchAddr1#": "Addr# -> Int# -> State# d -> State# d", "prefetchValue1#": "a -> State# d -> State# d", "prefetchByteArray0#": "ByteArray# -> Int# -> State# d -> State# d", "prefetchMutableByteArray0#": "MutableByteArray# d -> Int# -> State# d -> State# d", "prefetchAddr0#": "Addr# -> Int# -> State# d -> State# d", "prefetchValue0#": "a -> State# d -> State# d", "module": "GHC.Prim.Ext", "shiftL#": "Word# -> Int# -> Word#", "shiftRL#": "Word# -> Int# -> Word#", "iShiftL#": "Int# -> Int# -> Int#", "iShiftRA#": "Int# -> Int# -> Int#", "iShiftRL#": "Int# -> Int# -> Int#", "uncheckedShiftL64#": "Word# -> Int# -> Word#", "uncheckedShiftRL64#": "Word# -> Int# -> Word#", "uncheckedIShiftL64#": "Int# -> Int# -> Int#", "uncheckedIShiftRA64#": "Int# -> Int# -> Int#", "isTrue#": "Int# -> Bool", "atomicModifyMutVar#": "MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)", "resizeSmallMutableArray#": "", "IsString": "", "fromString": "String -> a", "unpackCString#": "Addr# -> [Char]", "unpackAppendCString#": "Addr# -> [Char] -> [Char]", "unpackFoldrCString#": "Addr# -> (Char -> a -> a) -> a -> a", "unpackCStringUtf8#": "Addr# -> [Char]", "unpackNBytes#": "Addr# -> Int# -> [Char]", "cstringLength#": "Addr# -> Int#", "breakpoint": "a -> a", "breakpointCond": "Bool -> a -> a", "inline": "a -> a", "noinline": "a -> a", "lazy": "a -> a", "SPEC": "", "SPEC2": "", "a": "", "TYPE": "", "RuntimeRep": "", "VecRep": "VecCount VecElem", "TupleRep": "[RuntimeRep]", "SumRep": "[RuntimeRep]", "LiftedRep": "", "UnliftedRep": "", "IntRep": "", "Int8Rep": "", "Int16Rep": "", "Int32Rep": "", "Int64Rep": "", "WordRep": "", "Word8Rep": "", "Word16Rep": "", "Word32Rep": "", "Word64Rep": "", "AddrRep": "", "FloatRep": "", "DoubleRep": "", "showsPrec": "Int -> RuntimeRep -> ShowS", "show": "RuntimeRep -> String", "showList": "[RuntimeRep] -> ShowS", "VecCount": "", "Vec2": "", "Vec4": "", "Vec8": "", "Vec16": "", "Vec32": "", "Vec64": "", "VecElem": "", "Int8ElemRep": "", "Int16ElemRep": "", "Int32ElemRep": "", "Int64ElemRep": "", "Word8ElemRep": "", "Word16ElemRep": "", "Word32ElemRep": "", "Word64ElemRep": "", "FloatElemRep": "", "DoubleElemRep": "", "Down": "", "getDown": "a", ">>=": "Down a -> (a -> Down b) -> Down b", ">>": "Down a -> Down b -> Down b", "return": "a -> Down a", "groupWith": "Ord b => (a -> b) -> [a] -> [[a]]", "sortWith": "Ord b => (a -> b) -> [a] -> [a]", "the": "Eq a => [a] -> a", "traceEvent": "String -> IO ()", "SpecConstrAnnotation": "", "NoSpecConstr": "", "ForceSpecConstr": "", "currentCallStack": "IO [String]", "Constraint": "", "family": "", "IsList": "", "fromList": "[Item l] -> l", "fromListN": "Int -> [Item l] -> l", "toList": "l -> [Item l]"}, "GHC.Fingerprint": {"Fingerprint": "", "==": "Fingerprint -> Fingerprint -> Bool", "/=": "Fingerprint -> Fingerprint -> Bool", "fingerprint0": "Fingerprint", "fingerprintData": "Ptr Word8 -> Int -> IO Fingerprint", "fingerprintString": "String -> Fingerprint", "fingerprintFingerprints": "[Fingerprint] -> Fingerprint", "getFileHash": "FilePath -> IO Fingerprint"}, "GHC.Fingerprint.Type": {"Fingerprint": "", "==": "Fingerprint -> Fingerprint -> Bool", "/=": "Fingerprint -> Fingerprint -> Bool"}, "GHC.Float": {"rationalToFloat": "Integer -> Integer -> Float", "rationalToDouble": "Integer -> Integer -> Double", "Fractional": "", "pi": "a", "exp": "a -> a", "log": "a -> a", "sqrt": "a -> a", "**": "a -> a -> a infixr 8", "logBase": "a -> a -> a", "sin": "a -> a", "cos": "a -> a", "tan": "a -> a", "asin": "a -> a", "acos": "a -> a", "atan": "a -> a", "sinh": "a -> a", "cosh": "a -> a", "tanh": "a -> a", "asinh": "a -> a", "acosh": "a -> a", "atanh": "a -> a", "log1p": "a -> a", "expm1": "a -> a", "log1pexp": "a -> a", "log1mexp": "a -> a", "RealFrac": "", "floatRadix": "a -> Integer", "floatDigits": "a -> Int", "floatRange": "a -> (Int, Int)", "decodeFloat": "a -> (Integer, Int)", "encodeFloat": "Integer -> Int -> a", "exponent": "a -> Int", "significand": "a -> a", "scaleFloat": "Int -> a -> a", "isNaN": "a -> Bool", "isInfinite": "a -> Bool", "isDenormalized": "a -> Bool", "isNegativeZero": "a -> Bool", "isIEEE": "a -> Bool", "atan2": "a -> a -> a", "FFFormat": "", "FFExponent": "", "FFFixed": "", "FFGeneric": "", "stgDoubleToWord64": "Double# -> Word#", "stgWord64ToDouble": "Word# -> Double#", "stgFloatToWord32": "Float# -> Word#", "stgWord32ToFloat": "Word# -> Float#", "isDoubleFinite": "Double -> Int", "isDoubleNegativeZero": "Double -> Int", "isDoubleDenormalized": "Double -> Int", "isDoubleInfinite": "Double -> Int", "isDoubleNaN": "Double -> Int", "isFloatFinite": "Float -> Int", "isFloatNegativeZero": "Float -> Int", "isFloatDenormalized": "Float -> Int", "isFloatInfinite": "Float -> Int", "isFloatNaN": "Float -> Int", "log1mexpOrd": "(Ord a, Floating a) => a -> a", "showFloat": "RealFloat a => a -> ShowS", "formatRealFloat": "RealFloat a => FFFormat -> Maybe Int -> a -> String", "formatRealFloatAlt": "RealFloat a => FFFormat -> Maybe Int -> Bool -> a -> String", "roundTo": "Int -> Int -> [Int] -> (Int, [Int])", "floatToDigits": "RealFloat a => Integer -> a -> ([Int], Int)", "fromRat": "RealFloat a => Rational -> a", "fromRat'": "RealFloat a => Rational -> a", "minExpt": "Int", "maxExpt": "Int", "expt": "Integer -> Int -> Integer", "expts": "Array Int Integer", "maxExpt10": "Int", "expts10": "Array Int Integer", "fromRat''": "RealFloat a => Int -> Int -> Integer -> Integer -> a", "roundingMode#": "Integer -> Int# -> Int#", "plusFloat": "Float -> Float -> Float", "minusFloat": "Float -> Float -> Float", "timesFloat": "Float -> Float -> Float", "divideFloat": "Float -> Float -> Float", "negateFloat": "Float -> Float", "gtFloat": "Float -> Float -> Bool", "geFloat": "Float -> Float -> Bool", "ltFloat": "Float -> Float -> Bool", "leFloat": "Float -> Float -> Bool", "expFloat": "Float -> Float", "expm1Float": "Float -> Float", "logFloat": "Float -> Float", "log1pFloat": "Float -> Float", "sqrtFloat": "Float -> Float", "fabsFloat": "Float -> Float", "sinFloat": "Float -> Float", "cosFloat": "Float -> Float", "tanFloat": "Float -> Float", "asinFloat": "Float -> Float", "acosFloat": "Float -> Float", "atanFloat": "Float -> Float", "sinhFloat": "Float -> Float", "coshFloat": "Float -> Float", "tanhFloat": "Float -> Float", "asinhFloat": "Float -> Float", "acoshFloat": "Float -> Float", "atanhFloat": "Float -> Float", "powerFloat": "Float -> Float -> Float", "plusDouble": "Double -> Double -> Double", "minusDouble": "Double -> Double -> Double", "timesDouble": "Double -> Double -> Double", "divideDouble": "Double -> Double -> Double", "negateDouble": "Double -> Double", "gtDouble": "Double -> Double -> Bool", "geDouble": "Double -> Double -> Bool", "ltDouble": "Double -> Double -> Bool", "leDouble": "Double -> Double -> Bool", "double2Float": "Double -> Float", "float2Double": "Float -> Double", "expDouble": "Double -> Double", "expm1Double": "Double -> Double", "logDouble": "Double -> Double", "log1pDouble": "Double -> Double", "sqrtDouble": "Double -> Double", "fabsDouble": "Double -> Double", "sinDouble": "Double -> Double", "cosDouble": "Double -> Double", "tanDouble": "Double -> Double", "asinDouble": "Double -> Double", "acosDouble": "Double -> Double", "atanDouble": "Double -> Double", "sinhDouble": "Double -> Double", "coshDouble": "Double -> Double", "tanhDouble": "Double -> Double", "asinhDouble": "Double -> Double", "acoshDouble": "Double -> Double", "atanhDouble": "Double -> Double", "powerDouble": "Double -> Double -> Double", "word2Double": "Word -> Double", "word2Float": "Word -> Float", "showSignedFloat": "", "clamp": "Int -> Int -> Int", "castWord32ToFloat": "Word32 -> Float", "castFloatToWord32": "Float -> Word32", "castWord64ToDouble": "Word64 -> Double", "castDoubleToWord64": "Double -> Word64", "Float": "", "F#": "Float#", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "Double": "", "D#": "Double#", "Float#": "", "Double#": "", "double2Int": "Double -> Int", "int2Double": "Int -> Double", "float2Int": "Float -> Int", "int2Float": "Int -> Float", "eqFloat": "Float -> Float -> Bool", "eqDouble": "Double -> Double -> Bool"}, "GHC.Float.ConversionUtils": {"elimZerosInteger": "Integer -> Int# -> (# Integer, Int# #)", "elimZerosInt#": "Int# -> Int# -> (# Integer, Int# #)"}, "GHC.Float.RealFracMethods": {"properFractionDoubleInteger": "Double -> (Integer, Double)", "truncateDoubleInteger": "Double -> Integer", "floorDoubleInteger": "Double -> Integer", "ceilingDoubleInteger": "Double -> Integer", "roundDoubleInteger": "Double -> Integer", "properFractionDoubleInt": "Double -> (Int, Double)", "floorDoubleInt": "Double -> Int", "ceilingDoubleInt": "Double -> Int", "roundDoubleInt": "Double -> Int", "double2Int": "Double -> Int", "int2Double": "Int -> Double", "properFractionFloatInteger": "Float -> (Integer, Float)", "truncateFloatInteger": "Float -> Integer", "floorFloatInteger": "Float -> Integer", "ceilingFloatInteger": "Float -> Integer", "roundFloatInteger": "Float -> Integer", "properFractionFloatInt": "Float -> (Int, Float)", "floorFloatInt": "Float -> Int", "ceilingFloatInt": "Float -> Int", "roundFloatInt": "Float -> Int", "float2Int": "Float -> Int", "int2Float": "Int -> Float"}, "GHC.Foreign": {"peekCString": "TextEncoding -> CString -> IO String", "peekCStringLen": "TextEncoding -> CStringLen -> IO String", "newCString": "TextEncoding -> String -> IO CString", "newCStringLen": "TextEncoding -> String -> IO CStringLen", "withCString": "TextEncoding -> String -> (CString -> IO a) -> IO a", "withCStringLen": "TextEncoding -> String -> (CStringLen -> IO a) -> IO a", "withCStringsLen": "TextEncoding -> [String] -> (Int -> Ptr CString -> IO a) -> IO a", "charIsRepresentable": "TextEncoding -> Char -> IO Bool"}, "GHC.ForeignPtr": {"ForeignPtr": "", "==": "ForeignPtr a -> ForeignPtr a -> Bool", "/=": "ForeignPtr a -> ForeignPtr a -> Bool", "ForeignPtrContents": "", "PlainForeignPtr": "!(IORef Finalizers)", "FinalPtr": "", "MallocPtr": "(MutableByteArray# RealWorld) !(IORef Finalizers)", "PlainPtr": "(MutableByteArray# RealWorld)", "Finalizers": "", "NoFinalizers": "", "CFinalizers": "(Weak# ())", "HaskellFinalizers": "[IO ()]", "FinalizerPtr": "", "FinalizerEnvPtr": "", "newForeignPtr_": "Ptr a -> IO (ForeignPtr a)", "mallocForeignPtr": "Storable a => IO (ForeignPtr a)", "mallocPlainForeignPtr": "Storable a => IO (ForeignPtr a)", "mallocForeignPtrBytes": "Int -> IO (ForeignPtr a)", "mallocPlainForeignPtrBytes": "Int -> IO (ForeignPtr a)", "mallocForeignPtrAlignedBytes": "Int -> Int -> IO (ForeignPtr a)", "mallocPlainForeignPtrAlignedBytes": "Int -> Int -> IO (ForeignPtr a)", "newConcForeignPtr": "Ptr a -> IO () -> IO (ForeignPtr a)", "addForeignPtrFinalizer": "FinalizerPtr a -> ForeignPtr a -> IO ()", "addForeignPtrFinalizerEnv": "FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> IO ()", "addForeignPtrConcFinalizer": "ForeignPtr a -> IO () -> IO ()", "unsafeForeignPtrToPtr": "ForeignPtr a -> Ptr a", "castForeignPtr": "ForeignPtr a -> ForeignPtr b", "plusForeignPtr": "ForeignPtr a -> Int -> ForeignPtr b", "withForeignPtr": "ForeignPtr a -> (Ptr a -> IO b) -> IO b", "unsafeWithForeignPtr": "ForeignPtr a -> (Ptr a -> IO b) -> IO b", "touchForeignPtr": "ForeignPtr a -> IO ()", "finalizeForeignPtr": "ForeignPtr a -> IO ()"}, "GHC.GHCi": {"Monad": "", "ghciStepIO": "m a -> IO a", "NoIO": "", ">>=": "NoIO a -> (a -> NoIO b) -> NoIO b", ">>": "NoIO a -> NoIO b -> NoIO b", "return": "a -> NoIO a"}, "GHC.GHCi.Helpers": {"disableBuffering": "IO ()", "flushAll": "IO ()", "evalWrapper": "String -> [String] -> IO a -> IO a"}, "GHC.Generics": {"V1": "", "from1": "a b c d a b", "to1": "a b c d b c", "U1": "", "Par1": "", "unPar1": "p", ">>=": "Par1 a -> (a -> Par1 b) -> Par1 b", ">>": "Par1 a -> Par1 b -> Par1 b", "return": "a -> Par1 a", "Rec1": "", "unRec1": "f p", "K1": "", "unK1": "c", "M1": "", "unM1": "f p", "f": "", "L1": "(f p)", "R1": "(g p)", "Comp1": "", "unComp1": "f (g p)", "family": "", "UAddr": "", "UChar": "", "UDouble": "", "UFloat": "", "UInt": "", "UWord": "", "Rec0": "", "R": "", "D1": "", "C1": "", "S1": "", "D": "", "C": "", "S": "", "Datatype": "", "datatypeName": "t d (f k -> Type) (a k) -> [Char]", "moduleName": "t d (f k -> Type) (a k) -> [Char]", "packageName": "t d (f k -> Type) (a k) -> [Char]", "isNewtype": "t d (f k -> Type) (a k) -> Bool", "Constructor": "", "conName": "a b c d b e f g h c i j", "conFixity": "a b c d b e f g h c", "conIsRecord": "a b c d b e f g h c", "Selector": "", "selName": "t s (f k -> Type) (a k) -> [Char]", "selSourceUnpackedness": "t s (f k -> Type) (a k) -> SourceUnpackedness", "selSourceStrictness": "t s (f k -> Type) (a k) -> SourceStrictness", "selDecidedStrictness": "t s (f k -> Type) (a k) -> DecidedStrictness", "Fixity": "", "Prefix": "", "Infix": "Associativity Int", "==": "Fixity -> Fixity -> Bool", "/=": "Fixity -> Fixity -> Bool", "FixityI": "", "PrefixI": "", "InfixI": "Associativity Nat", "Associativity": "", "LeftAssociative": "", "RightAssociative": "", "NotAssociative": "", "minBound": "a", "maxBound": "a", "prec": "Fixity -> Int", "SourceUnpackedness": "", "NoSourceUnpackedness": "", "SourceNoUnpack": "", "SourceUnpack": "", "SourceStrictness": "", "NoSourceStrictness": "", "SourceLazy": "", "SourceStrict": "", "DecidedStrictness": "", "DecidedLazy": "", "DecidedStrict": "", "DecidedUnpack": "", "Meta": "", "MetaData": "Symbol Symbol Symbol Bool", "MetaCons": "Symbol FixityI Bool", "MetaSel": "(Maybe Symbol) SourceUnpackedness SourceStrictness DecidedStrictness", "Generic": "", "from": "a -> Rep a x", "to": "Rep a x -> a", "Generic1": ""}, "GHC.IO": {"IO": "", ">>=": "IO a -> (a -> IO b) -> IO b", ">>": "IO a -> IO b -> IO b", "return": "a -> IO a", "unIO": "IO a -> State# RealWorld -> (# State# RealWorld, a #)", "liftIO": "IO a -> State# RealWorld -> STret RealWorld a", "mplusIO": "IO a -> IO a -> IO a", "unsafePerformIO": "IO a -> a", "unsafeInterleaveIO": "IO a -> IO a", "unsafeDupablePerformIO": "IO a -> a", "unsafeDupableInterleaveIO": "IO a -> IO a", "noDuplicate": "IO ()", "stToIO": "ST RealWorld a -> IO a", "ioToST": "IO a -> ST RealWorld a", "unsafeIOToST": "IO a -> ST s a", "unsafeSTToIO": "ST s a -> IO a", "FilePath": "", "catch": "", "catchException": "Exception e => IO a -> (e -> IO a) -> IO a", "::": "", "throwIO": "Exception e => e -> IO a", "mask_": "IO a -> IO a", "uninterruptibleMask_": "IO a -> IO a", "MaskingState": "", "Unmasked": "", "MaskedInterruptible": "", "MaskedUninterruptible": "", "==": "MaskingState -> MaskingState -> Bool", "/=": "MaskingState -> MaskingState -> Bool", "getMaskingState": "IO MaskingState", "unsafeUnmask": "IO a -> IO a", "interruptible": "IO a -> IO a", "onException": "IO a -> IO b -> IO a", "bracket": "", "finally": "", "evaluate": "a -> IO a", "mkUserError": "[Char] -> SomeException"}, "GHC.IO.Buffer": {"Buffer": "", "bufRaw": "!(RawBuffer e)", "bufState": "BufferState", "bufSize": "!Int", "bufOffset": "!Word64", "bufL": "!Int", "bufR": "!Int", "BufferState": "", "ReadBuffer": "", "WriteBuffer": "", "==": "BufferState -> BufferState -> Bool", "/=": "BufferState -> BufferState -> Bool", "CharBuffer": "", "CharBufElem": "", "newByteBuffer": "Int -> BufferState -> IO (Buffer Word8)", "newCharBuffer": "Int -> BufferState -> IO CharBuffer", "newBuffer": "Int -> Int -> BufferState -> IO (Buffer e)", "emptyBuffer": "RawBuffer e -> Int -> BufferState -> Buffer e", "bufferRemove": "Int -> Buffer e -> Buffer e", "bufferAdd": "Int -> Buffer e -> Buffer e", "slideContents": "Buffer Word8 -> IO (Buffer Word8)", "bufferAdjustL": "Int -> Buffer e -> Buffer e", "bufferAddOffset": "Int -> Buffer e -> Buffer e", "bufferAdjustOffset": "Word64 -> Buffer e -> Buffer e", "isEmptyBuffer": "Buffer e -> Bool", "isFullBuffer": "Buffer e -> Bool", "isFullCharBuffer": "Buffer e -> Bool", "isWriteBuffer": "Buffer e -> Bool", "bufferElems": "Buffer e -> Int", "bufferAvailable": "Buffer e -> Int", "bufferOffset": "Buffer e -> Word64", "summaryBuffer": "Buffer a -> String", "withBuffer": "Buffer e -> (Ptr e -> IO a) -> IO a", "withRawBuffer": "RawBuffer e -> (Ptr e -> IO a) -> IO a", "checkBuffer": "Buffer a -> IO ()", "RawBuffer": "", "readWord8Buf": "RawBuffer Word8 -> Int -> IO Word8", "writeWord8Buf": "RawBuffer Word8 -> Int -> Word8 -> IO ()", "RawCharBuffer": "", "peekCharBuf": "RawCharBuffer -> Int -> IO Char", "readCharBuf": "RawCharBuffer -> Int -> IO (Char, Int)", "writeCharBuf": "RawCharBuffer -> Int -> Char -> IO Int", "readCharBufPtr": "Ptr CharBufElem -> Int -> IO (Char, Int)", "writeCharBufPtr": "Ptr CharBufElem -> Int -> Char -> IO Int", "charSize": "Int"}, "GHC.IO.BufferedIO": {"BufferedIO": "", "newBuffer": "dev -> BufferState -> IO (Buffer Word8)", "fillReadBuffer": "dev -> Buffer Word8 -> IO (Int, Buffer Word8)", "fillReadBuffer0": "dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)", "emptyWriteBuffer": "dev -> Buffer Word8 -> IO (Buffer Word8)", "flushWriteBuffer": "dev -> Buffer Word8 -> IO (Buffer Word8)", "flushWriteBuffer0": "dev -> Buffer Word8 -> IO (Int, Buffer Word8)", "readBuf": "RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)", "readBufNonBlocking": "RawIO dev => dev -> Buffer Word8 -> IO (Maybe Int, Buffer Word8)", "writeBuf": "RawIO dev => dev -> Buffer Word8 -> IO (Buffer Word8)", "writeBufNonBlocking": "RawIO dev => dev -> Buffer Word8 -> IO (Int, Buffer Word8)"}, "GHC.IO.Device": {"RawIO": "", "read": "a -> Ptr Word8 -> Word64 -> Int -> IO Int", "readNonBlocking": "a -> Ptr Word8 -> Word64 -> Int -> IO (Maybe Int)", "write": "a -> Ptr Word8 -> Word64 -> Int -> IO ()", "writeNonBlocking": "a -> Ptr Word8 -> Word64 -> Int -> IO Int", "IODevice": "", "ready": "a -> Bool -> Int -> IO Bool", "close": "a -> IO ()", "isTerminal": "a -> IO Bool", "isSeekable": "a -> IO Bool", "seek": "a -> SeekMode -> Integer -> IO Integer", "tell": "a -> IO Integer", "getSize": "a -> IO Integer", "setSize": "a -> Integer -> IO ()", "setEcho": "a -> Bool -> IO ()", "getEcho": "a -> IO Bool", "setRaw": "a -> Bool -> IO ()", "devType": "a -> IO IODeviceType", "dup": "a -> IO a", "dup2": "a -> a -> IO a", "IODeviceType": "", "Directory": "", "Stream": "", "RegularFile": "", "RawDevice": "", "==": "IODeviceType -> IODeviceType -> Bool", "/=": "IODeviceType -> IODeviceType -> Bool", "SeekMode": "", "AbsoluteSeek": "", "RelativeSeek": "", "SeekFromEnd": "", "succ": "SeekMode -> SeekMode", "pred": "SeekMode -> SeekMode", "toEnum": "Int -> SeekMode", "fromEnum": "SeekMode -> Int", "enumFrom": "SeekMode -> [SeekMode]", "enumFromThen": "SeekMode -> SeekMode -> [SeekMode]", "enumFromTo": "SeekMode -> SeekMode -> [SeekMode]", "enumFromThenTo": "SeekMode -> SeekMode -> SeekMode -> [SeekMode]"}, "GHC.IO.Encoding": {"BufferCodec": "", "encode": "CodeBuffer from to", "recover": "Buffer from -> Buffer to -> IO (Buffer from, Buffer to)", "close": "IO ()", "getState": "IO state", "setState": "state -> IO ()", "TextEncoding": "", "forall": "dstate estate. TextEncoding", "textEncodingName": "String", "mkTextDecoder": "IO (TextDecoder dstate)", "mkTextEncoder": "IO (TextEncoder estate)", "showsPrec": "Int -> TextEncoding -> ShowS", "show": "TextEncoding -> String", "showList": "[TextEncoding] -> ShowS", "TextEncoder": "", "TextDecoder": "", "CodingProgress": "", "InputUnderflow": "", "OutputUnderflow": "", "InvalidSequence": "", "==": "CodingProgress -> CodingProgress -> Bool", "/=": "CodingProgress -> CodingProgress -> Bool", "latin1": "TextEncoding", "latin1_encode": "CharBuffer -> Buffer Word8 -> IO (CharBuffer, Buffer Word8)", "latin1_decode": "Buffer Word8 -> CharBuffer -> IO (Buffer Word8, CharBuffer)", "utf8": "TextEncoding", "utf8_bom": "TextEncoding", "utf16": "TextEncoding", "utf16le": "TextEncoding", "utf16be": "TextEncoding", "utf32": "TextEncoding", "utf32le": "TextEncoding", "utf32be": "TextEncoding", "initLocaleEncoding": "TextEncoding", "getLocaleEncoding": "IO TextEncoding", "getFileSystemEncoding": "IO TextEncoding", "getForeignEncoding": "IO TextEncoding", "setLocaleEncoding": "TextEncoding -> IO ()", "setFileSystemEncoding": "TextEncoding -> IO ()", "setForeignEncoding": "TextEncoding -> IO ()", "char8": "TextEncoding", "mkTextEncoding": "String -> IO TextEncoding", "argvEncoding": "IO TextEncoding"}, "GHC.IO.Encoding.CodePage": {}, "GHC.IO.Encoding.Failure": {"CodingFailureMode": "", "ErrorOnCodingFailure": "", "IgnoreCodingFailure": "", "TransliterateCodingFailure": "", "RoundtripFailure": "", "showsPrec": "Int -> CodingFailureMode -> ShowS", "show": "CodingFailureMode -> String", "showList": "[CodingFailureMode] -> ShowS", "codingFailureModeSuffix": "CodingFailureMode -> String", "isSurrogate": "Char -> Bool", "recoverDecode": "CodingFailureMode -> Buffer Word8 -> Buffer Char -> IO (Buffer Word8, Buffer Char)", "recoverEncode": "CodingFailureMode -> Buffer Char -> Buffer Word8 -> IO (Buffer Char, Buffer Word8)"}, "GHC.IO.Encoding.Iconv": {"iconvEncoding": "String -> IO (Maybe TextEncoding)", "mkIconvEncoding": "CodingFailureMode -> String -> IO (Maybe TextEncoding)", "localeEncodingName": "String"}, "GHC.IO.Encoding.Latin1": {"latin1": "TextEncoding", "mkLatin1": "CodingFailureMode -> TextEncoding", "latin1_checked": "TextEncoding", "mkLatin1_checked": "CodingFailureMode -> TextEncoding", "ascii": "TextEncoding", "mkAscii": "CodingFailureMode -> TextEncoding", "latin1_decode": "DecodeBuffer", "ascii_decode": "DecodeBuffer", "latin1_encode": "EncodeBuffer", "latin1_checked_encode": "EncodeBuffer", "ascii_encode": "EncodeBuffer"}, "GHC.IO.Encoding.Types": {"BufferCodec": "", "encode": "CodeBuffer from to", "recover": "Buffer from -> Buffer to -> IO (Buffer from, Buffer to)", "close": "IO ()", "getState": "IO state", "setState": "state -> IO ()", "TextEncoding": "", "forall": "dstate estate. TextEncoding", "textEncodingName": "String", "mkTextDecoder": "IO (TextDecoder dstate)", "mkTextEncoder": "IO (TextEncoder estate)", "showsPrec": "Int -> TextEncoding -> ShowS", "show": "TextEncoding -> String", "showList": "[TextEncoding] -> ShowS", "TextEncoder": "", "TextDecoder": "", "CodeBuffer": "", "EncodeBuffer": "", "DecodeBuffer": "", "CodingProgress": "", "InputUnderflow": "", "OutputUnderflow": "", "InvalidSequence": "", "==": "CodingProgress -> CodingProgress -> Bool", "/=": "CodingProgress -> CodingProgress -> Bool"}, "GHC.IO.Encoding.UTF16": {"utf16": "TextEncoding", "mkUTF16": "CodingFailureMode -> TextEncoding", "utf16_decode": "IORef (Maybe DecodeBuffer) -> DecodeBuffer", "utf16_encode": "IORef Bool -> EncodeBuffer", "utf16be": "TextEncoding", "mkUTF16be": "CodingFailureMode -> TextEncoding", "utf16be_decode": "DecodeBuffer", "utf16be_encode": "EncodeBuffer", "utf16le": "TextEncoding", "mkUTF16le": "CodingFailureMode -> TextEncoding", "utf16le_decode": "DecodeBuffer", "utf16le_encode": "EncodeBuffer"}, "GHC.IO.Encoding.UTF32": {"utf32": "TextEncoding", "mkUTF32": "CodingFailureMode -> TextEncoding", "utf32_decode": "IORef (Maybe DecodeBuffer) -> DecodeBuffer", "utf32_encode": "IORef Bool -> EncodeBuffer", "utf32be": "TextEncoding", "mkUTF32be": "CodingFailureMode -> TextEncoding", "utf32be_decode": "DecodeBuffer", "utf32be_encode": "EncodeBuffer", "utf32le": "TextEncoding", "mkUTF32le": "CodingFailureMode -> TextEncoding", "utf32le_decode": "DecodeBuffer", "utf32le_encode": "EncodeBuffer"}, "GHC.IO.Encoding.UTF8": {"utf8": "TextEncoding", "mkUTF8": "CodingFailureMode -> TextEncoding", "utf8_bom": "TextEncoding", "mkUTF8_bom": "CodingFailureMode -> TextEncoding"}, "GHC.IO.Exception": {"BlockedIndefinitelyOnMVar": "", "showsPrec": "Int -> a -> ShowS", "show": "a -> String", "showList": "[a] -> ShowS", "blockedIndefinitelyOnMVar": "SomeException", "BlockedIndefinitelyOnSTM": "", "blockedIndefinitelyOnSTM": "SomeException", "Deadlock": "", "AllocationLimitExceeded": "", "allocationLimitExceeded": "SomeException", "AssertionFailed": "", "CompactionFailed": "", "cannotCompactFunction": "SomeException", "cannotCompactPinned": "SomeException", "cannotCompactMutable": "SomeException", "SomeAsyncException": "", "forall": "e.Exception e => SomeAsyncException e", "asyncExceptionToException": "Exception e => e -> SomeException", "asyncExceptionFromException": "Exception e => SomeException -> Maybe e", "AsyncException": "", "StackOverflow": "", "HeapOverflow": "", "ThreadKilled": "", "UserInterrupt": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "stackOverflow": "SomeException", "heapOverflow": "SomeException", "ArrayException": "", "IndexOutOfBounds": "String", "UndefinedElement": "String", "ExitCode": "", "ExitSuccess": "", "ExitFailure": "Int", "FixIOException": "", "ioException": "IOException -> IO a", "ioError": "IOError -> IO a", "IOError": "", "IOException": "", "ioe_handle": "Maybe Handle", "ioe_type": "IOErrorType", "ioe_location": "String", "ioe_description": "String", "ioe_errno": "Maybe CInt", "ioe_filename": "Maybe FilePath", "IOErrorType": "", "AlreadyExists": "", "NoSuchThing": "", "ResourceBusy": "", "ResourceExhausted": "", "EOF": "", "IllegalOperation": "", "PermissionDenied": "", "UserError": "", "UnsatisfiedConstraints": "", "SystemError": "", "ProtocolError": "", "OtherError": "", "InvalidArgument": "", "InappropriateType": "", "HardwareFault": "", "UnsupportedOperation": "", "TimeExpired": "", "ResourceVanished": "", "Interrupted": "", "userError": "String -> IOError", "assertError": "(?callStack CallStack) => Bool -> a -> a", "unsupportedOperation": "IOError", "untangle": "Addr# -> String -> String"}, "GHC.IO.FD": {"FD": "", "fdFD": "!CInt", "fdIsNonBlocking": "!Int", "showsPrec": "Int -> FD -> ShowS", "show": "FD -> String", "showList": "[FD] -> ShowS", "openFile": "", "mkFD": "", "release": "FD -> IO ()", "setNonBlockingMode": "FD -> Bool -> IO FD", "readRawBufferPtr": "String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int", "readRawBufferPtrNoBlock": "String -> FD -> Ptr Word8 -> Int -> CSize -> IO Int", "writeRawBufferPtr": "String -> FD -> Ptr Word8 -> Int -> CSize -> IO CInt", "stdin": "FD", "stdout": "FD", "stderr": "FD"}, "GHC.IO.Handle": {"Handle": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "BufferMode": "", "NoBuffering": "", "LineBuffering": "", "BlockBuffering": "(Maybe Int)", "mkFileHandle": "", "mkDuplexHandle": "(RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle", "hFileSize": "Handle -> IO Integer", "hSetFileSize": "Handle -> Integer -> IO ()", "hIsEOF": "Handle -> IO Bool", "isEOF": "IO Bool", "hLookAhead": "Handle -> IO Char", "hSetBuffering": "Handle -> BufferMode -> IO ()", "hSetBinaryMode": "Handle -> Bool -> IO ()", "hSetEncoding": "Handle -> TextEncoding -> IO ()", "hGetEncoding": "Handle -> IO (Maybe TextEncoding)", "hFlush": "Handle -> IO ()", "hFlushAll": "Handle -> IO ()", "hDuplicate": "Handle -> IO Handle", "hDuplicateTo": "Handle -> Handle -> IO ()", "hClose": "Handle -> IO ()", "hClose_help": "Handle__ -> IO (Handle__, Maybe SomeException)", "LockMode": "", "SharedLock": "", "ExclusiveLock": "", "hLock": "Handle -> LockMode -> IO ()", "hTryLock": "Handle -> LockMode -> IO Bool", "HandlePosition": "", "HandlePosn": "", "hGetPosn": "Handle -> IO HandlePosn", "hSetPosn": "HandlePosn -> IO ()", "SeekMode": "", "AbsoluteSeek": "", "RelativeSeek": "", "SeekFromEnd": "", "succ": "SeekMode -> SeekMode", "pred": "SeekMode -> SeekMode", "toEnum": "Int -> SeekMode", "fromEnum": "SeekMode -> Int", "enumFrom": "SeekMode -> [SeekMode]", "enumFromThen": "SeekMode -> SeekMode -> [SeekMode]", "enumFromTo": "SeekMode -> SeekMode -> [SeekMode]", "enumFromThenTo": "SeekMode -> SeekMode -> SeekMode -> [SeekMode]", "hSeek": "Handle -> SeekMode -> Integer -> IO ()", "hTell": "Handle -> IO Integer", "hIsOpen": "Handle -> IO Bool", "hIsClosed": "Handle -> IO Bool", "hIsReadable": "Handle -> IO Bool", "hIsWritable": "Handle -> IO Bool", "hGetBuffering": "Handle -> IO BufferMode", "hIsSeekable": "Handle -> IO Bool", "hSetEcho": "Handle -> Bool -> IO ()", "hGetEcho": "Handle -> IO Bool", "hIsTerminalDevice": "Handle -> IO Bool", "hSetNewlineMode": "Handle -> NewlineMode -> IO ()", "Newline": "", "LF": "", "CRLF": "", "NewlineMode": "", "inputNL": "Newline", "outputNL": "Newline", "nativeNewline": "Newline", "noNewlineTranslation": "NewlineMode", "universalNewlineMode": "NewlineMode", "nativeNewlineMode": "NewlineMode", "hShow": "Handle -> IO String", "hWaitForInput": "Handle -> Int -> IO Bool", "hGetChar": "Handle -> IO Char", "hGetLine": "Handle -> IO String", "hGetContents": "Handle -> IO String", "hGetContents'": "Handle -> IO String", "hPutChar": "Handle -> Char -> IO ()", "hPutStr": "Handle -> String -> IO ()", "hGetBuf": "Handle -> Ptr a -> Int -> IO Int", "hGetBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int", "hPutBuf": "Handle -> Ptr a -> Int -> IO ()", "hPutBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int"}, "GHC.IO.Handle.FD": {"stdin": "Handle", "stdout": "Handle", "stderr": "Handle", "openFile": "FilePath -> IOMode -> IO Handle", "openBinaryFile": "FilePath -> IOMode -> IO Handle", "openFileBlocking": "FilePath -> IOMode -> IO Handle", "mkHandleFromFD": "FD -> IODeviceType -> FilePath -> IOMode -> Bool -> Maybe TextEncoding -> IO Handle", "fdToHandle": "FD -> IO Handle", "fdToHandle'": "CInt -> Maybe IODeviceType -> Bool -> FilePath -> IOMode -> Bool -> IO Handle", "handleToFd": "Handle -> IO FD"}, "GHC.IO.Handle.Internals": {"withHandle": "String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a", "withHandle'": "String -> Handle -> MVar Handle__ -> (Handle__ -> IO (Handle__, a)) -> IO a", "withHandle_": "String -> Handle -> (Handle__ -> IO a) -> IO a", "withHandle__'": "String -> Handle -> MVar Handle__ -> (Handle__ -> IO Handle__) -> IO ()", "withHandle_'": "String -> Handle -> MVar Handle__ -> (Handle__ -> IO a) -> IO a", "withAllHandles__": "String -> Handle -> (Handle__ -> IO Handle__) -> IO ()", "wantWritableHandle": "String -> Handle -> (Handle__ -> IO a) -> IO a", "wantReadableHandle": "String -> Handle -> (Handle__ -> IO (Handle__, a)) -> IO a", "wantReadableHandle_": "String -> Handle -> (Handle__ -> IO a) -> IO a", "wantSeekableHandle": "String -> Handle -> (Handle__ -> IO a) -> IO a", "mkHandle": "(RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> HandleType -> Bool -> Maybe TextEncoding -> NewlineMode -> Maybe HandleFinalizer -> Maybe (MVar Handle__) -> IO Handle", "mkFileHandle": "", "mkDuplexHandle": "(RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => dev -> FilePath -> Maybe TextEncoding -> NewlineMode -> IO Handle", "::": "", "closeTextCodecs": "Handle__ -> IO ()", "initBufferState": "HandleType -> BufferState", "dEFAULT_CHAR_BUFFER_SIZE": "Int", "flushBuffer": "Handle__ -> IO ()", "flushWriteBuffer": "Handle__ -> IO ()", "flushCharReadBuffer": "Handle__ -> IO ()", "flushCharBuffer": "Handle__ -> IO ()", "flushByteReadBuffer": "Handle__ -> IO ()", "flushByteWriteBuffer": "Handle__ -> IO ()", "readTextDevice": "Handle__ -> CharBuffer -> IO CharBuffer", "writeCharBuffer": "Handle__ -> CharBuffer -> IO ()", "readTextDeviceNonBlocking": "Handle__ -> CharBuffer -> IO CharBuffer", "decodeByteBuf": "Handle__ -> CharBuffer -> IO CharBuffer", "augmentIOError": "IOException -> String -> Handle -> IOException", "ioe_closedHandle": "IO a", "ioe_semiclosedHandle": "IO a", "ioe_EOF": "IO a", "ioe_notReadable": "IO a", "ioe_notWritable": "IO a", "ioe_finalizedHandle": "FilePath -> Handle__", "ioe_bufsiz": "Int -> IO a", "hClose_help": "Handle__ -> IO (Handle__, Maybe SomeException)", "hLookAhead_": "Handle__ -> IO Char", "HandleFinalizer": "", "handleFinalizer": "FilePath -> MVar Handle__ -> IO ()", "debugIO": "String -> IO ()", "traceIO": "String -> IO ()"}, "GHC.IO.Handle.Lock": {"FileLockingNotSupported": "", "showsPrec": "Int -> FileLockingNotSupported -> ShowS", "show": "FileLockingNotSupported -> String", "showList": "[FileLockingNotSupported] -> ShowS", "LockMode": "", "SharedLock": "", "ExclusiveLock": "", "hLock": "Handle -> LockMode -> IO ()", "hTryLock": "Handle -> LockMode -> IO Bool", "hUnlock": "Handle -> IO ()"}, "GHC.IO.Handle.Text": {"hWaitForInput": "Handle -> Int -> IO Bool", "hGetChar": "Handle -> IO Char", "hGetLine": "Handle -> IO String", "hGetContents": "Handle -> IO String", "hPutChar": "Handle -> Char -> IO ()", "hPutStr": "Handle -> String -> IO ()", "commitBuffer'": "RawCharBuffer -> Int -> Int -> Bool -> Bool -> Handle__ -> IO CharBuffer", "hGetBuf": "Handle -> Ptr a -> Int -> IO Int", "hGetBufSome": "Handle -> Ptr a -> Int -> IO Int", "hGetBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int", "hPutBuf": "Handle -> Ptr a -> Int -> IO ()", "hPutBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int", "memcpy": "Ptr a -> Ptr a -> CSize -> IO (Ptr ())", "hPutStrLn": "Handle -> String -> IO ()", "hGetContents'": "Handle -> IO String"}, "GHC.IO.Handle.Types": {"Handle": "", "FileHandle": "FilePath !(MVar Handle__)", "DuplexHandle": "FilePath !(MVar Handle__) !(MVar Handle__)", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "Handle__": "", "forall": "dev enc_state dec_state.(RawIO dev, IODevice dev, BufferedIO dev, Typeable dev) => Handle__", "haDevice": "!dev", "haType": "HandleType", "haByteBuffer": "!(IORef (Buffer Word8))", "haBufferMode": "BufferMode", "haLastDecode": "!(IORef (dec_state, Buffer Word8))", "haCharBuffer": "!(IORef (Buffer CharBufElem))", "haBuffers": "!(IORef (BufferList CharBufElem))", "haEncoder": "Maybe (TextEncoder enc_state)", "haDecoder": "Maybe (TextDecoder dec_state)", "haCodec": "Maybe TextEncoding", "haInputNL": "Newline", "haOutputNL": "Newline", "haOtherSide": "Maybe (MVar Handle__)", "showHandle": "FilePath -> String -> String", "checkHandleInvariants": "Handle__ -> IO ()", "BufferList": "", "BufferListNil": "", "BufferListCons": "(RawBuffer e) (BufferList e)", "HandleType": "", "ClosedHandle": "", "SemiClosedHandle": "", "ReadHandle": "", "WriteHandle": "", "AppendHandle": "", "ReadWriteHandle": "", "showsPrec": "Int -> HandleType -> ShowS", "show": "HandleType -> String", "showList": "[HandleType] -> ShowS", "isReadableHandleType": "HandleType -> Bool", "isWritableHandleType": "HandleType -> Bool", "isReadWriteHandleType": "HandleType -> Bool", "isAppendHandleType": "HandleType -> Bool", "BufferMode": "", "NoBuffering": "", "LineBuffering": "", "BlockBuffering": "(Maybe Int)", "BufferCodec": "", "encode": "CodeBuffer from to", "recover": "Buffer from -> Buffer to -> IO (Buffer from, Buffer to)", "close": "IO ()", "getState": "IO state", "setState": "state -> IO ()", "NewlineMode": "", "inputNL": "Newline", "outputNL": "Newline", "Newline": "", "LF": "", "CRLF": "", "nativeNewline": "Newline", "universalNewlineMode": "NewlineMode", "noNewlineTranslation": "NewlineMode", "nativeNewlineMode": "NewlineMode"}, "GHC.IO.IOMode": {"IOMode": "", "ReadMode": "", "WriteMode": "", "AppendMode": "", "ReadWriteMode": "", "succ": "IOMode -> IOMode", "pred": "IOMode -> IOMode", "toEnum": "Int -> IOMode", "fromEnum": "IOMode -> Int", "enumFrom": "IOMode -> [IOMode]", "enumFromThen": "IOMode -> IOMode -> [IOMode]", "enumFromTo": "IOMode -> IOMode -> [IOMode]", "enumFromThenTo": "IOMode -> IOMode -> IOMode -> [IOMode]"}, "GHC.IO.StdHandles": {"stdin": "Handle", "stdout": "Handle", "stderr": "Handle", "openFile": "FilePath -> IOMode -> IO Handle", "openBinaryFile": "FilePath -> IOMode -> IO Handle", "openFileBlocking": "FilePath -> IOMode -> IO Handle"}, "GHC.IO.SubSystem": {"withIoSubSystem": "(IoSubSystem -> IO a) -> IO a", "withIoSubSystem'": "(IoSubSystem -> a) -> a", "whenIoSubSystem": "IoSubSystem -> IO () -> IO ()", "ioSubSystem": "IoSubSystem", "IoSubSystem": "", "IoPOSIX": "", "IoNative": "", "succ": "IoSubSystem -> IoSubSystem", "pred": "IoSubSystem -> IoSubSystem", "toEnum": "Int -> IoSubSystem", "fromEnum": "IoSubSystem -> Int", "enumFrom": "IoSubSystem -> [IoSubSystem]", "enumFromThen": "IoSubSystem -> IoSubSystem -> [IoSubSystem]", "enumFromTo": "IoSubSystem -> IoSubSystem -> [IoSubSystem]", "enumFromThenTo": "IoSubSystem -> IoSubSystem -> IoSubSystem -> [IoSubSystem]", "conditional": "a -> a -> a", "<!>": "a -> a -> a infixl 7", "isWindowsNativeIO": "Bool"}, "GHC.IO.Unsafe": {"unsafePerformIO": "IO a -> a", "unsafeInterleaveIO": "IO a -> IO a", "unsafeDupablePerformIO": "IO a -> a", "unsafeDupableInterleaveIO": "IO a -> IO a", "noDuplicate": "IO ()"}, "GHC.IOArray": {"IOArray": "", "==": "IOArray i e -> IOArray i e -> Bool", "/=": "IOArray i e -> IOArray i e -> Bool", "newIOArray": "Ix i => (i, i) -> e -> IO (IOArray i e)", "unsafeReadIOArray": "IOArray i e -> Int -> IO e", "unsafeWriteIOArray": "IOArray i e -> Int -> e -> IO ()", "readIOArray": "Ix i => IOArray i e -> i -> IO e", "writeIOArray": "Ix i => IOArray i e -> i -> e -> IO ()", "boundsIOArray": "IOArray i e -> (i, i)"}, "GHC.IORef": {"IORef": "", "==": "IORef a -> IORef a -> Bool", "/=": "IORef a -> IORef a -> Bool", "newIORef": "a -> IO (IORef a)", "readIORef": "IORef a -> IO a", "writeIORef": "IORef a -> a -> IO ()", "atomicModifyIORef2Lazy": "IORef a -> (a -> (a, b)) -> IO (a, (a, b))", "atomicModifyIORef2": "IORef a -> (a -> (a, b)) -> IO (a, (a, b))", "atomicModifyIORefLazy_": "IORef a -> (a -> a) -> IO (a, a)", "atomicModifyIORef'_": "IORef a -> (a -> a) -> IO (a, a)", "atomicModifyIORefP": "IORef a -> (a -> (a, b)) -> IO b", "atomicSwapIORef": "IORef a -> a -> IO a", "atomicModifyIORef'": "IORef a -> (a -> (a, b)) -> IO b"}, "GHC.Int": {"Int": "", "I#": "Int#", "minBound": "a", "maxBound": "a", "Int8": "", "I8#": "Int#", "Int16": "", "I16#": "Int#", "Int32": "", "I32#": "Int#", "Int64": "", "I64#": "Int#", "uncheckedIShiftL64#": "Int# -> Int# -> Int#", "uncheckedIShiftRA64#": "Int# -> Int# -> Int#", "eqInt": "Int -> Int -> Bool", "neInt": "Int -> Int -> Bool", "gtInt": "Int -> Int -> Bool", "geInt": "Int -> Int -> Bool", "ltInt": "Int -> Int -> Bool", "leInt": "Int -> Int -> Bool", "eqInt8": "Int8 -> Int8 -> Bool", "neInt8": "Int8 -> Int8 -> Bool", "gtInt8": "Int8 -> Int8 -> Bool", "geInt8": "Int8 -> Int8 -> Bool", "ltInt8": "Int8 -> Int8 -> Bool", "leInt8": "Int8 -> Int8 -> Bool", "eqInt16": "Int16 -> Int16 -> Bool", "neInt16": "Int16 -> Int16 -> Bool", "gtInt16": "Int16 -> Int16 -> Bool", "geInt16": "Int16 -> Int16 -> Bool", "ltInt16": "Int16 -> Int16 -> Bool", "leInt16": "Int16 -> Int16 -> Bool", "eqInt32": "Int32 -> Int32 -> Bool", "neInt32": "Int32 -> Int32 -> Bool", "gtInt32": "Int32 -> Int32 -> Bool", "geInt32": "Int32 -> Int32 -> Bool", "ltInt32": "Int32 -> Int32 -> Bool", "leInt32": "Int32 -> Int32 -> Bool", "eqInt64": "Int64 -> Int64 -> Bool", "neInt64": "Int64 -> Int64 -> Bool", "gtInt64": "Int64 -> Int64 -> Bool", "geInt64": "Int64 -> Int64 -> Bool", "ltInt64": "Int64 -> Int64 -> Bool", "leInt64": "Int64 -> Int64 -> Bool"}, "GHC.Integer": {"Integer": "", "succ": "Integer -> Integer", "pred": "Integer -> Integer", "toEnum": "Int -> Integer", "fromEnum": "Integer -> Int", "enumFrom": "Integer -> [Integer]", "enumFromThen": "Integer -> Integer -> [Integer]", "enumFromTo": "Integer -> Integer -> [Integer]", "enumFromThenTo": "Integer -> Integer -> Integer -> [Integer]", "smallInteger": "Int# -> Integer", "wordToInteger": "Word# -> Integer", "integerToWord": "Integer -> Word#", "integerToInt": "Integer -> Int#", "encodeFloatInteger": "Integer -> Int# -> Float#", "floatFromInteger": "Integer -> Float#", "encodeDoubleInteger": "Integer -> Int# -> Double#", "decodeDoubleInteger": "Double# -> (# Integer, Int# #)", "doubleFromInteger": "Integer -> Double#", "plusInteger": "Integer -> Integer -> Integer", "minusInteger": "Integer -> Integer -> Integer", "timesInteger": "Integer -> Integer -> Integer", "negateInteger": "Integer -> Integer", "absInteger": "Integer -> Integer", "signumInteger": "Integer -> Integer", "divModInteger": "Integer -> Integer -> (# Integer, Integer #)", "divInteger": "Integer -> Integer -> Integer", "modInteger": "Integer -> Integer -> Integer", "quotRemInteger": "Integer -> Integer -> (# Integer, Integer #)", "quotInteger": "Integer -> Integer -> Integer", "remInteger": "Integer -> Integer -> Integer", "eqInteger": "Integer -> Integer -> Bool", "neqInteger": "Integer -> Integer -> Bool", "leInteger": "Integer -> Integer -> Bool", "gtInteger": "Integer -> Integer -> Bool", "ltInteger": "Integer -> Integer -> Bool", "geInteger": "Integer -> Integer -> Bool", "compareInteger": "Integer -> Integer -> Ordering", "eqInteger#": "Integer -> Integer -> Int#", "neqInteger#": "Integer -> Integer -> Int#", "leInteger#": "Integer -> Integer -> Int#", "gtInteger#": "Integer -> Integer -> Int#", "ltInteger#": "Integer -> Integer -> Int#", "geInteger#": "Integer -> Integer -> Int#", "andInteger": "Integer -> Integer -> Integer", "orInteger": "Integer -> Integer -> Integer", "xorInteger": "Integer -> Integer -> Integer", "complementInteger": "Integer -> Integer", "shiftLInteger": "Integer -> Int# -> Integer", "shiftRInteger": "Integer -> Int# -> Integer", "testBitInteger": "Integer -> Int# -> Bool", "popCountInteger": "Integer -> Int#", "bitInteger": "Int# -> Integer", "hashInteger": "Integer -> Int#"}, "GHC.Integer.Logarithms": {"wordLog2#": "Word# -> Int#", "integerLog2#": "Integer -> Int#", "integerLogBase#": "Integer -> Integer -> Int#"}, "GHC.Ix": {"Ord": "", "range": "(a, a) -> [a]", "index": "(a, a) -> a -> Int", "unsafeIndex": "(a, a) -> a -> Int", "inRange": "(a, a) -> a -> Bool", "rangeSize": "(a, a) -> Int", "unsafeRangeSize": "(a, a) -> Int", "indexError": "Show a => (a, a) -> a -> String -> b"}, "GHC.List": {"map": "(a -> b) -> [a] -> [b]", "++": "[a] -> [a] -> [a] infixr 5", "filter": "(a -> Bool) -> [a] -> [a]", "concat": "[[a]] -> [a]", "head": "[a] -> a", "last": "[a] -> a", "tail": "[a] -> [a]", "init": "[a] -> [a]", "uncons": "[a] -> Maybe (a, [a])", "null": "[a] -> Bool", "length": "[a] -> Int", "!!": "[a] -> Int -> a infixl 9", "::": "", "foldl1": "(a -> a -> a) -> [a] -> a", "foldl1'": "(a -> a -> a) -> [a] -> a", "scanl": "(b -> a -> b) -> b -> [a] -> [b]", "scanl1": "(a -> a -> a) -> [a] -> [a]", "scanl'": "(b -> a -> b) -> b -> [a] -> [b]", "foldr": "(a -> b -> b) -> b -> [a] -> b", "foldr1": "(a -> a -> a) -> [a] -> a", "scanr": "(a -> b -> b) -> b -> [a] -> [b]", "scanr1": "(a -> a -> a) -> [a] -> [a]", "iterate": "(a -> a) -> a -> [a]", "iterate'": "(a -> a) -> a -> [a]", "repeat": "a -> [a]", "replicate": "Int -> a -> [a]", "cycle": "[a] -> [a]", "take": "Int -> [a] -> [a]", "drop": "Int -> [a] -> [a]", "sum": "Num a => [a] -> a", "product": "Num a => [a] -> a", "maximum": "Ord a => [a] -> a", "minimum": "Ord a => [a] -> a", "splitAt": "Int -> [a] -> ([a], [a])", "takeWhile": "(a -> Bool) -> [a] -> [a]", "dropWhile": "(a -> Bool) -> [a] -> [a]", "span": "(a -> Bool) -> [a] -> ([a], [a])", "break": "(a -> Bool) -> [a] -> ([a], [a])", "reverse": "[a] -> [a]", "and": "[Bool] -> Bool", "or": "[Bool] -> Bool", "any": "(a -> Bool) -> [a] -> Bool", "all": "(a -> Bool) -> [a] -> Bool", "elem": "Eq a => a -> [a] -> Bool infix 4", "notElem": "Eq a => a -> [a] -> Bool infix 4", "lookup": "Eq a => a -> [(a, b)] -> Maybe b", "concatMap": "(a -> [b]) -> [a] -> [b]", "zip": "[a] -> [b] -> [(a, b)]", "zip3": "[a] -> [b] -> [c] -> [(a, b, c)]", "zipWith": "(a -> b -> c) -> [a] -> [b] -> [c]", "zipWith3": "(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]", "unzip": "[(a, b)] -> ([a], [b])", "unzip3": "[(a, b, c)] -> ([a], [b], [c])", "errorEmptyList": "String -> a"}, "GHC.MVar": {"MVar": "", "==": "MVar a -> MVar a -> Bool", "/=": "MVar a -> MVar a -> Bool", "newMVar": "a -> IO (MVar a)", "newEmptyMVar": "IO (MVar a)", "takeMVar": "MVar a -> IO a", "readMVar": "MVar a -> IO a", "putMVar": "MVar a -> a -> IO ()", "tryTakeMVar": "MVar a -> IO (Maybe a)", "tryPutMVar": "MVar a -> a -> IO Bool", "tryReadMVar": "MVar a -> IO (Maybe a)", "isEmptyMVar": "MVar a -> IO Bool", "addMVarFinalizer": "MVar a -> IO () -> IO ()"}, "GHC.Maybe": {"Maybe": "", "Nothing": "", "Just": "a", ">>=": "Maybe a -> (a -> Maybe b) -> Maybe b", ">>": "Maybe a -> Maybe b -> Maybe b", "return": "a -> Maybe a"}, "GHC.Natural": {"Natural": "", "succ": "Natural -> Natural", "pred": "Natural -> Natural", "toEnum": "Int -> Natural", "fromEnum": "Natural -> Int", "enumFrom": "Natural -> [Natural]", "enumFromThen": "Natural -> Natural -> [Natural]", "enumFromTo": "Natural -> Natural -> [Natural]", "enumFromThenTo": "Natural -> Natural -> Natural -> [Natural]", "BigNat": "", "BN#": "", "unBigNat": "BigNat#", "mkNatural": "[Word] -> Natural", "isValidNatural": "Natural -> Bool", "plusNatural": "Natural -> Natural -> Natural", "minusNatural": "Natural -> Natural -> Natural", "minusNaturalMaybe": "Natural -> Natural -> Maybe Natural", "timesNatural": "Natural -> Natural -> Natural", "negateNatural": "Natural -> Natural", "signumNatural": "Natural -> Natural", "quotRemNatural": "Natural -> Natural -> (Natural, Natural)", "quotNatural": "Natural -> Natural -> Natural", "remNatural": "Natural -> Natural -> Natural", "gcdNatural": "Natural -> Natural -> Natural", "lcmNatural": "Natural -> Natural -> Natural", "andNatural": "Natural -> Natural -> Natural", "orNatural": "Natural -> Natural -> Natural", "xorNatural": "Natural -> Natural -> Natural", "bitNatural": "Int# -> Natural", "testBitNatural": "Natural -> Int -> Bool", "popCountNatural": "Natural -> Int", "shiftLNatural": "Natural -> Int -> Natural", "shiftRNatural": "Natural -> Int -> Natural", "naturalToInteger": "Natural -> Integer", "naturalToWord": "Natural -> Word", "naturalToWordMaybe": "Natural -> Maybe Word", "wordToNatural": "Word -> Natural", "wordToNatural#": "Word -> Natural", "naturalFromInteger": "Integer -> Natural", "powModNatural": "Natural -> Natural -> Natural -> Natural"}, "GHC.Num": {"Num": "", "+": "a -> a -> a infixl 6", "-": "a -> a -> a infixl 6", "*": "a -> a -> a infixl 7", "negate": "a -> a", "abs": "a -> a", "signum": "a -> a", "fromInteger": "Integer -> a", "subtract": "Num a => a -> a -> a", "quotRemInteger": "Integer -> Integer -> (# Integer, Integer #)", "module": "a"}, "GHC.OldList": {"++": "[a] -> [a] -> [a] infixr 5", "head": "[a] -> a", "last": "[a] -> a", "tail": "[a] -> [a]", "init": "[a] -> [a]", "uncons": "[a] -> Maybe (a, [a])", "singleton": "a -> [a]", "null": "[a] -> Bool", "length": "[a] -> Int", "map": "(a -> b) -> [a] -> [b]", "reverse": "[a] -> [a]", "intersperse": "a -> [a] -> [a]", "intercalate": "[a] -> [[a]] -> [a]", "transpose": "[[a]] -> [[a]]", "subsequences": "[a] -> [[a]]", "permutations": "[a] -> [[a]]", "::": "", "foldl1": "(a -> a -> a) -> [a] -> a", "foldl1'": "(a -> a -> a) -> [a] -> a", "foldr": "(a -> b -> b) -> b -> [a] -> b", "foldr1": "(a -> a -> a) -> [a] -> a", "concat": "[[a]] -> [a]", "concatMap": "(a -> [b]) -> [a] -> [b]", "and": "[Bool] -> Bool", "or": "[Bool] -> Bool", "any": "(a -> Bool) -> [a] -> Bool", "all": "(a -> Bool) -> [a] -> Bool", "sum": "Num a => [a] -> a", "product": "Num a => [a] -> a", "maximum": "Ord a => [a] -> a", "minimum": "Ord a => [a] -> a", "scanl": "(b -> a -> b) -> b -> [a] -> [b]", "scanl'": "(b -> a -> b) -> b -> [a] -> [b]", "scanl1": "(a -> a -> a) -> [a] -> [a]", "scanr": "(a -> b -> b) -> b -> [a] -> [b]", "scanr1": "(a -> a -> a) -> [a] -> [a]", "mapAccumL": "(acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])", "mapAccumR": "(acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])", "iterate": "(a -> a) -> a -> [a]", "iterate'": "(a -> a) -> a -> [a]", "repeat": "a -> [a]", "replicate": "Int -> a -> [a]", "cycle": "[a] -> [a]", "unfoldr": "(b -> Maybe (a, b)) -> b -> [a]", "take": "Int -> [a] -> [a]", "drop": "Int -> [a] -> [a]", "splitAt": "Int -> [a] -> ([a], [a])", "takeWhile": "(a -> Bool) -> [a] -> [a]", "dropWhile": "(a -> Bool) -> [a] -> [a]", "dropWhileEnd": "(a -> Bool) -> [a] -> [a]", "span": "(a -> Bool) -> [a] -> ([a], [a])", "break": "(a -> Bool) -> [a] -> ([a], [a])", "stripPrefix": "Eq a => [a] -> [a] -> Maybe [a]", "group": "Eq a => [a] -> [[a]]", "inits": "[a] -> [[a]]", "tails": "[a] -> [[a]]", "isPrefixOf": "Eq a => [a] -> [a] -> Bool", "isSuffixOf": "Eq a => [a] -> [a] -> Bool", "isInfixOf": "Eq a => [a] -> [a] -> Bool", "elem": "Eq a => a -> [a] -> Bool infix 4", "notElem": "Eq a => a -> [a] -> Bool infix 4", "lookup": "Eq a => a -> [(a, b)] -> Maybe b", "find": "(a -> Bool) -> [a] -> Maybe a", "filter": "(a -> Bool) -> [a] -> [a]", "partition": "(a -> Bool) -> [a] -> ([a], [a])", "!!": "[a] -> Int -> a infixl 9", "elemIndex": "Eq a => a -> [a] -> Maybe Int", "elemIndices": "Eq a => a -> [a] -> [Int]", "findIndex": "(a -> Bool) -> [a] -> Maybe Int", "findIndices": "(a -> Bool) -> [a] -> [Int]", "zip": "[a] -> [b] -> [(a, b)]", "zip3": "[a] -> [b] -> [c] -> [(a, b, c)]", "zip4": "[a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]", "zip5": "[a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]", "zip6": "[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]", "zip7": "[a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]", "zipWith": "(a -> b -> c) -> [a] -> [b] -> [c]", "zipWith3": "(a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]", "zipWith4": "(a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]", "zipWith5": "(a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]", "zipWith6": "(a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]", "zipWith7": "(a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]", "unzip": "[(a, b)] -> ([a], [b])", "unzip3": "[(a, b, c)] -> ([a], [b], [c])", "unzip4": "[(a, b, c, d)] -> ([a], [b], [c], [d])", "unzip5": "[(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])", "unzip6": "[(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])", "unzip7": "[(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])", "lines": "String -> [String]", "words": "String -> [String]", "unlines": "[String] -> String", "unwords": "[String] -> String", "nub": "Eq a => [a] -> [a]", "delete": "Eq a => a -> [a] -> [a]", "\\\\": "Eq a => [a] -> [a] -> [a] infix 5", "union": "Eq a => [a] -> [a] -> [a]", "intersect": "Eq a => [a] -> [a] -> [a]", "sort": "Ord a => [a] -> [a]", "sortOn": "Ord b => (a -> b) -> [a] -> [a]", "insert": "Ord a => a -> [a] -> [a]", "nubBy": "(a -> a -> Bool) -> [a] -> [a]", "deleteBy": "(a -> a -> Bool) -> a -> [a] -> [a]", "deleteFirstsBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "unionBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "intersectBy": "(a -> a -> Bool) -> [a] -> [a] -> [a]", "groupBy": "(a -> a -> Bool) -> [a] -> [[a]]", "sortBy": "(a -> a -> Ordering) -> [a] -> [a]", "insertBy": "(a -> a -> Ordering) -> a -> [a] -> [a]", "maximumBy": "(a -> a -> Ordering) -> [a] -> a", "minimumBy": "(a -> a -> Ordering) -> [a] -> a", "genericLength": "Num i => [a] -> i", "genericTake": "Integral i => i -> [a] -> [a]", "genericDrop": "Integral i => i -> [a] -> [a]", "genericSplitAt": "Integral i => i -> [a] -> ([a], [a])", "genericIndex": "Integral i => [a] -> i -> a", "genericReplicate": "Integral i => i -> a -> [a]"}, "GHC.OverloadedLabels": {"IsLabel": "", "fromLabel": "a"}, "GHC.Pack": {"packCString#": "[Char] -> ByteArray#", "unpackCString": "Ptr a -> [Char]", "unpackCString#": "Addr# -> [Char]", "unpackNBytes#": "Addr# -> Int# -> [Char]", "unpackFoldrCString#": "Addr# -> (Char -> a -> a) -> a -> a", "unpackAppendCString#": "Addr# -> [Char] -> [Char]"}, "GHC.Profiling": {"stopProfTimer": "IO ()", "startProfTimer": "IO ()"}, "GHC.Ptr": {"Ptr": "", "from1": "forall (a k0). URec (Ptr ()) a -> Rep1 (URec (Ptr ())) a", "to1": "forall (a k0). Rep1 (URec (Ptr ())) a -> URec (Ptr ()) a", "FunPtr": "", "==": "FunPtr a -> FunPtr a -> Bool", "/=": "FunPtr a -> FunPtr a -> Bool", "nullPtr": "Ptr a", "castPtr": "Ptr a -> Ptr b", "plusPtr": "Ptr a -> Int -> Ptr b", "alignPtr": "Ptr a -> Int -> Ptr a", "minusPtr": "Ptr a -> Ptr b -> Int", "nullFunPtr": "FunPtr a", "castFunPtr": "FunPtr a -> FunPtr b", "castFunPtrToPtr": "FunPtr a -> Ptr b", "castPtrToFunPtr": "Ptr a -> FunPtr b"}, "GHC.RTS.Flags": {"RtsTime": "", "RTSFlags": "", "gcFlags": "GCFlags", "concurrentFlags": "ConcFlags", "miscFlags": "MiscFlags", "debugFlags": "DebugFlags", "costCentreFlags": "CCFlags", "profilingFlags": "ProfFlags", "traceFlags": "TraceFlags", "tickyFlags": "TickyFlags", "parFlags": "ParFlags", "showsPrec": "Int -> a -> ShowS", "show": "a -> String", "showList": "[a] -> ShowS", "GiveGCStats": "", "NoGCStats": "", "CollectGCStats": "", "OneLineGCStats": "", "SummaryGCStats": "", "VerboseGCStats": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "GCFlags": "", "statsFile": "Maybe FilePath", "giveStats": "GiveGCStats", "maxStkSize": "Word32", "initialStkSize": "Word32", "stkChunkSize": "Word32", "stkChunkBufferSize": "Word32", "maxHeapSize": "Word32", "minAllocAreaSize": "Word32", "largeAllocLim": "Word32", "nurseryChunkSize": "Word32", "minOldGenSize": "Word32", "heapSizeSuggestion": "Word32", "heapSizeSuggestionAuto": "Bool", "oldGenFactor": "Double", "pcFreeHeap": "Double", "generations": "Word32", "squeezeUpdFrames": "Bool", "compact": "Bool", "compactThreshold": "Double", "sweep": "Bool", "ringBell": "Bool", "idleGCDelayTime": "RtsTime", "doIdleGC": "Bool", "heapBase": "Word", "allocLimitGrace": "Word", "numa": "Bool", "numaMask": "Word", "ConcFlags": "", "ctxtSwitchTime": "RtsTime", "ctxtSwitchTicks": "Int", "MiscFlags": "", "tickInterval": "RtsTime", "installSignalHandlers": "Bool", "installSEHHandlers": "Bool", "generateCrashDumpFile": "Bool", "generateStackTrace": "Bool", "machineReadable": "Bool", "disableDelayedOsMemoryReturn": "Bool", "internalCounters": "Bool", "linkerAlwaysPic": "Bool", "linkerMemBase": "Word", "ioManager": "IoSubSystem", "numIoWorkerThreads": "Word32", "DebugFlags": "", "scheduler": "Bool", "interpreter": "Bool", "weak": "Bool", "gccafs": "Bool", "gc": "Bool", "nonmoving_gc": "Bool", "block_alloc": "Bool", "sanity": "Bool", "stable": "Bool", "prof": "Bool", "linker": "Bool", "apply": "Bool", "stm": "Bool", "squeeze": "Bool", "hpc": "Bool", "sparks": "Bool", "DoCostCentres": "", "CostCentresNone": "", "CostCentresSummary": "", "CostCentresVerbose": "", "CostCentresAll": "", "CostCentresJSON": "", "CCFlags": "", "doCostCentres": "DoCostCentres", "profilerTicks": "Int", "msecsPerTick": "Int", "DoHeapProfile": "", "NoHeapProfiling": "", "HeapByCCS": "", "HeapByMod": "", "HeapByDescr": "", "HeapByType": "", "HeapByRetainer": "", "HeapByLDV": "", "HeapByClosureType": "", "ProfFlags": "", "doHeapProfile": "DoHeapProfile", "heapProfileInterval": "RtsTime", "heapProfileIntervalTicks": "Word", "includeTSOs": "Bool", "showCCSOnException": "Bool", "maxRetainerSetSize": "Word", "ccsLength": "Word", "modSelector": "Maybe String", "descrSelector": "Maybe String", "typeSelector": "Maybe String", "ccSelector": "Maybe String", "ccsSelector": "Maybe String", "retainerSelector": "Maybe String", "bioSelector": "Maybe String", "DoTrace": "", "TraceNone": "", "TraceEventLog": "", "TraceStderr": "", "TraceFlags": "", "tracing": "DoTrace", "timestamp": "Bool", "traceScheduler": "Bool", "traceGc": "Bool", "traceNonmovingGc": "Bool", "sparksSampled": "Bool", "sparksFull": "Bool", "user": "Bool", "TickyFlags": "", "showTickyStats": "Bool", "tickyFile": "Maybe FilePath", "ParFlags": "", "nCapabilities": "Word32", "migrate": "Bool", "maxLocalSparks": "Word32", "parGcEnabled": "Bool", "parGcGen": "Word32", "parGcLoadBalancingEnabled": "Bool", "parGcLoadBalancingGen": "Word32", "parGcNoSyncWithIdle": "Word32", "parGcThreads": "Word32", "setAffinity": "Bool", "IoSubSystem": "", "IoPOSIX": "", "IoNative": "", "getRTSFlags": "IO RTSFlags", "getGCFlags": "IO GCFlags", "getConcFlags": "IO ConcFlags", "getMiscFlags": "IO MiscFlags", "getIoManagerFlag": "IO IoSubSystem", "getDebugFlags": "IO DebugFlags", "getCCFlags": "IO CCFlags", "getProfFlags": "IO ProfFlags", "getTraceFlags": "IO TraceFlags", "getTickyFlags": "IO TickyFlags", "getParFlags": "IO ParFlags"}, "GHC.Read": {"Read": "", "readsPrec": "", "::": "Int", "->": "ReadS a", "readList": "ReadS [a]", "readPrec": "ReadPrec a", "readListPrec": "ReadPrec [a]", "ReadS": "", "lex": "ReadS String", "lexLitChar": "ReadS String", "readLitChar": "ReadS Char", "lexDigits": "ReadS String", "lexP": "ReadPrec Lexeme", "expectP": "Lexeme -> ReadPrec ()", "paren": "ReadPrec a -> ReadPrec a", "parens": "ReadPrec a -> ReadPrec a", "list": "ReadPrec a -> ReadPrec [a]", "choose": "[(String, ReadPrec a)] -> ReadPrec a", "readListDefault": "Read a => ReadS [a]", "readListPrecDefault": "Read a => ReadPrec [a]", "readNumber": "Num a => (Lexeme -> ReadPrec a) -> ReadPrec a", "readField": "String -> ReadPrec a -> ReadPrec a", "readFieldHash": "String -> ReadPrec a -> ReadPrec a", "readSymField": "String -> ReadPrec a -> ReadPrec a", "readParen": "Bool -> ReadS a -> ReadS a"}, "GHC.Real": {"divZeroError": "a", "ratioZeroDenominatorError": "a", "overflowError": "a", "underflowError": "a", "Ratio": "", "!a": ":% !a", "succ": "Ratio a -> Ratio a", "pred": "Ratio a -> Ratio a", "toEnum": "Int -> Ratio a", "fromEnum": "Ratio a -> Int", "enumFrom": "Ratio a -> [Ratio a]", "enumFromThen": "Ratio a -> Ratio a -> [Ratio a]", "enumFromTo": "Ratio a -> Ratio a -> [Ratio a]", "enumFromThenTo": "Ratio a -> Ratio a -> Ratio a -> [Ratio a]", "Rational": "", "ratioPrec": "Int", "ratioPrec1": "Int", "infinity": "Rational", "notANumber": "Rational", "%": "Integral a => a -> a -> Ratio a infixl 7", "numerator": "Ratio a -> a", "denominator": "Ratio a -> a", "reduce": "Integral a => a -> a -> Ratio a", "Num": "", "toRational": "a -> Rational", "Real": "", "quot": "a -> a -> a infixl 7", "rem": "a -> a -> a infixl 7", "div": "a -> a -> a infixl 7", "mod": "a -> a -> a infixl 7", "quotRem": "a -> a -> (a, a)", "divMod": "a -> a -> (a, a)", "toInteger": "a -> Integer", "/": "a -> a -> a infixl 7", "recip": "a -> a", "fromRational": "Rational -> a", "properFraction": "Integral b => a -> (b, a)", "truncate": "Integral b => a -> b", "round": "Integral b => a -> b", "ceiling": "Integral b => a -> b", "floor": "Integral b => a -> b", "numericEnumFrom": "Fractional a => a -> [a]", "numericEnumFromThen": "Fractional a => a -> a -> [a]", "numericEnumFromTo": "(Ord a, Fractional a) => a -> a -> [a]", "numericEnumFromThenTo": "(Ord a, Fractional a) => a -> a -> a -> [a]", "fromIntegral": "(Integral a, Num b) => a -> b", "realToFrac": "(Real a, Fractional b) => a -> b", "showSigned": "", "even": "Integral a => a -> Bool", "odd": "Integral a => a -> Bool", "^": "(Num a, Integral b) => a -> b -> a infixr 8", "^^": "(Fractional a, Integral b) => a -> b -> a infixr 8", "^%^": "Integral a => Rational -> a -> Rational", "^^%^^": "Integral a => Rational -> a -> Rational", "gcd": "Integral a => a -> a -> a", "lcm": "Integral a => a -> a -> a", "integralEnumFrom": "(Integral a, Bounded a) => a -> [a]", "integralEnumFromThen": "(Integral a, Bounded a) => a -> a -> [a]", "integralEnumFromTo": "Integral a => a -> a -> [a]", "integralEnumFromThenTo": "Integral a => a -> a -> a -> [a]"}, "GHC.Records": {"HasField": "", "getField": "r -> a"}, "GHC.ResponseFile": {"getArgsWithResponseFiles": "IO [String]", "unescapeArgs": "String -> [String]", "escapeArgs": "[String] -> String", "expandResponse": "[String] -> IO [String]"}, "GHC.ST": {"ST": "", ">>=": "ST s a -> (a -> ST s b) -> ST s b", ">>": "ST s a -> ST s b -> ST s b", "return": "a -> ST s a", "STret": "", "STRep": "", "::": "", "liftST": "ST s a -> State# s -> STret s a", "unsafeInterleaveST": "ST s a -> ST s a", "unsafeDupableInterleaveST": "ST s a -> ST s a"}, "GHC.STRef": {"STRef": "", "==": "STRef s a -> STRef s a -> Bool", "/=": "STRef s a -> STRef s a -> Bool", "newSTRef": "a -> ST s (STRef s a)", "readSTRef": "STRef s a -> ST s a", "writeSTRef": "STRef s a -> a -> ST s ()"}, "GHC.Show": {"Show": "", "showsPrec": "", "::": "Int", "->": "a", "show": "a -> String", "showList": "[a] -> ShowS", "ShowS": "", "shows": "Show a => a -> ShowS", "showChar": "Char -> ShowS", "showString": "String -> ShowS", "showMultiLineString": "String -> [String]", "showParen": "Bool -> ShowS -> ShowS", "showList__": "(a -> ShowS) -> [a] -> ShowS", "showCommaSpace": "ShowS", "showSpace": "ShowS", "showLitChar": "Char -> ShowS", "showLitString": "String -> ShowS", "protectEsc": "(Char -> Bool) -> ShowS -> ShowS", "intToDigit": "Int -> Char", "showSignedInt": "Int -> Int -> ShowS", "appPrec": "Int", "appPrec1": "Int", "asciiTab": "[String]"}, "GHC.Stable": {"StablePtr": "", "==": "StablePtr a -> StablePtr a -> Bool", "/=": "StablePtr a -> StablePtr a -> Bool", "newStablePtr": "a -> IO (StablePtr a)", "deRefStablePtr": "StablePtr a -> IO a", "freeStablePtr": "StablePtr a -> IO ()", "castStablePtrToPtr": "StablePtr a -> Ptr ()", "castPtrToStablePtr": "Ptr () -> StablePtr a"}, "GHC.StableName": {"StableName": "", "==": "StableName a -> StableName a -> Bool", "/=": "StableName a -> StableName a -> Bool", "makeStableName": "a -> IO (StableName a)", "hashStableName": "StableName a -> Int", "eqStableName": "StableName a -> StableName b -> Bool"}, "GHC.Stack": {"errorWithStackTrace": "String -> a", "currentCallStack": "IO [String]", "whoCreated": "a -> IO [String]", "CallStack": "", "fromList": "[Item CallStack] -> CallStack", "fromListN": "Int -> [Item CallStack] -> CallStack", "toList": "CallStack -> [Item CallStack]", "HasCallStack": "", "callStack": "HasCallStack => CallStack", "emptyCallStack": "CallStack", "freezeCallStack": "CallStack -> CallStack", "fromCallSiteList": "[([Char], SrcLoc)] -> CallStack", "getCallStack": "CallStack -> [([Char], SrcLoc)]", "popCallStack": "CallStack -> CallStack", "prettyCallStack": "CallStack -> String", "pushCallStack": "([Char], SrcLoc) -> CallStack -> CallStack", "withFrozenCallStack": "HasCallStack => (HasCallStack => a) -> a", "SrcLoc": "", "srcLocPackage": "[Char]", "srcLocModule": "[Char]", "srcLocFile": "[Char]", "srcLocStartLine": "Int", "srcLocStartCol": "Int", "srcLocEndLine": "Int", "srcLocEndCol": "Int", "==": "SrcLoc -> SrcLoc -> Bool", "/=": "SrcLoc -> SrcLoc -> Bool", "prettySrcLoc": "SrcLoc -> String", "CostCentreStack": "", "CostCentre": "", "getCurrentCCS": "dummy -> IO (Ptr CostCentreStack)", "getCCSOf": "a -> IO (Ptr CostCentreStack)", "clearCCS": "IO a -> IO a", "ccsCC": "Ptr CostCentreStack -> IO (Ptr CostCentre)", "ccsParent": "Ptr CostCentreStack -> IO (Ptr CostCentreStack)", "ccLabel": "Ptr CostCentre -> IO CString", "ccModule": "Ptr CostCentre -> IO CString", "ccSrcSpan": "Ptr CostCentre -> IO CString", "ccsToStrings": "Ptr CostCentreStack -> IO [String]", "renderStack": "[String] -> String"}, "GHC.Stack.CCS": {"currentCallStack": "IO [String]", "whoCreated": "a -> IO [String]", "CostCentreStack": "", "CostCentre": "", "getCurrentCCS": "dummy -> IO (Ptr CostCentreStack)", "getCCSOf": "a -> IO (Ptr CostCentreStack)", "clearCCS": "IO a -> IO a", "ccsCC": "Ptr CostCentreStack -> IO (Ptr CostCentre)", "ccsParent": "Ptr CostCentreStack -> IO (Ptr CostCentreStack)", "ccLabel": "Ptr CostCentre -> IO CString", "ccModule": "Ptr CostCentre -> IO CString", "ccSrcSpan": "Ptr CostCentre -> IO CString", "ccsToStrings": "Ptr CostCentreStack -> IO [String]", "renderStack": "[String] -> String"}, "GHC.Stack.Types": {"CallStack": "", "EmptyCallStack": "", "PushCallStack": "[Char] SrcLoc CallStack", "FreezeCallStack": "CallStack", "fromList": "[Item CallStack] -> CallStack", "fromListN": "Int -> [Item CallStack] -> CallStack", "toList": "CallStack -> [Item CallStack]", "HasCallStack": "", "emptyCallStack": "CallStack", "freezeCallStack": "CallStack -> CallStack", "fromCallSiteList": "[([Char], SrcLoc)] -> CallStack", "getCallStack": "CallStack -> [([Char], SrcLoc)]", "pushCallStack": "([Char], SrcLoc) -> CallStack -> CallStack", "SrcLoc": "", "srcLocPackage": "[Char]", "srcLocModule": "[Char]", "srcLocFile": "[Char]", "srcLocStartLine": "Int", "srcLocStartCol": "Int", "srcLocEndLine": "Int", "srcLocEndCol": "Int", "==": "SrcLoc -> SrcLoc -> Bool", "/=": "SrcLoc -> SrcLoc -> Bool"}, "GHC.StaticPtr": {"StaticPtr": "", "fromStaticPtr": "StaticPtr a -> a a", "deRefStaticPtr": "StaticPtr a -> a", "StaticKey": "", "staticKey": "StaticPtr a -> StaticKey", "unsafeLookupStaticPtr": "StaticKey -> IO (Maybe (StaticPtr a))", "StaticPtrInfo": "", "spInfoUnitId": "String", "spInfoModuleName": "String", "spInfoSrcLoc": "(Int, Int)", "showsPrec": "Int -> StaticPtrInfo -> ShowS", "show": "StaticPtrInfo -> String", "showList": "[StaticPtrInfo] -> ShowS", "staticPtrInfo": "StaticPtr a -> StaticPtrInfo", "staticPtrKeys": "IO [StaticKey]", "IsStatic": ""}, "GHC.Stats": {"RTSStats": "", "gcs": "Word32", "major_gcs": "Word32", "allocated_bytes": "Word64", "max_live_bytes": "Word64", "max_large_objects_bytes": "Word64", "max_compact_bytes": "Word64", "max_slop_bytes": "Word64", "max_mem_in_use_bytes": "Word64", "cumulative_live_bytes": "Word64", "copied_bytes": "Word64", "par_copied_bytes": "Word64", "cumulative_par_max_copied_bytes": "Word64", "cumulative_par_balanced_copied_bytes": "Word64", "init_cpu_ns": "RtsTime", "init_elapsed_ns": "RtsTime", "mutator_cpu_ns": "RtsTime", "mutator_elapsed_ns": "RtsTime", "gc_cpu_ns": "RtsTime", "gc_elapsed_ns": "RtsTime", "cpu_ns": "RtsTime", "elapsed_ns": "RtsTime", "nonmoving_gc_sync_cpu_ns": "RtsTime", "nonmoving_gc_sync_elapsed_ns": "RtsTime", "nonmoving_gc_sync_max_elapsed_ns": "RtsTime", "nonmoving_gc_cpu_ns": "RtsTime", "nonmoving_gc_elapsed_ns": "RtsTime", "nonmoving_gc_max_elapsed_ns": "RtsTime", "gc": "GCDetails", "readsPrec": "Int -> ReadS a", "readList": "ReadS [a]", "readPrec": "ReadPrec a", "readListPrec": "ReadPrec [a]", "GCDetails": "", "gcdetails_gen": "Word32", "gcdetails_threads": "Word32", "gcdetails_allocated_bytes": "Word64", "gcdetails_live_bytes": "Word64", "gcdetails_large_objects_bytes": "Word64", "gcdetails_compact_bytes": "Word64", "gcdetails_slop_bytes": "Word64", "gcdetails_mem_in_use_bytes": "Word64", "gcdetails_copied_bytes": "Word64", "gcdetails_par_max_copied_bytes": "Word64", "gcdetails_par_balanced_copied_bytes": "Word64", "gcdetails_sync_elapsed_ns": "RtsTime", "gcdetails_cpu_ns": "RtsTime", "gcdetails_elapsed_ns": "RtsTime", "gcdetails_nonmoving_gc_sync_cpu_ns": "RtsTime", "gcdetails_nonmoving_gc_sync_elapsed_ns": "RtsTime", "RtsTime": "", "getRTSStats": "IO RTSStats", "getRTSStatsEnabled": "IO Bool"}, "GHC.Storable": {"readWideCharOffPtr": "Ptr Char -> Int -> IO Char", "readIntOffPtr": "Ptr Int -> Int -> IO Int", "readWordOffPtr": "Ptr Word -> Int -> IO Word", "readPtrOffPtr": "Ptr (Ptr a) -> Int -> IO (Ptr a)", "readFunPtrOffPtr": "Ptr (FunPtr a) -> Int -> IO (FunPtr a)", "readFloatOffPtr": "Ptr Float -> Int -> IO Float", "readDoubleOffPtr": "Ptr Double -> Int -> IO Double", "readStablePtrOffPtr": "Ptr (StablePtr a) -> Int -> IO (StablePtr a)", "readInt8OffPtr": "Ptr Int8 -> Int -> IO Int8", "readInt16OffPtr": "Ptr Int16 -> Int -> IO Int16", "readInt32OffPtr": "Ptr Int32 -> Int -> IO Int32", "readInt64OffPtr": "Ptr Int64 -> Int -> IO Int64", "readWord8OffPtr": "Ptr Word8 -> Int -> IO Word8", "readWord16OffPtr": "Ptr Word16 -> Int -> IO Word16", "readWord32OffPtr": "Ptr Word32 -> Int -> IO Word32", "readWord64OffPtr": "Ptr Word64 -> Int -> IO Word64", "writeWideCharOffPtr": "Ptr Char -> Int -> Char -> IO ()", "writeIntOffPtr": "Ptr Int -> Int -> Int -> IO ()", "writeWordOffPtr": "Ptr Word -> Int -> Word -> IO ()", "writePtrOffPtr": "Ptr (Ptr a) -> Int -> Ptr a -> IO ()", "writeFunPtrOffPtr": "Ptr (FunPtr a) -> Int -> FunPtr a -> IO ()", "writeFloatOffPtr": "Ptr Float -> Int -> Float -> IO ()", "writeDoubleOffPtr": "Ptr Double -> Int -> Double -> IO ()", "writeStablePtrOffPtr": "Ptr (StablePtr a) -> Int -> StablePtr a -> IO ()", "writeInt8OffPtr": "Ptr Int8 -> Int -> Int8 -> IO ()", "writeInt16OffPtr": "Ptr Int16 -> Int -> Int16 -> IO ()", "writeInt32OffPtr": "Ptr Int32 -> Int -> Int32 -> IO ()", "writeInt64OffPtr": "Ptr Int64 -> Int -> Int64 -> IO ()", "writeWord8OffPtr": "Ptr Word8 -> Int -> Word8 -> IO ()", "writeWord16OffPtr": "Ptr Word16 -> Int -> Word16 -> IO ()", "writeWord32OffPtr": "Ptr Word32 -> Int -> Word32 -> IO ()", "writeWord64OffPtr": "Ptr Word64 -> Int -> Word64 -> IO ()"}, "GHC.TopHandler": {"runMainIO": "IO a -> IO a", "runIO": "IO a -> IO a", "runIOFastExit": "IO a -> IO a", "runNonIO": "a -> IO a", "topHandler": "SomeException -> IO a", "topHandlerFastExit": "SomeException -> IO a", "reportStackOverflow": "IO ()", "reportError": "SomeException -> IO ()", "flushStdHandles": "IO ()"}, "GHC.TypeLits": {"Nat": "", "resolution": "p n -> Integer", "Symbol": "", "KnownNat": "", "::": "", "KnownSymbol": "", "SomeNat": "", "forall": "a n => b (Proxy n)", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "SomeSymbol": "", "someNatVal": "Integer -> Maybe SomeNat", "someSymbolVal": "String -> SomeSymbol", "sameNat": "(KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)", "sameSymbol": "(KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)", "<=": "", "family": "", "ErrorMessage": "", "Text": "Symbol"}, "GHC.TypeNats": {"Nat": "", "resolution": "p n -> Integer", "KnownNat": "", "::": "", "SomeNat": "", "forall": "n.KnownNat n => SomeNat (Proxy n)", "==": "SomeNat -> SomeNat -> Bool", "/=": "SomeNat -> SomeNat -> Bool", "someNatVal": "Natural -> SomeNat", "sameNat": "(KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Maybe (a :~: b)", "<=": "", "family": ""}, "GHC.Unicode": {"unicodeVersion": "Version", "GeneralCategory": "", "UppercaseLetter": "", "LowercaseLetter": "", "TitlecaseLetter": "", "ModifierLetter": "", "OtherLetter": "", "NonSpacingMark": "", "SpacingCombiningMark": "", "EnclosingMark": "", "DecimalNumber": "", "LetterNumber": "", "OtherNumber": "", "ConnectorPunctuation": "", "DashPunctuation": "", "OpenPunctuation": "", "ClosePunctuation": "", "InitialQuote": "", "FinalQuote": "", "OtherPunctuation": "", "MathSymbol": "", "CurrencySymbol": "", "ModifierSymbol": "", "OtherSymbol": "", "Space": "", "LineSeparator": "", "ParagraphSeparator": "", "Control": "", "Format": "", "Surrogate": "", "PrivateUse": "", "NotAssigned": "", "minBound": "GeneralCategory", "maxBound": "GeneralCategory", "generalCategory": "Char -> GeneralCategory", "isAscii": "Char -> Bool", "isLatin1": "Char -> Bool", "isControl": "Char -> Bool", "isAsciiUpper": "Char -> Bool", "isAsciiLower": "Char -> Bool", "isPrint": "Char -> Bool", "isSpace": "Char -> Bool", "isUpper": "Char -> Bool", "isLower": "Char -> Bool", "isAlpha": "Char -> Bool", "isDigit": "Char -> Bool", "isOctDigit": "Char -> Bool", "isHexDigit": "Char -> Bool", "isAlphaNum": "Char -> Bool", "isPunctuation": "Char -> Bool", "isSymbol": "Char -> Bool", "toUpper": "Char -> Char", "toLower": "Char -> Char", "toTitle": "Char -> Char", "wgencat": "Int -> Int"}, "GHC.Weak": {"Weak": "", "mkWeak": "", "deRefWeak": "Weak v -> IO (Maybe v)", "finalize": "Weak v -> IO ()", "runFinalizerBatch": "Int -> Array# (State# RealWorld -> State# RealWorld) -> IO ()"}, "GHC.Word": {"Word": "", "W#": "Word#", "minBound": "a", "maxBound": "a", "Word8": "", "W8#": "Word#", "Word16": "", "W16#": "Word#", "Word32": "", "W32#": "Word#", "Word64": "", "W64#": "Word#", "uncheckedShiftL64#": "Word# -> Int# -> Word#", "uncheckedShiftRL64#": "Word# -> Int# -> Word#", "byteSwap16": "Word16 -> Word16", "byteSwap32": "Word32 -> Word32", "byteSwap64": "Word64 -> Word64", "bitReverse8": "Word8 -> Word8", "bitReverse16": "Word16 -> Word16", "bitReverse32": "Word32 -> Word32", "bitReverse64": "Word64 -> Word64", "eqWord": "Word -> Word -> Bool", "neWord": "Word -> Word -> Bool", "gtWord": "Word -> Word -> Bool", "geWord": "Word -> Word -> Bool", "ltWord": "Word -> Word -> Bool", "leWord": "Word -> Word -> Bool", "eqWord8": "Word8 -> Word8 -> Bool", "neWord8": "Word8 -> Word8 -> Bool", "gtWord8": "Word8 -> Word8 -> Bool", "geWord8": "Word8 -> Word8 -> Bool", "ltWord8": "Word8 -> Word8 -> Bool", "leWord8": "Word8 -> Word8 -> Bool", "eqWord16": "Word16 -> Word16 -> Bool", "neWord16": "Word16 -> Word16 -> Bool", "gtWord16": "Word16 -> Word16 -> Bool", "geWord16": "Word16 -> Word16 -> Bool", "ltWord16": "Word16 -> Word16 -> Bool", "leWord16": "Word16 -> Word16 -> Bool", "eqWord32": "Word32 -> Word32 -> Bool", "neWord32": "Word32 -> Word32 -> Bool", "gtWord32": "Word32 -> Word32 -> Bool", "geWord32": "Word32 -> Word32 -> Bool", "ltWord32": "Word32 -> Word32 -> Bool", "leWord32": "Word32 -> Word32 -> Bool", "eqWord64": "Word64 -> Word64 -> Bool", "neWord64": "Word64 -> Word64 -> Bool", "gtWord64": "Word64 -> Word64 -> Bool", "geWord64": "Word64 -> Word64 -> Bool", "ltWord64": "Word64 -> Word64 -> Bool", "leWord64": "Word64 -> Word64 -> Bool"}, "Numeric": {"showSigned": "", "showIntAtBase": "(Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS", "showInt": "Integral a => a -> ShowS", "showHex": "(Integral a, Show a) => a -> ShowS", "showOct": "(Integral a, Show a) => a -> ShowS", "showEFloat": "RealFloat a => Maybe Int -> a -> ShowS", "showFFloat": "RealFloat a => Maybe Int -> a -> ShowS", "showGFloat": "RealFloat a => Maybe Int -> a -> ShowS", "showFFloatAlt": "RealFloat a => Maybe Int -> a -> ShowS", "showGFloatAlt": "RealFloat a => Maybe Int -> a -> ShowS", "showFloat": "RealFloat a => a -> ShowS", "showHFloat": "RealFloat a => a -> ShowS", "floatToDigits": "RealFloat a => Integer -> a -> ([Int], Int)", "readSigned": "Real a => ReadS a -> ReadS a", "readInt": "", "readDec": "(Eq a, Num a) => ReadS a", "readOct": "(Eq a, Num a) => ReadS a", "readHex": "(Eq a, Num a) => ReadS a", "readFloat": "RealFrac a => ReadS a", "lexDigits": "ReadS String", "fromRat": "RealFloat a => Rational -> a", "Fractional": "", "pi": "a", "exp": "a -> a", "log": "a -> a", "sqrt": "a -> a", "**": "a -> a -> a infixr 8", "logBase": "a -> a -> a", "sin": "a -> a", "cos": "a -> a", "tan": "a -> a", "asin": "a -> a", "acos": "a -> a", "atan": "a -> a", "sinh": "a -> a", "cosh": "a -> a", "tanh": "a -> a", "asinh": "a -> a", "acosh": "a -> a", "atanh": "a -> a", "log1p": "a -> a", "expm1": "a -> a", "log1pexp": "a -> a", "log1mexp": "a -> a"}, "Numeric.Natural": {"Natural": "", "succ": "Natural -> Natural", "pred": "Natural -> Natural", "toEnum": "Int -> Natural", "fromEnum": "Natural -> Int", "enumFrom": "Natural -> [Natural]", "enumFromThen": "Natural -> Natural -> [Natural]", "enumFromTo": "Natural -> Natural -> [Natural]", "enumFromThenTo": "Natural -> Natural -> Natural -> [Natural]"}, "System.CPUTime": {"getCPUTime": "IO Integer", "cpuTimePrecision": "Integer"}, "System.Console.GetOpt": {"getOpt": "ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])", "getOpt'": "ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])", "usageInfo": "String -> [OptDescr a] -> String", "ArgOrder": "", "RequireOrder": "", "Permute": "", "ReturnInOrder": "(String -> a)", "fmap": "(a -> b) -> a a -> a b", "<$": "a -> a b -> a a", "OptDescr": "", "Option": "[Char] [String] (ArgDescr a) String", "ArgDescr": "", "NoArg": "a", "ReqArg": "(String -> a) String", "OptArg": "(Maybe String -> a) String"}, "System.Environment": {"getArgs": "IO [String]", "getProgName": "IO String", "getExecutablePath": "IO FilePath", "getEnv": "String -> IO String", "lookupEnv": "String -> IO (Maybe String)", "setEnv": "String -> String -> IO ()", "unsetEnv": "String -> IO ()", "withArgs": "[String] -> IO a -> IO a", "withProgName": "String -> IO a -> IO a", "getEnvironment": "IO [(String, String)]"}, "System.Environment.Blank": {"getExecutablePath": "IO FilePath", "getArgs": "IO [String]", "getProgName": "IO String", "withArgs": "[String] -> IO a -> IO a", "withProgName": "String -> IO a -> IO a", "getEnvironment": "IO [(String, String)]", "getEnv": "String -> IO (Maybe String)", "getEnvDefault": "", "setEnv": "", "unsetEnv": "String -> IO ()"}, "System.Exit": {"ExitCode": "", "ExitSuccess": "", "ExitFailure": "Int", "==": "ExitCode -> ExitCode -> Bool", "/=": "ExitCode -> ExitCode -> Bool", "exitWith": "ExitCode -> IO a", "exitFailure": "IO a", "exitSuccess": "IO a", "die": "String -> IO a"}, "System.IO": {"IO": "", ">>=": "IO a -> (a -> IO b) -> IO b", ">>": "IO a -> IO b -> IO b", "return": "a -> IO a", "fixIO": "(a -> IO a) -> IO a", "FilePath": "", "Handle": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "stdin": "Handle", "stdout": "Handle", "stderr": "Handle", "withFile": "FilePath -> IOMode -> (Handle -> IO r) -> IO r", "openFile": "FilePath -> IOMode -> IO Handle", "IOMode": "", "ReadMode": "", "WriteMode": "", "AppendMode": "", "ReadWriteMode": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "hClose": "Handle -> IO ()", "readFile": "FilePath -> IO String", "readFile'": "FilePath -> IO String", "writeFile": "FilePath -> String -> IO ()", "appendFile": "FilePath -> String -> IO ()", "hFileSize": "Handle -> IO Integer", "hSetFileSize": "Handle -> Integer -> IO ()", "hIsEOF": "Handle -> IO Bool", "isEOF": "IO Bool", "BufferMode": "", "NoBuffering": "", "LineBuffering": "", "BlockBuffering": "(Maybe Int)", "hSetBuffering": "Handle -> BufferMode -> IO ()", "hGetBuffering": "Handle -> IO BufferMode", "hFlush": "Handle -> IO ()", "hGetPosn": "Handle -> IO HandlePosn", "hSetPosn": "HandlePosn -> IO ()", "HandlePosn": "", "hSeek": "Handle -> SeekMode -> Integer -> IO ()", "SeekMode": "", "AbsoluteSeek": "", "RelativeSeek": "", "SeekFromEnd": "", "hTell": "Handle -> IO Integer", "hIsOpen": "Handle -> IO Bool", "hIsClosed": "Handle -> IO Bool", "hIsReadable": "Handle -> IO Bool", "hIsWritable": "Handle -> IO Bool", "hIsSeekable": "Handle -> IO Bool", "hIsTerminalDevice": "Handle -> IO Bool", "hSetEcho": "Handle -> Bool -> IO ()", "hGetEcho": "Handle -> IO Bool", "hShow": "Handle -> IO String", "hWaitForInput": "Handle -> Int -> IO Bool", "hReady": "Handle -> IO Bool", "hGetChar": "Handle -> IO Char", "hGetLine": "Handle -> IO String", "hLookAhead": "Handle -> IO Char", "hGetContents": "Handle -> IO String", "hGetContents'": "Handle -> IO String", "hPutChar": "Handle -> Char -> IO ()", "hPutStr": "Handle -> String -> IO ()", "hPutStrLn": "Handle -> String -> IO ()", "hPrint": "Show a => Handle -> a -> IO ()", "interact": "(String -> String) -> IO ()", "putChar": "Char -> IO ()", "putStr": "String -> IO ()", "putStrLn": "String -> IO ()", "print": "Show a => a -> IO ()", "getChar": "IO Char", "getLine": "IO String", "getContents": "IO String", "getContents'": "IO String", "readIO": "Read a => String -> IO a", "readLn": "Read a => IO a", "withBinaryFile": "FilePath -> IOMode -> (Handle -> IO r) -> IO r", "openBinaryFile": "FilePath -> IOMode -> IO Handle", "hSetBinaryMode": "Handle -> Bool -> IO ()", "hPutBuf": "Handle -> Ptr a -> Int -> IO ()", "hGetBuf": "Handle -> Ptr a -> Int -> IO Int", "hGetBufSome": "Handle -> Ptr a -> Int -> IO Int", "hPutBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int", "hGetBufNonBlocking": "Handle -> Ptr a -> Int -> IO Int", "openTempFile": "", "openBinaryTempFile": "FilePath -> String -> IO (FilePath, Handle)", "openTempFileWithDefaultPermissions": "FilePath -> String -> IO (FilePath, Handle)", "openBinaryTempFileWithDefaultPermissions": "FilePath -> String -> IO (FilePath, Handle)", "hSetEncoding": "Handle -> TextEncoding -> IO ()", "hGetEncoding": "Handle -> IO (Maybe TextEncoding)", "TextEncoding": "", "showsPrec": "Int -> TextEncoding -> ShowS", "show": "TextEncoding -> String", "showList": "[TextEncoding] -> ShowS", "latin1": "TextEncoding", "utf8": "TextEncoding", "utf8_bom": "TextEncoding", "utf16": "TextEncoding", "utf16le": "TextEncoding", "utf16be": "TextEncoding", "utf32": "TextEncoding", "utf32le": "TextEncoding", "utf32be": "TextEncoding", "localeEncoding": "TextEncoding", "char8": "TextEncoding", "mkTextEncoding": "String -> IO TextEncoding", "hSetNewlineMode": "Handle -> NewlineMode -> IO ()", "Newline": "", "LF": "", "CRLF": "", "nativeNewline": "Newline", "NewlineMode": "", "inputNL": "Newline", "outputNL": "Newline", "noNewlineTranslation": "NewlineMode", "universalNewlineMode": "NewlineMode", "nativeNewlineMode": "NewlineMode"}, "System.IO.Error": {"IOError": "", "userError": "String -> IOError", "mkIOError": "IOErrorType -> String -> Maybe Handle -> Maybe FilePath -> IOError", "annotateIOError": "IOError -> String -> Maybe Handle -> Maybe FilePath -> IOError", "isAlreadyExistsError": "IOError -> Bool", "isDoesNotExistError": "IOError -> Bool", "isAlreadyInUseError": "IOError -> Bool", "isFullError": "IOError -> Bool", "isEOFError": "IOError -> Bool", "isIllegalOperation": "IOError -> Bool", "isPermissionError": "IOError -> Bool", "isUserError": "IOError -> Bool", "isResourceVanishedError": "IOError -> Bool", "ioeGetErrorType": "IOError -> IOErrorType", "ioeGetLocation": "IOError -> String", "ioeGetErrorString": "IOError -> String", "ioeGetHandle": "IOError -> Maybe Handle", "ioeGetFileName": "IOError -> Maybe FilePath", "ioeSetErrorType": "IOError -> IOErrorType -> IOError", "ioeSetErrorString": "IOError -> String -> IOError", "ioeSetLocation": "IOError -> String -> IOError", "ioeSetHandle": "IOError -> Handle -> IOError", "ioeSetFileName": "IOError -> FilePath -> IOError", "IOErrorType": "", "==": "IOErrorType -> IOErrorType -> Bool", "/=": "IOErrorType -> IOErrorType -> Bool", "alreadyExistsErrorType": "IOErrorType", "doesNotExistErrorType": "IOErrorType", "alreadyInUseErrorType": "IOErrorType", "fullErrorType": "IOErrorType", "eofErrorType": "IOErrorType", "illegalOperationErrorType": "IOErrorType", "permissionErrorType": "IOErrorType", "userErrorType": "IOErrorType", "resourceVanishedErrorType": "IOErrorType", "isAlreadyExistsErrorType": "IOErrorType -> Bool", "isDoesNotExistErrorType": "IOErrorType -> Bool", "isAlreadyInUseErrorType": "IOErrorType -> Bool", "isFullErrorType": "IOErrorType -> Bool", "isEOFErrorType": "IOErrorType -> Bool", "isIllegalOperationErrorType": "IOErrorType -> Bool", "isPermissionErrorType": "IOErrorType -> Bool", "isUserErrorType": "IOErrorType -> Bool", "isResourceVanishedErrorType": "IOErrorType -> Bool", "ioError": "IOError -> IO a", "catchIOError": "IO a -> (IOError -> IO a) -> IO a", "tryIOError": "IO a -> IO (Either IOError a)", "modifyIOError": "(IOError -> IOError) -> IO a -> IO a"}, "System.IO.Unsafe": {"unsafePerformIO": "IO a -> a", "unsafeDupablePerformIO": "IO a -> a", "unsafeInterleaveIO": "IO a -> IO a", "unsafeFixIO": "(a -> IO a) -> IO a"}, "System.Info": {"os": "String", "arch": "String", "compilerName": "String", "compilerVersion": "Version", "fullCompilerVersion": "Version"}, "System.Mem": {"performGC": "IO ()", "performMajorGC": "IO ()", "performMinorGC": "IO ()", "setAllocationCounter": "Int64 -> IO ()", "getAllocationCounter": "IO Int64", "enableAllocationLimit": "IO ()", "disableAllocationLimit": "IO ()"}, "System.Mem.StableName": {"StableName": "", "==": "StableName a -> StableName a -> Bool", "/=": "StableName a -> StableName a -> Bool", "makeStableName": "a -> IO (StableName a)", "hashStableName": "StableName a -> Int", "eqStableName": "StableName a -> StableName b -> Bool"}, "System.Mem.Weak": {"Weak": "", "mkWeak": "", "deRefWeak": "Weak v -> IO (Maybe v)", "finalize": "Weak v -> IO ()", "mkWeakPtr": "k -> Maybe (IO ()) -> IO (Weak k)", "addFinalizer": "key -> IO () -> IO ()", "mkWeakPair": "k -> v -> Maybe (IO ()) -> IO (Weak (k, v))"}, "System.Posix.Internals": {"puts": "String -> IO ()", "CFLock": "", "CGroup": "", "CLconv": "", "CPasswd": "", "CSigaction": "", "CSigset": "", "CStat": "", "CTermios": "", "CTm": "", "CTms": "", "CUtimbuf": "", "CUtsname": "", "FD": "", "fdFileSize": "FD -> IO Integer", "fileType": "FilePath -> IO IODeviceType", "fdStat": "FD -> IO (IODeviceType, CDev, CIno)", "fdType": "FD -> IO IODeviceType", "statGetType": "Ptr CStat -> IO IODeviceType", "ioe_unknownfiletype": "IOException", "fdGetMode": "FD -> IO IOMode", "withFilePath": "FilePath -> (CString -> IO a) -> IO a", "newFilePath": "FilePath -> IO CString", "peekFilePath": "CString -> IO FilePath", "peekFilePathLen": "CStringLen -> IO FilePath", "setEcho": "FD -> Bool -> IO ()", "getEcho": "FD -> IO Bool", "setCooked": "FD -> Bool -> IO ()", "tcSetAttr": "FD -> (Ptr CTermios -> IO a) -> IO a", "get_saved_termios": "CInt -> IO (Ptr CTermios)", "set_saved_termios": "CInt -> Ptr CTermios -> IO ()", "setNonBlockingFD": "FD -> Bool -> IO ()", "setCloseOnExec": "FD -> IO ()", "CFilePath": "", "c_open": "CFilePath -> CInt -> CMode -> IO CInt", "c_safe_open": "CFilePath -> CInt -> CMode -> IO CInt", "c_fstat": "CInt -> Ptr CStat -> IO CInt", "lstat": "CFilePath -> Ptr CStat -> IO CInt", "c_lseek": "CInt -> COff -> CInt -> IO COff", "c_access": "CString -> CInt -> IO CInt", "c_chmod": "CString -> CMode -> IO CInt", "c_close": "CInt -> IO CInt", "c_creat": "CString -> CMode -> IO CInt", "c_dup": "CInt -> IO CInt", "c_dup2": "CInt -> CInt -> IO CInt", "c_isatty": "CInt -> IO CInt", "c_read": "CInt -> Ptr Word8 -> CSize -> IO CSsize", "c_safe_read": "CInt -> Ptr Word8 -> CSize -> IO CSsize", "c_umask": "CMode -> IO CMode", "c_write": "CInt -> Ptr Word8 -> CSize -> IO CSsize", "c_safe_write": "CInt -> Ptr Word8 -> CSize -> IO CSsize", "c_pipe": "Ptr CInt -> IO CInt", "c_unlink": "CString -> IO CInt", "c_utime": "CString -> Ptr CUtimbuf -> IO CInt", "c_getpid": "IO CPid", "c_stat": "CFilePath -> Ptr CStat -> IO CInt", "c_ftruncate": "CInt -> COff -> IO CInt", "c_fcntl_read": "CInt -> CInt -> IO CInt", "c_fcntl_write": "CInt -> CInt -> CLong -> IO CInt", "c_fcntl_lock": "CInt -> CInt -> Ptr CFLock -> IO CInt", "c_fork": "IO CPid", "c_link": "CString -> CString -> IO CInt", "c_mkfifo": "CString -> CMode -> IO CInt", "c_sigemptyset": "Ptr CSigset -> IO CInt", "c_sigaddset": "Ptr CSigset -> CInt -> IO CInt", "c_sigprocmask": "CInt -> Ptr CSigset -> Ptr CSigset -> IO CInt", "c_tcgetattr": "CInt -> Ptr CTermios -> IO CInt", "c_tcsetattr": "CInt -> CInt -> Ptr CTermios -> IO CInt", "c_waitpid": "CPid -> Ptr CInt -> CInt -> IO CPid", "o_RDONLY": "CInt", "o_WRONLY": "CInt", "o_RDWR": "CInt", "o_APPEND": "CInt", "o_CREAT": "CInt", "o_EXCL": "CInt", "o_TRUNC": "CInt", "o_NOCTTY": "CInt", "o_NONBLOCK": "CInt", "o_BINARY": "CInt", "c_s_isreg": "CMode -> CInt", "c_s_ischr": "CMode -> CInt", "c_s_isblk": "CMode -> CInt", "c_s_isdir": "CMode -> CInt", "c_s_isfifo": "CMode -> CInt", "s_isreg": "CMode -> Bool", "s_ischr": "CMode -> Bool", "s_isblk": "CMode -> Bool", "s_isdir": "CMode -> Bool", "s_isfifo": "CMode -> Bool", "sizeof_stat": "Int", "st_mtime": "Ptr CStat -> IO CTime", "st_size": "Ptr CStat -> IO COff", "st_mode": "Ptr CStat -> IO CMode", "st_dev": "Ptr CStat -> IO CDev", "st_ino": "Ptr CStat -> IO CIno", "const_echo": "CInt", "const_tcsanow": "CInt", "const_icanon": "CInt", "const_vmin": "CInt", "const_vtime": "CInt", "const_sigttou": "CInt", "const_sig_block": "CInt", "const_sig_setmask": "CInt", "const_f_getfl": "CInt", "const_f_setfl": "CInt", "const_f_setfd": "CInt", "const_fd_cloexec": "CLong", "sizeof_termios": "Int", "sizeof_sigset_t": "Int", "c_lflag": "Ptr CTermios -> IO CTcflag", "poke_c_lflag": "Ptr CTermios -> CTcflag -> IO ()", "ptr_c_cc": "Ptr CTermios -> IO (Ptr Word8)", "s_issock": "CMode -> Bool", "c_s_issock": "CMode -> CInt", "dEFAULT_BUFFER_SIZE": "Int", "sEEK_CUR": "CInt", "sEEK_SET": "CInt", "sEEK_END": "CInt"}, "System.Posix.Types": {"CDev": "", "minBound": "a", "maxBound": "a", "CIno": "", "CMode": "", "COff": "", "CPid": "", "CSsize": "", "CGid": "", "CNlink": "", "CUid": "", "CCc": "", "succ": "a -> a", "pred": "a -> a", "toEnum": "Int -> a", "fromEnum": "a -> Int", "enumFrom": "a -> [a]", "enumFromThen": "a -> a -> [a]", "enumFromTo": "a -> a -> [a]", "enumFromThenTo": "a -> a -> a -> [a]", "CSpeed": "", "CTcflag": "", "CRLim": "", "CBlkSize": "", "CBlkCnt": "", "CClockId": "", "CFsBlkCnt": "", "CFsFilCnt": "", "CId": "", "CKey": "", "CTimer": "", "==": "CTimer -> CTimer -> Bool", "/=": "CTimer -> CTimer -> Bool", "CSocklen": "", "CNfds": "", "Fd": "", "LinkCount": "", "UserID": "", "GroupID": "", "ByteCount": "", "ClockTick": "", "EpochTime": "", "FileOffset": "", "ProcessID": "", "ProcessGroupID": "", "DeviceID": "", "FileID": "", "FileMode": "", "Limit": ""}, "System.Timeout": {"Timeout": "", "==": "Timeout -> Timeout -> Bool", "/=": "Timeout -> Timeout -> Bool", "timeout": "Int -> IO a -> IO (Maybe a)"}, "Text.ParserCombinators.ReadP": {"ReadP": "", ">>=": "ReadP a -> (a -> ReadP b) -> ReadP b", ">>": "ReadP a -> ReadP b -> ReadP b", "return": "a -> ReadP a", "get": "ReadP Char", "look": "ReadP String", "+++": "ReadP a -> ReadP a -> ReadP a infixr 5", "<++": "ReadP a -> ReadP a -> ReadP a infixr 5", "gather": "ReadP a -> ReadP (String, a)", "pfail": "ReadP a", "eof": "ReadP ()", "satisfy": "(Char -> Bool) -> ReadP Char", "char": "Char -> ReadP Char", "string": "String -> ReadP String", "munch": "(Char -> Bool) -> ReadP String", "munch1": "(Char -> Bool) -> ReadP String", "skipSpaces": "ReadP ()", "choice": "[ReadP a] -> ReadP a", "count": "Int -> ReadP a -> ReadP [a]", "between": "ReadP open -> ReadP close -> ReadP a -> ReadP a", "option": "a -> ReadP a -> ReadP a", "optional": "ReadP a -> ReadP ()", "many": "ReadP a -> ReadP [a]", "many1": "ReadP a -> ReadP [a]", "skipMany": "ReadP a -> ReadP ()", "skipMany1": "ReadP a -> ReadP ()", "sepBy": "ReadP a -> ReadP sep -> ReadP [a]", "sepBy1": "ReadP a -> ReadP sep -> ReadP [a]", "endBy": "ReadP a -> ReadP sep -> ReadP [a]", "endBy1": "ReadP a -> ReadP sep -> ReadP [a]", "chainr": "ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a", "chainl": "ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a", "chainl1": "ReadP a -> ReadP (a -> a -> a) -> ReadP a", "chainr1": "ReadP a -> ReadP (a -> a -> a) -> ReadP a", "manyTill": "ReadP a -> ReadP end -> ReadP [a]", "ReadS": "", "readP_to_S": "ReadP a -> ReadS a", "readS_to_P": "ReadS a -> ReadP a"}, "Text.ParserCombinators.ReadPrec": {"ReadPrec": "", ">>=": "ReadPrec a -> (a -> ReadPrec b) -> ReadPrec b", ">>": "ReadPrec a -> ReadPrec b -> ReadPrec b", "return": "a -> ReadPrec a", "Prec": "", "minPrec": "Prec", "lift": "ReadP a -> ReadPrec a", "prec": "Prec -> ReadPrec a -> ReadPrec a", "step": "ReadPrec a -> ReadPrec a", "reset": "ReadPrec a -> ReadPrec a", "get": "ReadPrec Char", "look": "ReadPrec String", "+++": "ReadPrec a -> ReadPrec a -> ReadPrec a", "<++": "ReadPrec a -> ReadPrec a -> ReadPrec a", "pfail": "ReadPrec a", "choice": "[ReadPrec a] -> ReadPrec a", "readPrec_to_P": "ReadPrec a -> Int -> ReadP a", "readP_to_Prec": "(Int -> ReadP a) -> ReadPrec a", "readPrec_to_S": "ReadPrec a -> Int -> ReadS a", "readS_to_Prec": "(Int -> ReadS a) -> ReadPrec a"}, "Text.Printf": {"printf": "PrintfType r => String -> r", "hPrintf": "HPrintfType r => Handle -> String -> r", "PrintfArg": "", "formatArg": "a -> FieldFormatter", "parseFormat": "a -> ModifierParser", "FieldFormatter": "", "FieldFormat": "", "fmtWidth": "Maybe Int", "fmtPrecision": "Maybe Int", "fmtAdjust": "Maybe FormatAdjustment", "fmtSign": "Maybe FormatSign", "fmtAlternate": "Bool", "fmtModifiers": "String", "fmtChar": "Char", "FormatAdjustment": "", "LeftAdjust": "", "ZeroPad": "", "FormatSign": "", "SignPlus": "", "SignSpace": "", "vFmt": "Char -> FieldFormat -> FieldFormat", "ModifierParser": "", "FormatParse": "", "fpModifiers": "String", "fpChar": "Char", "fpRest": "String", "formatString": "IsChar a => [a] -> FieldFormatter", "formatChar": "Char -> FieldFormatter", "formatInt": "(Integral a, Bounded a) => a -> FieldFormatter", "formatInteger": "Integer -> FieldFormatter", "formatRealFloat": "RealFloat a => a -> FieldFormatter", "errorBadFormat": "Char -> a", "errorShortFormat": "a", "errorMissingArgument": "a", "errorBadArgument": "a", "perror": "String -> a", "PrintfType": "", "spr": "String -> [UPrintf] -> [c]", "HPrintfType": "", "hspr": "Handle -> String -> [UPrintf] -> IO a", "IsChar": "", "toChar": "c -> Char", "fromChar": "Char -> c"}, "Text.Read": {"Read": "", "readsPrec": "", "::": "Int", "->": "ReadS a", "readList": "ReadS [a]", "readPrec": "ReadPrec a", "readListPrec": "ReadPrec [a]", "ReadS": "", "reads": "Read a => ReadS a", "read": "Read a => String -> a", "readParen": "Bool -> ReadS a -> ReadS a", "lex": "ReadS String", "module": "Text.ParserCombinators.ReadPrec", "Lexeme": "", "Char": "Char", "String": "String", "Punc": "String", "Ident": "String", "Symbol": "String", "Number": "Number", "EOF": "", "==": "Lexeme -> Lexeme -> Bool", "/=": "Lexeme -> Lexeme -> Bool", "lexP": "ReadPrec Lexeme", "parens": "ReadPrec a -> ReadPrec a", "readListDefault": "Read a => ReadS [a]", "readListPrecDefault": "Read a => ReadPrec [a]", "readEither": "Read a => String -> Either String a", "readMaybe": "Read a => String -> Maybe a"}, "Text.Read.Lex": {"Lexeme": "", "Char": "Char", "String": "String", "Punc": "String", "Ident": "String", "Symbol": "String", "Number": "", "EOF": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "numberToInteger": "Number -> Maybe Integer", "numberToFixed": "Integer -> Number -> Maybe (Integer, Integer)", "numberToRational": "Number -> Rational", "numberToRangedRational": "(Int, Int) -> Number -> Maybe Rational", "lex": "ReadP Lexeme", "expect": "Lexeme -> ReadP ()", "hsLex": "ReadP String", "lexChar": "ReadP Char", "readIntP": "Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a", "readOctP": "(Eq a, Num a) => ReadP a", "readDecP": "(Eq a, Num a) => ReadP a", "readHexP": "(Eq a, Num a) => ReadP a", "isSymbolChar": "Char -> Bool"}, "Text.Show": {"ShowS": "", "Show": "", "showsPrec": "", "::": "Int", "->": "a", "show": "a -> String", "showList": "[a] -> ShowS", "shows": "Show a => a -> ShowS", "showChar": "Char -> ShowS", "showString": "String -> ShowS", "showParen": "Bool -> ShowS -> ShowS", "showListWith": "(a -> ShowS) -> [a] -> ShowS"}, "Text.Show.Functions": {}, "Type.Reflection": {"Typeable": "", "typeRep": "Typeable a => TypeRep a", "::": "", "a": "", "Refl": "a :~: a", "id": "forall (a k0). a a a", ".": "forall (b k0) (c k0) (a k0). (b a c) -> (a a b) -> a a c", "HRefl": "a :~~: a", "TypeRep": "", "testEquality": "forall (a k0) (b k0). TypeRep a -> TypeRep b -> Maybe (a :~: b)", "typeOf": "Typeable a => a -> TypeRep a", "App": "", "Con": "", "Con'": "", "Fun": "", "typeRepTyCon": "TypeRep a -> TyCon", "rnfTypeRep": "TypeRep a -> ()", "typeRepKind": "TypeRep (a k) -> TypeRep k", "splitApps": "TypeRep a -> (TyCon, [SomeTypeRep])", "SomeTypeRep": "", "==": "a -> a -> Bool", "/=": "a -> a -> Bool", "someTypeRepTyCon": "SomeTypeRep -> TyCon", "rnfSomeTypeRep": "SomeTypeRep -> ()", "TyCon": "", "tyConPackage": "TyCon -> String", "tyConModule": "TyCon -> String", "tyConName": "TyCon -> String", "rnfTyCon": "TyCon -> ()", "Module": "", "moduleName": "Module -> String", "modulePackage": "Module -> String", "rnfModule": "Module -> ()"}, "Type.Reflection.Unsafe": {"TypeRep": "", "testEquality": "forall (a k0) (b k0). TypeRep a -> TypeRep b -> Maybe (a :~: b)", "::": "", "mkTyCon": "", "typeRepFingerprint": "TypeRep a -> Fingerprint", "someTypeRepFingerprint": "SomeTypeRep -> Fingerprint", "KindRep": "", "KindRepTyConApp": "TyCon [KindRep]", "KindRepVar": "!KindBndr", "KindRepApp": "KindRep KindRep", "KindRepFun": "KindRep KindRep", "KindRepTYPE": "!RuntimeRep", "KindRepTypeLitS": "TypeLitSort Addr#", "KindRepTypeLitD": "TypeLitSort [Char]", "showsPrec": "Int -> a -> ShowS", "show": "a -> String", "showList": "[a] -> ShowS", "TypeLitSort": "", "TypeLitSymbol": "", "TypeLitNat": "", "TyCon": "", "==": "TyCon -> TyCon -> Bool", "/=": "TyCon -> TyCon -> Bool", "tyConKindRep": "TyCon -> KindRep", "tyConKindArgs": "TyCon -> Int", "tyConFingerprint": "TyCon -> Fingerprint"}, "Unsafe.Coerce": {"::": "", "UnsafeEquality": "", "UnsafeRefl": "UnsafeEquality a a"}}